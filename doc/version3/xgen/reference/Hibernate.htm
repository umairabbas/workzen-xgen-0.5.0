<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0059)http://www.hibernate.org/hib_docs/reference/en/html_single/ -->
<HTML><HEAD><TITLE>HIBERNATE - Relational Persistence for Idiomatic Java</TITLE>
<META http-equiv=Content-Type content="text/html; charset=ISO-8859-1"><LINK 
href="Hibernate_files/html.css" type=text/css rel=stylesheet>
<META content="MSHTML 6.00.2800.1400" name=GENERATOR></HEAD>
<BODY text=black vLink=#840084 aLink=#0000ff link=#0000ff bgColor=white>
<DIV class=book lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H1 class=title><A name=d0e1></A>HIBERNATE - Relational Persistence for 
Idiomatic Java</H1></DIV>
<DIV>
<H2 class=subtitle>Hibernate Reference Documentation</H2></DIV>
<DIV>
<P class=releaseinfo>2.1.3</P></DIV></DIV>
<DIV></DIV>
<HR>
</DIV>
<DIV class=toc>
<P><B>Table of Contents</B></P>
<DL>
  <DT><SPAN class=preface><A 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#preface">Preface</A></SPAN>
  <DT><SPAN class=chapter><A 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#quickstart">1. 
  Quickstart with Tomcat</A></SPAN>
  <DD>
  <DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#quickstart-intro">1.1. 
    Getting started with Hibernate</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#quickstart-persistentclass">1.2. 
    First persistent class</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#quickstart-mapping">1.3. 
    Mapping the cat</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#quickstart-playingwithcats">1.4. 
    Playing with cats</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#quickstart-summary">1.5. 
    Finally</A></SPAN></DT></DL>
  <DT><SPAN class=chapter><A 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#architecture">2. 
  Architecture</A></SPAN>
  <DD>
  <DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#architecture-overview">2.1. 
    Overview</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#architecture-jmx">2.2. 
    JMX Integration</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#architecture-jca">2.3. 
    JCA Support</A></SPAN></DT></DL>
  <DT><SPAN class=chapter><A 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#session-configuration">3. 
  SessionFactory Configuration</A></SPAN>
  <DD>
  <DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#configuration-programmatic">3.1. 
    Programmatic Configuration</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#configuration-sessionfactory">3.2. 
    Obtaining a SessionFactory</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#configuration-userjdbc">3.3. 
    User provided JDBC connection</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#configuration-hibernatejdbc">3.4. 
    Hibernate provided JDBC connection</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#configuration-optional">3.5. 
    Optional configuration properties</A></SPAN>
    <DD>
    <DL>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#configuration-optional-dialects">3.5.1. 
      SQL Dialects</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#configuration-optional-outerjoin">3.5.2. 
      Outer Join Fetching</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#configuration-optional-binarystreams">3.5.3. 
      Binary Streams</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#configuration-optional-cacheprovider">3.5.4. 
      Custom CacheProvider</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#configuration-optional-transactionstrategy">3.5.5. 
      Transaction strategy configuration</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#configuration-optional-jndi">3.5.6. 
      JNDI-bound SessionFactory</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#configuration-optional-querysubstitution">3.5.7. 
      Query Language Substitution</A></SPAN></DT></DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#configuration-logging">3.6. 
    Logging</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#configuration-namingstrategy">3.7. 
    Implementing a NamingStrategy</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#configuration-xmlconfig">3.8. 
    XML Configuration File</A></SPAN></DT></DL>
  <DT><SPAN class=chapter><A 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#persistent-classes">4. 
  Persistent Classes</A></SPAN>
  <DD>
  <DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#persistent-classes-pojo">4.1. 
    A simple POJO example</A></SPAN>
    <DD>
    <DL>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#persistent-classes-pojo-accessors">4.1.1. 
      Declare accessors and mutators for persistent fields</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#persistent-classes-pojo-constructor">4.1.2. 
      Implement a default constructor</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#persistent-classes-pojo-identifier">4.1.3. 
      Provide an identifier property (optional)</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#persistent-classes-pojo-final">4.1.4. 
      Prefer non-final classes (optional)</A></SPAN></DT></DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#persistent-classes-inheritance">4.2. 
    Implementing inheritance</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#persistent-classes-equalshashcode">4.3. 
    Implementing equals() and hashCode()</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#persistent-classes-lifecycle">4.4. 
    Lifecycle Callbacks</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#persistent-classes-validatable">4.5. 
    Validatable callback</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#persistent-classes-xdoclet">4.6. 
    Using XDOclet markup</A></SPAN></DT></DL>
  <DT><SPAN class=chapter><A 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping">5. 
  Basic O/R Mapping</A></SPAN>
  <DD>
  <DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-declaration">5.1. 
    Mapping declaration</A></SPAN>
    <DD>
    <DL>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-declaration-doctype">5.1.1. 
      Doctype</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-declaration-mapping">5.1.2. 
      hibernate-mapping</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-declaration-class">5.1.3. 
      class</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-declaration-id">5.1.4. 
      id</A></SPAN>
      <DD>
      <DL>
        <DT><SPAN class=sect3><A 
        href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-declaration-id-generator">5.1.4.1. 
        generator</A></SPAN>
        <DT><SPAN class=sect3><A 
        href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-declaration-id-hilo">5.1.4.2. 
        Hi/Lo Algorithm</A></SPAN>
        <DT><SPAN class=sect3><A 
        href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-declaration-id-uuid">5.1.4.3. 
        UUID Algorithm</A></SPAN>
        <DT><SPAN class=sect3><A 
        href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-declaration-id-sequences">5.1.4.4. 
        Identity columns and Sequences</A></SPAN>
        <DT><SPAN class=sect3><A 
        href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-declaration-id-assigned">5.1.4.5. 
        Assigned Identifiers</A></SPAN></DT></DL>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-declaration-compositeid">5.1.5. 
      composite-id</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-declaration-discriminator">5.1.6. 
      discriminator</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-declaration-version">5.1.7. 
      version (optional)</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-declaration-timestamp">5.1.8. 
      timestamp (optional)</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-declaration-property">5.1.9. 
      property</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-declaration-manytoone">5.1.10. 
      many-to-one</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-declaration-onetoone">5.1.11. 
      one-to-one</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-declaration-component">5.1.12. 
      component, dynamic-component</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-declaration-subclass">5.1.13. 
      subclass</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-declaration-joinedsubclass">5.1.14. 
      joined-subclass</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-declaration-collections">5.1.15. 
      map, set, list, bag</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-declaration-import">5.1.16. 
      import</A></SPAN></DT></DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-types">5.2. 
    Hibernate Types</A></SPAN>
    <DD>
    <DL>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-types-entitiesvalues">5.2.1. 
      Entities and values</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-types-basictypes">5.2.2. 
      Basic value types</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-types-enum">5.2.3. 
      Persistent enum types</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-types-custom">5.2.4. 
      Custom value types</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-types-anymapping">5.2.5. 
      Any type mappings</A></SPAN></DT></DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-quotedidentifiers">5.3. 
    SQL quoted identifiers</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#mapping-modularfiles">5.4. 
    Modular mapping files</A></SPAN></DT></DL>
  <DT><SPAN class=chapter><A 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#collections">6. 
  Collection Mapping</A></SPAN>
  <DD>
  <DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#collections-persistent">6.1. 
    Persistent Collections</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#collections-mapping">6.2. 
    Mapping a Collection</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#collections-ofvalues">6.3. 
    Collections of Values and Many-To-Many Associations</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#collections-onetomany">6.4. 
    One-To-Many Associations</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#collections-lazy">6.5. 
    Lazy Initialization</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#collections-sorted">6.6. 
    Sorted Collections</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#collections-idbag">6.7. 
    Using an &lt;idbag&gt;</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#collections-bidirectional">6.8. 
    Bidirectional Associations</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#collections-ternary">6.9. 
    Ternary Associations</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#collections-heterogeneous">6.10. 
    Heterogeneous Associations</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#collections-example">6.11. 
    Collection examples</A></SPAN></DT></DL>
  <DT><SPAN class=chapter><A 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#components">7. 
  Component Mapping</A></SPAN>
  <DD>
  <DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#components-dependentobjects">7.1. 
    Dependent objects</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#components-incollections">7.2. 
    Collections of dependent objects</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#components-asmapindex">7.3. 
    Components as Map indices</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#components-compositeid">7.4. 
    Components as composite identifiers</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#components-dynamic">7.5. 
    Dynamic components</A></SPAN></DT></DL>
  <DT><SPAN class=chapter><A 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#inheritance">8. 
  Inheritance Mapping</A></SPAN>
  <DD>
  <DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#inheritance-strategies">8.1. 
    The Three Strategies</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#inheritance-limitations">8.2. 
    Limitations</A></SPAN></DT></DL>
  <DT><SPAN class=chapter><A 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata">9. 
  Manipulating Persistent Data</A></SPAN>
  <DD>
  <DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-creating">9.1. 
    Creating a persistent object</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-loading">9.2. 
    Loading an object</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-querying">9.3. 
    Querying</A></SPAN>
    <DD>
    <DL>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-scalarqueries">9.3.1. 
      Scalar queries</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-queryinterface">9.3.2. 
      The Query interface</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-scrolling">9.3.3. 
      Scrollable iteration</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-filtering">9.3.4. 
      Filtering collections</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-criteria">9.3.5. 
      Criteria queries</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-nativesql">9.3.6. 
      Queries in native SQL</A></SPAN></DT></DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-updating">9.4. 
    Updating objects</A></SPAN>
    <DD>
    <DL>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-updating-insession">9.4.1. 
      Updating in the same Session</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-updating-detached">9.4.2. 
      Updating detached objects</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-update-lock">9.4.3. 
      Reattaching detached objects</A></SPAN></DT></DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-deleting">9.5. 
    Deleting persistent objects</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-flushing">9.6. 
    Flush</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-endingsession">9.7. 
    Ending a Session</A></SPAN>
    <DD>
    <DL>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-endingsession-flushing">9.7.1. 
      Flushing the Session</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-endingsession-commit">9.7.2. 
      Committing the database transaction</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-endingsession-close">9.7.3. 
      Closing the Session</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-endingsession-exceptions">9.7.4. 
      Exception handling</A></SPAN></DT></DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-graphs">9.8. 
    Lifecyles and object graphs</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-interceptors">9.9. 
    Interceptors</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-metadata">9.10. 
    Metadata API</A></SPAN></DT></DL>
  <DT><SPAN class=chapter><A 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#transactions">10. 
  Transactions And Concurrency</A></SPAN>
  <DD>
  <DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#transactions-basics">10.1. 
    Configurations, Sessions and Factories</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#transactions-threads">10.2. 
    Threads and connections</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#transactions-identity">10.3. 
    Considering object identity</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#transactions-optimistic">10.4. 
    Optimistic concurrency control</A></SPAN>
    <DD>
    <DL>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#transactions-optimistic-longsession">10.4.1. 
      Long session with automatic versioning</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#transactions-optimistic-detached">10.4.2. 
      Many sessions with automatic versioning</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#transactions-optimistic-manual">10.4.3. 
      Application version checking</A></SPAN></DT></DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#transactions-disconnection">10.5. 
    Session disconnection</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#transactions-locking">10.6. 
    Pessimistic Locking</A></SPAN></DT></DL>
  <DT><SPAN class=chapter><A 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#queryhql">11. 
  HQL: The Hibernate Query Language</A></SPAN>
  <DD>
  <DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#queryhql-casesensitivity">11.1. 
    Case Sensitivity</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#queryhql-from">11.2. 
    The from clause</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#queryhql-joins">11.3. 
    Associations and joins</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#queryhql-select">11.4. 
    The select clause</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#queryhql-aggregation">11.5. 
    Aggregate functions</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#queryhql-polymorphism">11.6. 
    Polymorphic queries</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#queryhql-where">11.7. 
    The where clause</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#queryhql-expressions">11.8. 
    Expressions</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#queryhql-ordering">11.9. 
    The order by clause</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#queryhql-grouping">11.10. 
    The group by clause</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#queryhql-subqueries">11.11. 
    Subqueries</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#queryhql-examples">11.12. 
    HQL examples</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#queryhql-tipstricks">11.13. 
    Tips &amp; Tricks</A></SPAN></DT></DL>
  <DT><SPAN class=chapter><A 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#querycriteria">12. 
  Criteria Queries</A></SPAN>
  <DD>
  <DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#querycriteria-creating">12.1. 
    Creating a Criteria instance</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#querycriteria-narrowing">12.2. 
    Narrowing the result set</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#querycriteria-ordering">12.3. 
    Ordering the results</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#querycriteria-associations">12.4. 
    Associations</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#querycriteria-dynamicfetching">12.5. 
    Dynamic association fetching</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#querycriteria-examples">12.6. 
    Example queries</A></SPAN></DT></DL>
  <DT><SPAN class=chapter><A 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#querysql">13. 
  Native SQL Queries</A></SPAN>
  <DD>
  <DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#querysql-creating">13.1. 
    Creating a SQL based Query</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#querysql-aliasreferences">13.2. 
    Alias and property references</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#querysql-namedqueries">13.3. 
    Named SQL queries</A></SPAN></DT></DL>
  <DT><SPAN class=chapter><A 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#performance">14. 
  Improving performance</A></SPAN>
  <DD>
  <DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#performance-collections">14.1. 
    Understanding Collection performance</A></SPAN>
    <DD>
    <DL>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#performance-collections-taxonomy">14.1.1. 
      Taxonomy</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#performance-collections-mostefficientupdate">14.1.2. 
      Lists, maps and sets are the most efficient collections to 
      update</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#performance-collections-mostefficentinverse">14.1.3. 
      Bags and lists are the most efficient inverse collections</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#performance-collections-oneshotdelete">14.1.4. 
      One shot delete</A></SPAN></DT></DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#performance-proxies">14.2. 
    Proxies for Lazy Initialization</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#performance-cache">14.3. 
    The Second Level Cache</A></SPAN>
    <DD>
    <DL>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#performance-cache-mapping">14.3.1. 
      Cache mappings</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#performance-cache-readonly">14.3.2. 
      Strategy: read only</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#performance-cache-readwrite">14.3.3. 
      Strategy: read/write</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#performance-cache-nonstrict">14.3.4. 
      Strategy: nonstrict read/write</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#performance-cache-transactional">14.3.5. 
      Strategy: transactional</A></SPAN></DT></DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#performance-sessioncache">14.4. 
    Managing the Session Cache</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#performance-querycache">14.5. 
    The Query Cache</A></SPAN></DT></DL>
  <DT><SPAN class=chapter><A 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#toolsetguide">15. 
  Toolset Guide</A></SPAN>
  <DD>
  <DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#toolsetguide-s1">15.1. 
    Schema Generation</A></SPAN>
    <DD>
    <DL>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#toolsetguide-s1-2">15.1.1. 
      Customizing the schema</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#toolsetguide-s1-3">15.1.2. 
      Running the tool</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#toolsetguide-s1-4">15.1.3. 
      Properties</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#toolsetguide-s1-5">15.1.4. 
      Using Ant</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#toolsetguide-s1-6">15.1.5. 
      Incremental schema updates</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#toolsetguide-s1-7">15.1.6. 
      Using Ant for incremental schema updates</A></SPAN></DT></DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#toolsetguide-s2">15.2. 
    Code Generation</A></SPAN>
    <DD>
    <DL>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#toolsetguide-s2-1">15.2.1. 
      The config file (optional)</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#toolsetguide-s2-2">15.2.2. 
      The meta attribute</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#toolsetguide-s2-3">15.2.3. 
      Basic finder generator</A></SPAN>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#toolsetguide-s2-4">15.2.4. 
      Velocity based renderer/generator</A></SPAN></DT></DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#toolsetguide-s3">15.3. 
    Mapping File Generation</A></SPAN>
    <DD>
    <DL>
      <DT><SPAN class=sect2><A 
      href="http://www.hibernate.org/hib_docs/reference/en/html_single/#toolsetguide-s3-1">15.3.1. 
      Running the tool</A></SPAN></DT></DL></DD></DL>
  <DT><SPAN class=chapter><A 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#example-parentchild">16. 
  Example: Parent/Child</A></SPAN>
  <DD>
  <DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#example-parentchild-collections">16.1. 
    A note about collections</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#example-parentchild-bidir">16.2. 
    Bidirectional one-to-many</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#example-parentchild-cascades">16.3. 
    Cascading lifecycle</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#example-parentchild-update">16.4. 
    Using cascading update()</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#example-parentchild-conclusion">16.5. 
    Conclusion</A></SPAN></DT></DL>
  <DT><SPAN class=chapter><A 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#example-weblog">17. 
  Example: Weblog Application</A></SPAN>
  <DD>
  <DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#example-weblog-classes">17.1. 
    Persistent Classes</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#example-weblog-mappings">17.2. 
    Hibernate Mappings</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#example-weblog-code">17.3. 
    Hibernate Code</A></SPAN></DT></DL>
  <DT><SPAN class=chapter><A 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#example-mappings">18. 
  Example: Various Mappings</A></SPAN>
  <DD>
  <DL>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#example-mappings-emp">18.1. 
    Employer/Employee</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#example-mappings-authorwork">18.2. 
    Author/Work</A></SPAN>
    <DT><SPAN class=sect1><A 
    href="http://www.hibernate.org/hib_docs/reference/en/html_single/#example-mappings-customerorderproduct">18.3. 
    Customer/Order/Product</A></SPAN></DT></DL>
  <DT><SPAN class=chapter><A 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#best-practices">19. 
  Best Practices</A></SPAN></DT></DL></DIV>
<DIV class=preface lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A name=preface></A>Preface</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Working with object-oriented software and a relational database can be 
cumbersome and time consuming in today's enterprise environments. Hibernate is 
an object/relational mapping tool for Java environments. The term 
object/relational mapping (ORM) refers to the technique of mapping a data 
representation from an object model to a relational data model with a SQL-based 
schema. </P>
<P>Hibernate not only takes care of the mapping from Java classes to database 
tables (and from Java data types to SQL data types), but also provides data 
query and retrieval facilities and can significantly reduce development time 
otherwise spent with manual data handling in SQL and JDBC. </P>
<P>Hibernates goal is to relieve the developer from 95 percent of common data 
persistence related programming tasks. Hibernate may not be the best solution 
for data-centric applications that only use stored-procedures to implement the 
business logic in the database, it is most useful with object-oriented domain 
models and business logic in the Java-based middle-tier. However, Hibernate can 
certainly help you to remove or encapsulate vendor-specific SQL code and will 
help with the common task of result set translation from a tabular 
representation to a graph of objects. </P>
<P>If you are new to Hibernate and Object/Relational Mapping or even Java, 
please follow these steps: </P>
<DIV class=orderedlist>
<OL type=1>
  <LI>
  <P>Read <A title="Chapter&nbsp;1.&nbsp;Quickstart with Tomcat" 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#quickstart">Chapter&nbsp;1, 
  <I>Quickstart with Tomcat</I></A> for a 30 minute tutorial, using Tomcat. </P>
  <LI>
  <P>Read <A title=Chapter&nbsp;2.&nbsp;Architecture 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#architecture">Chapter&nbsp;2, 
  <I>Architecture</I></A> to understand the environments where Hibernate can be 
  used. </P>
  <LI>
  <P>Have a look at the <TT class=literal>eg/</TT> directory in the Hibernate 
  distribution, it contains a simple standalone application. Copy your JDBC 
  driver to the <TT class=literal>lib/</TT> directory and edit <TT 
  class=literal>src/hibernate.properties</TT>, specifying correct values for 
  your database. From a command prompt in the distribution directory, type <TT 
  class=literal>ant eg</TT> (using Ant), or under Windows, type <TT 
  class=literal>build eg</TT>. </P>
  <LI>
  <P>Use this reference documentation as your primary source of information. 
</P>
  <LI>
  <P>FAQs are answered on the Hibernate website. </P>
  <LI>
  <P>Third party demos, examples and tutorials are linked on the Hibernate 
  website. </P>
  <LI>
  <P>The Community Area on the Hibernate website is a good source for design 
  patterns and various integration solutions (Tomcat, JBoss, Spring, Struts, 
  EJB, etc.). </P>
  <LI>
  <P>An offline version of the Hibernate website is distributed with Hibernate 
  in the <TT class=literal>doc/</TT> subdirectory. </P></LI></OL></DIV>
<P>If you have questions, use the user forum linked on the Hibernate website. We 
also provide a JIRA issue trackings system for bug reports and feature requests. 
If you are interested in the development of Hibernate, join the developer 
mailing list. </P>
<P>Commercial development, production support and training for Hibernate is 
available through JBoss Inc. (see http://www.hibernate.org/SupportTraining/). 
Hibernate is a project of the JBoss Professional Open Source product suite. 
</P></DIV>
<DIV class=chapter lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A name=quickstart></A>Chapter&nbsp;1.&nbsp;Quickstart with 
Tomcat</H2></DIV></DIV>
<DIV></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=quickstart-intro></A>1.1.&nbsp;Getting started with 
Hibernate</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>This tutorial explains a setup of Hibernate 2.1 with the Apache Tomcat 
servlet container for a web-based application. Hibernate works well in a managed 
environment with all major J2EE application servers, or even in standalone Java 
applications. The database system used in this tutorial is PostgreSQL 7.3, 
support for other database is only a matter of changing the Hibernate SQL 
dialect configuration. </P>
<P>First, we have to copy all required libraries to the Tomcat installation. We 
use a separate web context (<TT class=literal>webapps/quickstart</TT>) for this 
tutorial, so we've to consider both the global library search path (<TT 
class=literal>TOMCAT/common/lib</TT>) and the classloader at the context level 
in <TT class=literal>webapps/quickstart/WEB-INF/lib</TT> (for JAR files) and <TT 
class=literal>webapps/quickstart/WEB-INF/classes</TT>. We refer to both 
classloader levels as the global classpath and the context classpath. </P>
<P>Now, copy the libraries to the two classpaths: </P>
<DIV class=orderedlist>
<OL type=1>
  <LI>
  <P>Copy the JDBC driver for the database to the global classpath. This is 
  required for the DBCP connection pool software which comes bundled with 
  Tomcat. Hibernate uses JDBC connections to execute SQL on the database, so you 
  either have to provide pooled JDBC connections or configure Hibernate to use 
  one of the directly supported pools (C3P0, Proxool). For this tutorial, copy 
  the <TT class=literal>pg73jdbc3.jar</TT> library (for PostgreSQL 7.3 and JDK 
  1.4) to the global classloaders path. If you'd like to use a different 
  database, simply copy its appropriate JDBC driver. </P>
  <LI>
  <P>Never copy anything else into the global classloader path in Tomcat, or you 
  will get problems with various tools, including Log4j, commons-logging and 
  others. Always us the context classpath for each web application, that is, 
  copy libraries to <TT class=literal>WEB-INF/lib</TT> and your own classes and 
  configuration/property files to <TT class=literal>WEB-INF/classes</TT>. Both 
  directories are in the context level classpath by default. </P>
  <LI>
  <P>Hibernate is packaged as a JAR library. The <TT 
  class=literal>hibernate2.jar</TT> file should be copied in the context 
  classpath together with other classes of the application. Hibernate requires 
  some 3rd party libraries at runtime, these come bundled with the Hibernate 
  distribution in the <TT class=literal>lib/</TT> directory; see <A 
  title="Table&nbsp;1.1.&nbsp;&#10;                Hibernate 3rd party libraries&#10;            " 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#3rdpartylibs">Table&nbsp;1.1, 
  “ Hibernate 3rd party libraries ”</A>. Copy the required 3rd party libraries 
  to the context classpath. </P></LI></OL></DIV>
<DIV class=table><A name=3rdpartylibs></A>
<P class=title><B>Table&nbsp;1.1.&nbsp; Hibernate 3rd party libraries </B></P>
<TABLE 
summary="&#10;                Hibernate 3rd party libraries&#10;            " 
border=1>
  <COLGROUP>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH align=middle>Library </TH>
    <TH align=middle>Description </TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>dom4j (required) </TD>
    <TD>Hibernate uses dom4j to parse XML configuration and XML mapping 
      metadata files. </TD></TR>
  <TR>
    <TD>CGLIB (required) </TD>
    <TD>Hibernate uses the code generation library to enhance classes at 
      runtime (in combination with Java reflection). </TD></TR>
  <TR>
    <TD>Commons Collections, Commons Logging (required) </TD>
    <TD>Hibernate uses various utility libraries from the Apache Jakarta 
      Commons project. </TD></TR>
  <TR>
    <TD>ODMG4 (required) </TD>
    <TD>Hibernate provides an optional ODMG compliant persistence manager 
      interface. It is required if you like to map collections, even if you 
      don't intend to use the ODMG API. We don't map collections in this 
      tutorial, but it's a good idea to copy the JAR anyway. </TD></TR>
  <TR>
    <TD>EHCache (required) </TD>
    <TD>Hibernate can use various cache providers for the second-level cache. 
      EHCache is the default cache provider if not changed in the configuration. 
    </TD></TR>
  <TR>
    <TD>Log4j (optional) </TD>
    <TD>Hibernate uses the Commons Logging API, which in turn can use Log4j as 
      the underlying logging mechanism. If the Log4j library is available in the 
      context library directory, Commons Logging will use Log4j and the <TT 
      class=literal>log4j.properties</TT> configuration in the context 
      classpath. An example properties file for Log4j is bundled with the 
      Hibernate distribution. So, copy log4j.jar and the configuration file 
      (from <TT class=literal>src/</TT>) to your context classpath if you want 
      to see whats going on behind the scenes. </TD></TR>
  <TR>
    <TD>Required or not? </TD>
    <TD>Have a look at the file <TT class=literal>lib/README.txt</TT> in the 
      Hibernate distribution. This is an up-to-date list of 3rd party libraries 
      distributed with Hibernate. You will find all required and optional 
      libraries listed there. </TD></TR></TBODY></TABLE></DIV>
<P>We now set up the database connection pooling and sharing in both Tomcat and 
Hibernate. This means Tomcat will provide pooled JDBC connections (using its 
builtin DBCP pooling feature), Hibernate requests theses connections through 
JNDI. Tomcat binds the connection pool to JNDI, we add a resource declaration to 
Tomcats main configuration file, <TT class=literal>TOMCAT/conf/server.xml</TT>: 
</P><PRE class=programlisting>&lt;Context path="/quickstart" docBase="quickstart"&gt;
    &lt;Resource name="jdbc/quickstart" scope="Shareable" type="javax.sql.DataSource"/&gt;
    &lt;ResourceParams name="jdbc/quickstart"&gt;
        &lt;parameter&gt;
            &lt;name&gt;factory&lt;/name&gt;
            &lt;value&gt;org.apache.commons.dbcp.BasicDataSourceFactory&lt;/value&gt;
        &lt;/parameter&gt;

        &lt;!-- DBCP database connection settings --&gt;
        &lt;parameter&gt;
            &lt;name&gt;url&lt;/name&gt;
            &lt;value&gt;jdbc:postgresql://localhost/quickstart&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;driverClassName&lt;/name&gt;&lt;value&gt;org.postgresql.Driver&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;username&lt;/name&gt;
            &lt;value&gt;quickstart&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;password&lt;/name&gt;
            &lt;value&gt;secret&lt;/value&gt;
        &lt;/parameter&gt;

        &lt;!-- DBCP connection pooling options --&gt;
        &lt;parameter&gt;
            &lt;name&gt;maxWait&lt;/name&gt;
            &lt;value&gt;3000&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;maxIdle&lt;/name&gt;
            &lt;value&gt;100&lt;/value&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
            &lt;name&gt;maxActive&lt;/name&gt;
            &lt;value&gt;10&lt;/value&gt;
        &lt;/parameter&gt;
    &lt;/ResourceParams&gt;
&lt;/Context&gt;</PRE>
<P>The context we configure in this example is named <TT 
class=literal>quickstart</TT>, its base is the <TT 
class=literal>TOMCAT/webapp/quickstart</TT> directory. To access any servlets, 
call the path <TT class=literal>http://localhost:8080/quickstart</TT> in your 
browser (of course, adding the name of the servlet as mapped in your <TT 
class=literal>web.xml</TT>). You may also go ahead and create a simple servlet 
now that has an empty <TT class=literal>process()</TT> </P>
<P>Tomcat uses the DBCP connection pool with this configuration and provides 
pooled JDBC <TT class=literal>Connection</TT>s through JNDI at <TT 
class=literal>java:comp/env/jdbc/quickstart</TT>. If you have trouble getting 
the connection pool running, refer to the Tomcat documentation. If you get JDBC 
driver exception messages, try to setup JDBC connection pool without Hibernate 
first. Tomcat &amp; JDBC tutorials are available on the Web. </P>
<P>The next step is to configure Hibernate, using the connections from the JNDI 
bound pool. We use Hibernates XML based configuration. The basic approach, using 
properties, is equivalent in features, but doesn't offer any advantages. We use 
the XML configuration because it is usually more convenient. The XML 
configuration file is placed in the context classpath (<TT 
class=literal>WEB-INF/classes</TT>), as <TT 
class=literal>hibernate.cfg.xml</TT>: </P><PRE class=programlisting>&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration
    PUBLIC "-//Hibernate/Hibernate Configuration DTD//EN"
    "http://hibernate.sourceforge.net/hibernate-configuration-2.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;session-factory&gt;

        &lt;property name="connection.datasource"&gt;java:comp/env/jdbc/quickstart&lt;/property&gt;
        &lt;property name="show_sql"&gt;false&lt;/property&gt;
        &lt;property name="dialect"&gt;net.sf.hibernate.dialect.PostgreSQLDialect&lt;/property&gt;

        &lt;!-- Mapping files --&gt;
        &lt;mapping resource="Cat.hbm.xml"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</PRE>
<P>We turn logging of SQL commands off and tell Hibernate what database SQL 
dialect is used and where to get the JDBC connections (by declaring the JNDI 
address of the Tomcat bound datasource pool). The dialect is a required setting, 
databases differ in their interpretation of the SQL "standard". Hibernate will 
take care of the differences and comes bundled with dialects for all major 
commercial and open source databases. </P>
<P>A <TT class=literal>SessionFactory</TT> is Hibernate's concept of a single 
datastore, multiple databases can be used by creating multiple XML configuration 
files and creating multiple <TT class=literal>Configuration</TT> and <TT 
class=literal>SessionFactory</TT> objects in your application. </P>
<P>The last element of the <TT class=literal>hibernate.cfg.xml</TT> declares <TT 
class=literal>Cat.hbm.xml</TT> as the name of a Hibernate XML mapping file for 
the persistent class <TT class=literal>Cat</TT>. This file contains the metadata 
for the mapping of the POJO class to a datbase table (or multiple tables). We'll 
come back to that file soon. Let's write the POJO class first and then declare 
the mapping metadata for it. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=quickstart-persistentclass></A>1.2.&nbsp;First persistent 
class</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Hibernate works best with the Plain Old Java Objects (POJOs, sometimes called 
Plain Ordinary Java Objects) programming model for persistent classes. A POJO is 
much like a JavaBean, with properties of the class accessible via getter and 
setter methods, shielding the internal representation from the publicly visible 
interface: </P><PRE class=programlisting>package net.sf.hibernate.examples.quickstart;

public class Cat {

    private String id;
    private String name;
    private char sex;
    private float weight;

    public Cat() {
    }

    public String getId() {
        return id;
    }

    private void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public char getSex() {
        return sex;
    }

    public void setSex(char sex) {
        this.sex = sex;
    }

    public float getWeight() {
        return weight;
    }

    public void setWeight(float weight) {
        this.weight = weight;
    }

}</PRE>
<P>Hibernate is not restricted in its usage of property types, all Java JDK 
types and primitives (like <TT class=literal>String</TT>, <TT 
class=literal>char</TT> and <TT class=literal>Date</TT>) can be mapped, 
including classes from the Java collections framework. You can map them as 
values, collections of values, or associations to other entities. The <TT 
class=literal>id</TT> is a special property that represents the database 
identifer (primary key) of that class, it is highly recommended for entities 
like a <TT class=literal>Cat</TT>. Hibernate can use identifiers only 
internally, but we would lose some of the flexibility in our application 
architecture. </P>
<P>No special interface has to be implemented for persistent classes nor do we 
have to subclass from a special root persistent class. Hibernate also doesn't 
use any build time processing, such as byte-code manipulation, it relies solely 
on Java reflection and runtime class enhancement (through CGLIB). So, without 
any dependency in the POJO class on Hibernate, we can map it to a database 
table. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=quickstart-mapping></A>1.3.&nbsp;Mapping the cat</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>The <TT class=literal>Cat.hbm.xml</TT> mapping file contains the metadata 
required for the object/relational mapping. The metadata includes declaration of 
persistent classes and the mapping of properties (to columns and foreign key 
relationships to other entities) to database tables. </P><PRE class=programlisting>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping
    PUBLIC "-//Hibernate/Hibernate Mapping DTD//EN"
    "http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd"&gt;

&lt;hibernate-mapping&gt;

    &lt;class name="net.sf.hibernate.examples.quickstart.Cat" table="CAT"&gt;

        &lt;!-- A 32 hex character is our surrogate key. It's automatically
            generated by Hibernate with the UUID pattern. --&gt;
        &lt;id name="id" type="string" unsaved-value="null" &gt;
            &lt;column name="CAT_ID" sql-type="char(32)" not-null="true"/&gt;
            &lt;generator class="uuid.hex"/&gt;
        &lt;/id&gt;

        &lt;!-- A cat has to have a name, but it shouldn' be too long. --&gt;
        &lt;property name="name"&gt;
            &lt;column name="NAME" length="16" not-null="true"/&gt;
        &lt;/property&gt;

        &lt;property name="sex"/&gt;

        &lt;property name="weight"/&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</PRE>
<P>Every persistent class should have an identifer attribute (actually, only 
classes representing entities, not dependent value objects, which are mapped as 
components of an entity). This property is used to distinguish persistent 
objects: Two cats are equal if <TT 
class=literal>catA.getId().equals(catB.getId())</TT> is true, this concept is 
called <SPAN class=emphasis><EM>database identity</EM></SPAN>. Hibernate comes 
bundled with various identifer generators for different scenarios (including 
native generators for database sequences, hi/lo identifier tables, and 
application assigned identifiers). We use the UUID generator (only recommended 
for testing, as integer surrogate keys generated by the database should be 
prefered) and also specify the column <TT class=literal>CAT_ID</TT> of the table 
<TT class=literal>CAT</TT> for the Hibernate generated identifier value (as a 
primary key of the table). </P>
<P>All other properties of <TT class=literal>Cat</TT> are mapped to the same 
table. In the case of the <TT class=literal>name</TT> property, we mapped it 
with an explicit database column declaration. This is especially useful when the 
database schema is automatically generated (as SQL DDL statements) from the 
mapping declaration with Hibernate's <SPAN 
class=emphasis><EM>SchemaExport</EM></SPAN> tool. All other properties are 
mapped using Hibernate's default settings, which is what you need most of the 
time. The table <TT class=literal>CAT</TT> in the database looks like this: </P><PRE class=programlisting> Column |         Type          | Modifiers
--------+-----------------------+-----------
 cat_id | character(32)         | not null
 name   | character varying(16) | not null
 sex    | character(1)          |
 weight | real                  |
Indexes: cat_pkey primary key btree (cat_id)</PRE>
<P>You should now create this table in your database manually, and later read <A 
title="Chapter&nbsp;15.&nbsp;Toolset Guide" 
href="http://www.hibernate.org/hib_docs/reference/en/html_single/#toolsetguide">Chapter&nbsp;15, 
<I>Toolset Guide</I></A> if you want to automate this step with the SchemaExport 
tool. This tool can create a full SQL DDL, including table definition, custom 
column type constraints, unique constraints and indexes. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=quickstart-playingwithcats></A>1.4.&nbsp;Playing with cats</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>We're now ready to start Hibernate's <TT class=literal>Session</TT>. It is 
the <SPAN class=emphasis><EM>persistence manager</EM></SPAN>interface, we use it 
to store and retrieve <TT class=literal>Cat</TT>s to and from the database. But 
first, we've to get a <TT class=literal>Session</TT> (Hibernate's unit-of-work) 
from the <TT class=literal>SessionFactory</TT>: </P><PRE class=programlisting>SessionFactory sessionFactory =
            new Configuration().configure().buildSessionFactory();</PRE>
<P>A <TT class=literal>SessionFactory</TT> is responsible for one database and 
may only use one XML configuration file (<TT 
class=literal>hibernate.cfg.xml</TT>). You can set other properties (and even 
change the mapping metadata) by accessing the <TT 
class=literal>Configuration</TT> <SPAN class=emphasis><EM>before</EM></SPAN> you 
build the <TT class=literal>SessionFactory</TT> (it is immutable). Where do we 
create the <TT class=literal>SessionFactory</TT> and how can we access it in our 
application? </P>
<P>A <TT class=literal>SessionFactory</TT> is usually only build done once, e.g. 
at startup with a <SPAN class=emphasis><EM>load-on-startup</EM></SPAN> servlet. 
This also means you should not keep it in an instance variable in your servlets, 
but in some other location. We need some kind of <SPAN 
class=emphasis><EM>Singleton</EM></SPAN>, so we can access the <TT 
class=literal>SessionFactory</TT> easily. The approach shown next solves both 
problems: configuration and easy access to a <TT 
class=literal>SessionFactory</TT>. </P>
<P>We implement a <TT class=literal>HibernateUtil</TT> helper class: </P><PRE class=programlisting>import net.sf.hibernate.*;
import net.sf.hibernate.cfg.*;

public class HibernateUtil {

    private static final SessionFactory sessionFactory;

    static {
        try {
            // Create the SessionFactory
            sessionFactory = new Configuration().configure().buildSessionFactory();
        } catch (HibernateException ex) {
            throw new RuntimeException("Configuration problem: " + ex.getMessage(), ex);
        }
    }

    public static final ThreadLocal session = new ThreadLocal();

    public static Session currentSession() throws HibernateException {
        Session s = (Session) session.get();
        // Open a new Session, if this Thread has none yet
        if (s == null) {
            s = sessionFactory.openSession();
            session.set(s);
        }
        return s;
    }

    public static void closeSession() throws HibernateException {
        Session s = (Session) session.get();
        session.set(null);
        if (s != null)
            s.close();
    }
}</PRE>
<P>This class does not only take care of the <TT 
class=literal>SessionFactory</TT> with its static attribute, but also has a <TT 
class=literal>ThreadLocal</TT> to hold the <TT class=literal>Session</TT> for 
the current executing thread. Make sure you understand the Java concept of a 
thread-local variable before you try to use this helper. </P>
<P>A <TT class=literal>SessionFactory</TT> is threadsafe, many threads can 
access it concurrently and request <TT class=literal>Session</TT>s. A <TT 
class=literal>Session</TT> is a non-threadsafe object that represents a single 
unit-of-work with the database. <TT class=literal>Session</TT>s are opened by a 
<TT class=literal>SessionFactory</TT> and are closed when all work is completed: 
</P><PRE class=programlisting>Session session = HibernateUtil.currentSession();

Transaction tx= session.beginTransaction();

Cat princess = new Cat();
princess.setName("Princess");
princess.setSex('F');
princess.setWeight(7.4f);

session.save(princess);
tx.commit();

HibernateUtil.closeSession();</PRE>
<P>In a <TT class=literal>Session</TT>, every database operation occurs inside a 
transaction that isolates the database operations (even read-only operations). 
We use Hibernates <TT class=literal>Transaction</TT> API to abstract from the 
underlying transaction strategy (in our case, JDBC transactions). This allows 
our code to be deployed with container-managed transactions (using JTA) without 
any changes. Please note that the example above does not handle any exceptions. 
</P>
<P>Also note that you may call <TT 
class=literal>HibernateUtil.currentSession();</TT> as many times as you like, 
you will always get the current <TT class=literal>Session</TT> of this thread. 
You have to make sure the <TT class=literal>Session</TT> is closed after your 
unit-of-work completes, either in your servlet code or in a servlet filter 
before the HTTP response is send. The nice side effect of the latter is easy 
lazy initialization: the <TT class=literal>Session</TT> is still open when the 
view is rendered, so Hibernate can load unitialized objects while you navigate 
the graph. </P>
<P>Hibernate has various methods that can be used to retrieve objects from the 
database. The most flexible way is using the Hibernate Query Language (HQL), 
which is an easy to learn and powerful object-oriented extension to SQL: </P><PRE class=programlisting>Transaction tx = session.beginTransaction();

Query query = session.createQuery("select c from Cat as c where c.sex = :sex");
query.setCharacter("sex", 'F');
for (Iterator it = query.iterate(); it.hasNext();) {
    Cat cat = (Cat) it.next();
    out.println("Female Cat: " + cat.getName() );
}

tx.commit();</PRE>
<P>Hibernate also offers an object-oriented <SPAN class=emphasis><EM>query by 
criteria</EM></SPAN> API that can be used to formulate type-safe queries. 
Hibernate of course uses <TT class=literal>PreparedStatement</TT>s and parameter 
binding for all SQL communication with the database. You may also use 
Hibernate's direct SQL query feature or get a plain JDBC connection from a <TT 
class=literal>Session</TT> in rare cases. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=quickstart-summary></A>1.5.&nbsp;Finally</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>We only scratched the surface of Hibernate in this small tutorial. Please 
note that we don't include any servlet specific code in our examples. You have 
to create a servlet yourself and insert the Hibernate code as you see fit. </P>
<P>Keep in mind that Hibernate, as a data access layer, is tightly integrated 
into your application. Usually, all other layers depent on the persistence 
mechanism. Make sure you understand the implications of this design. 
</P></DIV></DIV>
<DIV class=chapter lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A 
name=architecture></A>Chapter&nbsp;2.&nbsp;Architecture</H2></DIV></DIV>
<DIV></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=architecture-overview></A>2.1.&nbsp;Overview</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>A (very) high-level view of the Hibernate architecture: </P>
<DIV class=mediaobject align=center><IMG src="Hibernate_files/overview.gif" 
align=middle></DIV>
<P>This diagram shows Hibernate using the database and configuration data to 
provide persistence services (and persistent objects) to the application. </P>
<P>We would like to show a more detailed view of the runtime architecture. 
Unfortunately, Hibernate is flexible and supports several approaches. We will 
show the two extremes. The "lite" architecture has the application provide its 
own JDBC connections and manage its own transactions. This approach uses a 
minimal subset of Hibernate's APIs: </P>
<DIV class=mediaobject align=center><IMG src="Hibernate_files/lite.gif" 
align=middle></DIV>
<P>The "full cream" architecture abstracts the application away from the 
underlying JDBC/JTA APIs and lets Hibernate take care of the details. </P>
<DIV class=mediaobject align=center><IMG src="Hibernate_files/full_cream.gif" 
align=middle></DIV>
<P>Heres some definitions of the objects in the diagrams: </P>
<DIV class=variablelist>
<DL>
  <DT><SPAN class=term>SessionFactory (<TT 
  class=literal>net.sf.hibernate.SessionFactory</TT>)</SPAN>
  <DD>
  <P>A threadsafe (immutable) cache of compiled mappings for a single database. 
  A factory for <TT class=literal>Session</TT> and a client of <TT 
  class=literal>ConnectionProvider</TT>. Might hold an optional (second-level) 
  cache of data that is reusable between transactions, at a process- or 
  cluster-level. </P>
  <DT><SPAN class=term>Session (<TT 
  class=literal>net.sf.hibernate.Session</TT>)</SPAN>
  <DD>
  <P>A single-threaded, short-lived object representing a conversation between 
  the application and the persistent store. Wraps a JDBC connection. Factory for 
  <TT class=literal>Transaction</TT>. Holds a mandatory (first-level) cache of 
  persistent objects, used when navigating the object graph or looking up 
  objects by identifier. </P>
  <DT><SPAN class=term>Persistent Objects and Collections</SPAN>
  <DD>
  <P>Short-lived, single threaded objects containing persistent state and 
  business function. These might be ordinary JavaBeans/POJOs, the only special 
  thing about them is that they are currently associated with (exactly one) <TT 
  class=literal>Session</TT>. As soon as the <TT class=literal>Session</TT> is 
  closed, they will be detached and free to use in any application layer (e.g. 
  directly as data transfer objects to and from presentation). </P>
  <DT><SPAN class=term>Transient Objects and Collections</SPAN>
  <DD>
  <P>Instances of persistent classes that are not currently associated with a 
  <TT class=literal>Session</TT>. They may have been instantiated by the 
  application and not (yet) persisted or they may have been instantiated by a 
  closed <TT class=literal>Session</TT>. </P>
  <DT><SPAN class=term>Transaction (<TT 
  class=literal>net.sf.hibernate.Transaction</TT>)</SPAN>
  <DD>
  <P>(Optional) A single-threaded, short-lived object used by the application to 
  specify atomic units of work. Abstracts application from underlying JDBC, JTA 
  or CORBA transaction. A <TT class=literal>Session</TT> might span several <TT 
  class=literal>Transaction</TT>s in some cases. </P>
  <DT><SPAN class=term>ConnectionProvider (<TT 
  class=literal>net.sf.hibernate.connection.ConnectionProvider</TT>)</SPAN>
  <DD>
  <P>(Optional) A factory for (and pool of) JDBC connections. Abstracts 
  application from underlying <TT class=literal>Datasource</TT> or <TT 
  class=literal>DriverManager</TT>. Not exposed to application, but can be 
  extended/implemented by the developer. </P>
  <DT><SPAN class=term>TransactionFactory (<TT 
  class=literal>net.sf.hibernate.TransactionFactory</TT>)</SPAN>
  <DD>
  <P>(Optional) A factory for <TT class=literal>Transaction</TT> instances. Not 
  exposed to the application, but can be extended/implemented by the developer. 
  </P></DD></DL></DIV>
<P></P>
<P>Given a "lite" architecture, the application bypasses the <TT 
class=literal>Transaction</TT>/<TT class=literal>TransactionFactory</TT> and/or 
<TT class=literal>ConnectionProvider</TT> APIs to talk to JTA or JDBC directly. 
</P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=architecture-jmx></A>2.2.&nbsp;JMX 
Integration</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>JMX is the J2EE standard for management of Java components. Hibernate may be 
managed via a JMX standard MBean but because most application servers do not yet 
support JMX, Hibernate also affords some non-standard configuration mechanisms. 
</P>
<P>Please see the Hibernate website for more information on how to configure 
Hibernate to run as a JMX component inside JBoss. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=architecture-jca></A>2.3.&nbsp;JCA 
Support</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Hibernate may also be configured as a JCA connector. Please see the website 
for more details. </P></DIV></DIV>
<DIV class=chapter lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A 
name=session-configuration></A>Chapter&nbsp;3.&nbsp;SessionFactory 
Configuration</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Because Hibernate is designed to operate in many different environments, 
there are a large number of configuration parameters. Fortunately, most have 
sensible default values and Hibernate is distributed with an example <TT 
class=literal>hibernate.properties</TT> file that shows the various options. You 
usually only have to put that file in your classpath and customize it. </P>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=configuration-programmatic></A>3.1.&nbsp;Programmatic 
Configuration</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>An instance of <TT class=literal>net.sf.hibernate.cfg.Configuration</TT> 
represents an entire set of mappings of an application's Java types to a SQL 
database. The <TT class=literal>Configuration</TT> is used to build a 
(immutable)` <TT class=literal>SessionFactory</TT>. The mappings are compiled 
from various XML mapping files. </P>
<P>You may obtain a <TT class=literal>Configuration</TT> instance by 
instantiating it directly. Heres an example of setting up a datastore from 
mappings defined in two XML configuration files (in the classpath): </P><PRE class=programlisting>Configuration cfg = new Configuration()
    .addFile("Item.hbm.xml")
    .addFile("Bid.hbm.xml");</PRE>
<P>An alternative (sometimes better) way is to let Hibernate load a mapping file 
using <TT class=literal>getResourceAsStream()</TT>: </P><PRE class=programlisting>Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class);</PRE>
<P>Then Hibernate will look for mapping files named <TT 
class=literal>/org/hibernate/autcion/Item.hbm.xml</TT> and <TT 
class=literal>/org/hibernate/autcion/Bid.hbm.xml</TT> in the classpath. This 
approach eliminates any hardcoded filenames. </P>
<P>A <TT class=literal>Configuration</TT> also specifies various optional 
properties: </P><PRE class=programlisting>Properties props = new Properties();
...
Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class)
    .setProperties(props);</PRE>
<P>A <TT class=literal>Configuration</TT> is intended as a configuration-time 
object, to be discarded once a <TT class=literal>SessionFactory</TT> is built. 
</P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=configuration-sessionfactory></A>3.2.&nbsp;Obtaining a 
SessionFactory</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>When all mappings have been parsed by the <TT 
class=literal>Configuration</TT>, the application must obtain a factory for <TT 
class=literal>Session</TT> instances. This factory is intended to be shared by 
all application threads: </P><PRE class=programlisting>SessionFactory sessions = cfg.buildSessionFactory();</PRE>
<P>However, Hibernate does allow your application to instantiate more than one 
<TT class=literal>SessionFactory</TT>. This is useful if you are using more than 
one database. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=configuration-userjdbc></A>3.3.&nbsp;User provided JDBC 
connection</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>A <TT class=literal>SessionFactory</TT> may open a <TT 
class=literal>Session</TT> on a user-provided JDBC connection. This design 
choice frees the application to obtain JDBC connections wherever it pleases: 
</P><PRE class=programlisting>java.sql.Connection conn = datasource.getConnection();
Session session = sessions.openSession(conn);

// do some data access work</PRE>
<P>The application must be careful not to open two concurrent <TT 
class=literal>Session</TT>s on the same JDBC connection! </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=configuration-hibernatejdbc></A>3.4.&nbsp;Hibernate provided JDBC 
connection</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Alternatively, you can have the <TT class=literal>SessionFactory</TT> open 
connections for you. The <TT class=literal>SessionFactory</TT> must be provided 
with JDBC connection properties in one of the following ways: </P>
<DIV class=orderedlist>
<OL type=1 compact>
  <LI>
  <P>Pass an instance of <TT class=literal>java.util.Properties</TT> to <TT 
  class=literal>Configuration.setProperties()</TT>. </P>
  <LI>
  <P>Place <TT class=literal>hibernate.properties</TT> in a root directory of 
  the classpath. </P>
  <LI>
  <P>Set <TT class=literal>System</TT> properties using <TT class=literal>java 
  -Dproperty=value</TT>. </P>
  <LI>
  <P>Include <TT class=literal>&lt;property&gt;</TT> elements in <TT 
  class=literal>hibernate.cfg.xml</TT> (discussed later). </P></LI></OL></DIV>
<P>If you take this approach, opening a <TT class=literal>Session</TT> is as 
simple as: </P><PRE class=programlisting>Session session = sessions.openSession(); // open a new Session
// do some data access work, a JDBC connection will be used on demand</PRE>
<P>All Hibernate property names and semantics are defined on the class <TT 
class=literal>net.sf.hibernate.cfg.Environment</TT>. We will now describe the 
most important settings for JDBC connection configuration. </P>
<P>Hibernate will obtain (and pool) connections using <TT 
class=literal>java.sql.DriverManager</TT> if you set the following properties: 
</P>
<DIV class=table><A name=d0e762></A>
<P class=title><B>Table&nbsp;3.1.&nbsp;Hibernate JDBC Properties</B></P>
<TABLE summary="Hibernate JDBC Properties" border=1>
  <COLGROUP>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Property name</TH>
    <TH>Purpose</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><TT class=literal>hibernate.connection.driver_class</TT></TD>
    <TD><SPAN class=emphasis><EM>jdbc driver class</EM></SPAN></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.connection.url</TT></TD>
    <TD><SPAN class=emphasis><EM>jdbc URL</EM></SPAN></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.connection.username</TT></TD>
    <TD><SPAN class=emphasis><EM>database user</EM></SPAN></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.connection.password</TT></TD>
    <TD><SPAN class=emphasis><EM>database user password</EM></SPAN></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.connection.pool_size</TT></TD>
    <TD><SPAN class=emphasis><EM>maximum number of pooled 
      connections</EM></SPAN></TD></TR></TBODY></TABLE></DIV>
<P>Hibernate's own connection pooling algorithm is quite rudimentary. It is 
intended to help you get started and is <SPAN class=emphasis><EM>not intended 
for use in a production system</EM></SPAN> or even for performance testing. Use 
a third party pool for best performance and stability, i.e., replace the <TT 
class=literal>hibernate.connection.pool_size</TT> property with connection pool 
specific settings. </P>
<P>C3P0 is an open source JDBC connection pool distributed along with Hibernate 
in the <TT class=literal>lib</TT> directory. Hibernate will use the built-in <TT 
class=literal>C3P0ConnectionProvider</TT> for connection pooling if you set the 
<TT class=literal>hibernate.c3p0.*</TT> properties. There is also built-in 
support for Apache DBCP and for Proxool. You must set the properties <TT 
class=literal>hibernate.dbcp.*</TT> (DBCP connection pool properties) to enable 
the <TT class=literal>DBCPConnectionProvider</TT>. Prepared statement caching is 
enabled (highly recommend) if <TT class=literal>hibernate.dbcp.ps.*</TT> (DBCP 
statement cache properties) are set. Please refer the the Apache commons-pool 
documentation for the interpretation of these properties. You should set the <TT 
class=literal>hibernate.proxool.*</TT> properties if you wish to use Proxool. 
</P>
<P>This is an example using C3P0: </P><PRE class=programlisting>hibernate.connection.driver_class = org.postgresql.Driver
hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
hibernate.connection.username = myuser
hibernate.connection.password = secret
hibernate.c3p0.minPoolSize=5
hibernate.c3p0.maxPoolSize=20
hibernate.c3p0.timeout=1800
hibernate.c3p0.max_statement=50
hibernate.dialect = net.sf.hibernate.dialect.PostgreSQLDialect</PRE>
<P>For use inside an application server, Hibernate may obtain connections from a 
<TT class=literal>javax.sql.Datasource</TT> registered in JNDI. Set the 
following properties: </P>
<DIV class=table><A name=d0e850></A>
<P class=title><B>Table&nbsp;3.2.&nbsp;Hibernate Datasource Properties</B></P>
<TABLE summary="Hibernate Datasource Properties" border=1>
  <COLGROUP>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Propery name</TH>
    <TH>Purpose</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><TT class=literal>hibernate.connection.datasource</TT></TD>
    <TD><SPAN class=emphasis><EM>datasource JNDI name</EM></SPAN></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.jndi.url</TT></TD>
    <TD><SPAN class=emphasis><EM>URL of the JNDI provider</EM></SPAN> 
      (optional) </TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.jndi.class</TT></TD>
    <TD><SPAN class=emphasis><EM>class of the JNDI <TT 
      class=literal>InitialContextFactory</TT></EM></SPAN> (optional) </TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.connection.username</TT></TD>
    <TD><SPAN class=emphasis><EM>database user</EM></SPAN> (optional) </TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.connection.password</TT></TD>
    <TD><SPAN class=emphasis><EM>database user password</EM></SPAN> (optional) 
    </TD></TR></TBODY></TABLE></DIV>
<P>This is an example using an application server provided JNDI datasource: </P><PRE class=programlisting>hibernate.connection.datasource = java:/comp/env/jdbc/MyDB
hibernate.transaction.factory_class = \
    net.sf.hibernate.transaction.JTATransactionFactory
hibernate.transaction.manager_lookup_class = \
    net.sf.hibernate.transaction.JBossTransactionManagerLookup
hibernate.dialect = \
    net.sf.hibernate.dialect.PostgreSQLDialect</PRE>
<P>JDBC connections obtained from a JNDI datasource will automatically 
participate in the container-managed transactions of the application server. 
</P>
<P>Arbitrary connection properties may be given by prepending "<TT 
class=literal>hibernate.connnection</TT>" to the property name. For example, you 
may specify a <TT class=literal>charSet</TT> using <TT 
class=literal>hibernate.connnection.charSet</TT>. </P>
<P>You may define your own plugin strategy for obtaining JDBC connections by 
implementing the interface <TT 
class=literal>net.sf.hibernate.connection.ConnectionProvider</TT>. You may 
select a custom implementation by setting <TT 
class=literal>hibernate.connection.provider_class</TT>. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=configuration-optional></A>3.5.&nbsp;Optional configuration 
properties</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>There are a number of other properties that control the behaviour of 
Hibernate at runtime. All are optional and have reasonable default values. </P>
<P>System-level properties can only be set via <TT class=literal>java 
-Dproperty=value</TT> or be defined in <TT 
class=literal>hibernate.properties</TT> and not with an instance of <TT 
class=literal>Properties</TT> passed to the <TT 
class=literal>Configuration</TT>. </P>
<DIV class=table><A name=d0e948></A>
<P class=title><B>Table&nbsp;3.3.&nbsp;Hibernate Configuration 
Properties</B></P>
<TABLE summary="Hibernate Configuration Properties" border=1>
  <COLGROUP>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Property name</TH>
    <TH>Purpose</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><TT class=literal>hibernate.dialect</TT></TD>
    <TD>The classname of a Hibernate <TT class=literal>Dialect</TT> - enables 
      certain platform dependent features. 
      <P><SPAN class=strong>eg.</SPAN> <TT 
      class=literal>full.classname.of.Dialect</TT> </P></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.default_schema</TT></TD>
    <TD>Qualify unqualified tablenames with the given schema/tablespace in 
      generated SQL. 
      <P><SPAN class=strong>eg.</SPAN> <TT class=literal>SCHEMA_NAME</TT> 
  </P></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.session_factory_name</TT></TD>
    <TD>The <TT class=literal>SessionFactory</TT> will be automatically bound 
      to this name in JNDI after it has been created. 
      <P><SPAN class=strong>eg.</SPAN> <TT 
      class=literal>jndi/composite/name</TT> </P></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.use_outer_join</TT></TD>
    <TD>Enables outer join fetching. Deprecated, use <TT 
      class=literal>max_fetch_depth</TT>. 
      <P><SPAN class=strong>eg.</SPAN> <TT class=literal>true</TT> | <TT 
      class=literal>false</TT> </P></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.max_fetch_depth</TT></TD>
    <TD>Set a maximum "depth" for the outer join fetch tree for single-ended 
      associations (one-to-one, many-to-one). A <TT class=literal>0</TT> 
      disables default outer join fetching. 
      <P><SPAN class=strong>eg.</SPAN> recommended values between <TT 
      class=literal>0</TT> and <TT class=literal>3</TT> </P></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.jdbc.fetch_size</TT></TD>
    <TD>A non-zero value determines the JDBC fetch size (calls <TT 
      class=literal>Statement.setFetchSize()</TT>). </TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.jdbc.batch_size</TT></TD>
    <TD>A non-zero value enables use of JDBC2 batch updates by Hibernate. 
      <P><SPAN class=strong>eg.</SPAN> recommended values between <TT 
      class=literal>5</TT> and <TT class=literal>30</TT> </P></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.jdbc.use_scrollable_resultset</TT></TD>
    <TD>Enables use of JDBC2 scrollable resultsets by Hibernate. This property 
      is only necessary when using user supplied JDBC connections, Hibernate 
      uses connection metadata otherwise. 
      <P><SPAN class=strong>eg.</SPAN> <TT class=literal>true</TT> | <TT 
      class=literal>false</TT> </P></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.jdbc.use_streams_for_binary</TT></TD>
    <TD>Use streams when writing/reading <TT class=literal>binary</TT> or <TT 
      class=literal>serializable</TT> types to/from JDBC (system-level 
      property). 
      <P><SPAN class=strong>eg.</SPAN> <TT class=literal>true</TT> | <TT 
      class=literal>false</TT> </P></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.cglib.use_reflection_optimizer</TT></TD>
    <TD>Enables use of CGLIB instead of runtime reflection (System-level 
      property, default is to use CGLIB where possible). Reflection can 
      sometimes be useful when troubleshooting. 
      <P><SPAN class=strong>eg.</SPAN> <TT class=literal>true</TT> | <TT 
      class=literal>false</TT> </P></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.jndi.<SPAN 
      class=emphasis><EM>&lt;propertyName&gt;</EM></SPAN></TT></TD>
    <TD>Pass the property <TT class=literal>propertyName</TT> to the JNDI <TT 
      class=literal>InitialContextFactory</TT>. </TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.connection.isolation</TT></TD>
    <TD>Set the JDBC transaction isolation level. Check <TT 
      class=literal>java.sql.Connection</TT> for meaningful values but note that 
      most databases do not support all isolation levels. 
      <P><SPAN class=strong>eg.</SPAN> <TT class=literal>1, 2, 4, 8</TT> 
  </P></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.connection.<SPAN 
      class=emphasis><EM>&lt;propertyName&gt;</EM></SPAN></TT></TD>
    <TD>Pass the JDBC property <TT class=literal>propertyName</TT> to <TT 
      class=literal>DriverManager.getConnection()</TT>. </TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.connection.provider_class</TT></TD>
    <TD>The classname of a custom <TT class=literal>ConnectionProvider</TT>. 
      <P><SPAN class=strong>eg.</SPAN> <TT 
      class=literal>classname.of.ConnectionProvider</TT> </P></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.cache.provider_class</TT></TD>
    <TD>The classname of a custom <TT class=literal>CacheProvider</TT>. 
      <P><SPAN class=strong>eg.</SPAN> <TT 
      class=literal>classname.of.CacheProvider</TT> </P></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.cache.use_minimal_puts</TT></TD>
    <TD>Optimize second-level cache operation to minimize writes, at the cost 
      of more frequent reads (useful for clustered caches). 
      <P><SPAN class=strong>eg.</SPAN> <TT class=literal>true|false</TT> 
  </P></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.cache.use_query_cache</TT></TD>
    <TD>Enable the query cache, individual queries still have to be set 
      cachable. 
      <P><SPAN class=strong>eg.</SPAN> <TT class=literal>true|false</TT> 
  </P></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.cache.region_prefix</TT></TD>
    <TD>A prefix to use for second-level cache region names. 
      <P><SPAN class=strong>eg.</SPAN> <TT class=literal>prefix</TT> </P></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.transaction.factory_class</TT></TD>
    <TD>The classname of a <TT class=literal>TransactionFactory</TT> to use 
      with Hibernate <TT class=literal>Transaction</TT> API (defaults to <TT 
      class=literal>JDBCTransactionFactory</TT>). 
      <P><SPAN class=strong>eg.</SPAN> <TT 
      class=literal>classname.of.TransactionFactory</TT> </P></TD></TR>
  <TR>
    <TD><TT class=literal>jta.UserTransaction</TT></TD>
    <TD>A JNDI name used by <TT class=literal>JTATransactionFactory</TT> to 
      obtain the JTA <TT class=literal>UserTransaction</TT> from the application 
      server. 
      <P><SPAN class=strong>eg.</SPAN> <TT 
      class=literal>jndi/composite/name</TT> </P></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.transaction.manager_lookup_class</TT></TD>
    <TD>The classname of a <TT class=literal>TransactionManagerLookup</TT> - 
      required when JVM-level caching is enabled in a JTA environment. 
      <P><SPAN class=strong>eg.</SPAN> <TT 
      class=literal>classname.of.TransactionManagerLookup</TT> </P></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.query.substitutions</TT></TD>
    <TD>Mapping from tokens in Hibernate queries to SQL tokens (tokens might 
      be function or literal names, for example). 
      <P><SPAN class=strong>eg.</SPAN> <TT class=literal>hqlLiteral=SQL_LITERAL, 
      hqlFunction=SQLFUNC</TT> </P></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.show_sql</TT></TD>
    <TD>Write all SQL statements to console. 
      <P><SPAN class=strong>eg.</SPAN> <TT class=literal>true</TT> | <TT 
      class=literal>false</TT> </P></TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.hbm2ddl.auto</TT></TD>
    <TD>Automatically export schema DDL to the database when the <TT 
      class=literal>SessionFactory</TT> is created. With <TT 
      class=literal>create-drop</TT>, the database schema will be dropped when 
      the <TT class=literal>SessionFactory</TT> is closed explicitely. 
      <P><SPAN class=strong>eg.</SPAN> <TT class=literal>update</TT> | <TT 
      class=literal>create</TT> | <TT class=literal>create-drop</TT> 
  </P></TD></TR></TBODY></TABLE></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=configuration-optional-dialects></A>3.5.1.&nbsp;SQL 
Dialects</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>You should always set the <TT class=literal>hibernate.dialect</TT> property 
to the correct <TT class=literal>net.sf.hibernate.dialect.Dialect</TT> subclass 
for your database. This is not strictly essential unless you wish to use <TT 
class=literal>native</TT> or <TT class=literal>sequence</TT> primary key 
generation or pessimistic locking (with, eg. <TT 
class=literal>Session.lock()</TT> or <TT 
class=literal>Query.setLockMode()</TT>). However, if you specify a dialect, 
Hibernate will use sensible defaults for some of the other properties listed 
above, saving you the effort of specifying them manually. </P>
<DIV class=table><A name=d0e1396></A>
<P class=title><B>Table&nbsp;3.4.&nbsp;Hibernate SQL Dialects (<TT 
class=literal>hibernate.dialect</TT>)</B></P>
<TABLE summary="Hibernate SQL Dialects (hibernate.dialect)" border=1>
  <COLGROUP>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>RDBMS</TH>
    <TH>Dialect</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>DB2</TD>
    <TD><TT class=literal>net.sf.hibernate.dialect.DB2Dialect</TT></TD></TR>
  <TR>
    <TD>MySQL</TD>
    <TD><TT class=literal>net.sf.hibernate.dialect.MySQLDialect</TT></TD></TR>
  <TR>
    <TD>SAP DB</TD>
    <TD><TT class=literal>net.sf.hibernate.dialect.SAPDBDialect</TT></TD></TR>
  <TR>
    <TD>Oracle (any version)</TD>
    <TD><TT class=literal>net.sf.hibernate.dialect.OracleDialect</TT></TD></TR>
  <TR>
    <TD>Oracle 9</TD>
    <TD><TT class=literal>net.sf.hibernate.dialect.Oracle9Dialect</TT></TD></TR>
  <TR>
    <TD>Sybase</TD>
    <TD><TT class=literal>net.sf.hibernate.dialect.SybaseDialect</TT></TD></TR>
  <TR>
    <TD>Sybase Anywhere</TD>
    <TD><TT 
    class=literal>net.sf.hibernate.dialect.SybaseAnywhereDialect</TT></TD></TR>
  <TR>
    <TD>Progress</TD>
    <TD><TT class=literal>net.sf.hibernate.dialect.ProgressDialect</TT></TD></TR>
  <TR>
    <TD>Mckoi SQL</TD>
    <TD><TT class=literal>net.sf.hibernate.dialect.MckoiDialect</TT></TD></TR>
  <TR>
    <TD>Interbase</TD>
    <TD><TT class=literal>net.sf.hibernate.dialect.InterbaseDialect</TT></TD></TR>
  <TR>
    <TD>Pointbase</TD>
    <TD><TT class=literal>net.sf.hibernate.dialect.PointbaseDialect</TT></TD></TR>
  <TR>
    <TD>PostgreSQL</TD>
    <TD><TT 
class=literal>net.sf.hibernate.dialect.PostgreSQLDialect</TT></TD></TR>
  <TR>
    <TD>HypersonicSQL</TD>
    <TD><TT class=literal>net.sf.hibernate.dialect.HSQLDialect</TT></TD></TR>
  <TR>
    <TD>Microsoft SQL Server</TD>
    <TD><TT class=literal>net.sf.hibernate.dialect.SQLServerDialect</TT></TD></TR>
  <TR>
    <TD>Ingres</TD>
    <TD><TT class=literal>net.sf.hibernate.dialect.IngresDialect</TT></TD></TR>
  <TR>
    <TD>Informix</TD>
    <TD><TT class=literal>net.sf.hibernate.dialect.InformixDialect</TT></TD></TR>
  <TR>
    <TD>FrontBase</TD>
    <TD><TT 
  class=literal>net.sf.hibernate.dialect.FrontbaseDialect</TT></TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=configuration-optional-outerjoin></A>3.5.2.&nbsp;Outer 
Join Fetching</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>If your database supports ANSI or Oracle style outer joins, <SPAN 
class=emphasis><EM>outer join fetching</EM></SPAN> might increase performance by 
limiting the number of round trips to and from the database (at the cost of 
possibly more work performed by the database itself). Outer join fetching allows 
a graph of objects connected by many-to-one, one-to-many or one-to-one 
associations to be retrieved in a single SQL <TT class=literal>SELECT</TT>. </P>
<P>By default, the fetched graph when loading an objects ends at leaf objects, 
collections, objects with proxies, or where circularities occur. </P>
<P>For a <SPAN class=emphasis><EM>particular association</EM></SPAN>, fetching 
may be enabled or disabled (and the default behaviour overridden) by setting the 
<TT class=literal>outer-join</TT> attribute in the XML mapping. </P>
<P>Outer join fetching may be disabled <SPAN 
class=emphasis><EM>globally</EM></SPAN> by setting the property <TT 
class=literal>hibernate.max_fetch_depth</TT> to <TT class=literal>0</TT>. A 
setting of <TT class=literal>1</TT> or higher enables outer join fetching for 
all one-to-one and many-to-one associations, which are, also by default, set to 
<TT class=literal>auto</TT> outer join. However, one-to-many associations and 
collections are never fetched with an outer-join, unless explicitely declared 
for each particular association. This behavior can also be overriden at runtime 
with Hibernate queries. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=configuration-optional-binarystreams></A>3.5.3.&nbsp;Binary 
Streams</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>Oracle limits the size of <TT class=literal>byte</TT> arrays that may be 
passed to/from its JDBC driver. If you wish to use large instances of <TT 
class=literal>binary</TT> or <TT class=literal>serializable</TT> type, you 
should enable <TT class=literal>hibernate.jdbc.use_streams_for_binary</TT>. 
<SPAN class=emphasis><EM>This is a JVM-level setting only.</EM></SPAN> 
</P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=configuration-optional-cacheprovider></A>3.5.4.&nbsp;Custom <TT 
class=literal>CacheProvider</TT></H3></DIV></DIV>
<DIV></DIV></DIV>
<P>You may integrate a JVM-level (or clustered) second-level cache system by 
implementing the interface <TT 
class=literal>net.sf.hibernate.cache.CacheProvider</TT>. You may select the 
custom implementation by setting <TT 
class=literal>hibernate.cache.provider_class</TT>. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=configuration-optional-transactionstrategy></A>3.5.5.&nbsp;Transaction 
strategy configuration</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>If you wish to use the Hibernate <TT class=literal>Transaction</TT> API, you 
must specify a factory class for <TT class=literal>Transaction</TT> instances by 
setting the property <TT class=literal>hibernate.transaction.factory_class</TT>. 
The <TT class=literal>Transaction</TT> API hides the underlying transaction 
mechanism and allows Hibernate code to run in managed and non-managed 
environments. </P>
<P>There are two standard (built-in) choices: </P>
<DIV class=variablelist>
<DL>
  <DT><SPAN class=term><TT 
  class=literal>net.sf.hibernate.transaction.JDBCTransactionFactory</TT></SPAN>
  <DD>
  <P>delegates to database (JDBC) transactions (default)</P>
  <DT><SPAN class=term><TT 
  class=literal>net.sf.hibernate.transaction.JTATransactionFactory</TT></SPAN>
  <DD>
  <P>delegates to JTA (if an existing transaction is underway, the <TT 
  class=literal>Session</TT> performs its work in that context, otherwise a new 
  transaction is started)</P></DD></DL></DIV>
<P>You may also define your own transaction strategies (for a CORBA transaction 
service, for example). </P>
<P>If you wish to use JVM-level caching of mutable data in a JTA environment, 
you must specify a strategy for obtaining the JTA <TT 
class=literal>TransactionManager</TT>, as this is not standardized for J2EE 
containers: </P>
<DIV class=table><A name=d0e1629></A>
<P class=title><B>Table&nbsp;3.5.&nbsp;JTA TransactionManagers</B></P>
<TABLE summary="JTA TransactionManagers" border=1>
  <COLGROUP>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Transaction Factory</TH>
    <TH align=middle>Application Server</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><TT 
      class=literal>net.sf.hibernate.transaction.JBossTransactionManagerLookup</TT></TD>
    <TD align=middle>JBoss</TD></TR>
  <TR>
    <TD><TT 
      class=literal>net.sf.hibernate.transaction.WeblogicTransactionManagerLookup</TT></TD>
    <TD align=middle>Weblogic</TD></TR>
  <TR>
    <TD><TT 
      class=literal>net.sf.hibernate.transaction.WebSphereTransactionManagerLookup</TT></TD>
    <TD align=middle>WebSphere</TD></TR>
  <TR>
    <TD><TT 
      class=literal>net.sf.hibernate.transaction.OrionTransactionManagerLookup</TT></TD>
    <TD align=middle>Orion</TD></TR>
  <TR>
    <TD><TT 
      class=literal>net.sf.hibernate.transaction.ResinTransactionManagerLookup</TT></TD>
    <TD align=middle>Resin</TD></TR>
  <TR>
    <TD><TT 
      class=literal>net.sf.hibernate.transaction.JOTMTransactionManagerLookup</TT></TD>
    <TD align=middle>JOTM</TD></TR>
  <TR>
    <TD><TT 
      class=literal>net.sf.hibernate.transaction.JOnASTransactionManagerLookup</TT></TD>
    <TD align=middle>JOnAS</TD></TR>
  <TR>
    <TD><TT 
      class=literal>net.sf.hibernate.transaction.JRun4TransactionManagerLookup</TT></TD>
    <TD align=middle>JRun4</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=configuration-optional-jndi></A>3.5.6.&nbsp;JNDI-bound 
<TT class=literal>SessionFactory</TT></H3></DIV></DIV>
<DIV></DIV></DIV>
<P>A JNDI bound Hibernate <TT class=literal>SessionFactory</TT> can simplify the 
lookup of the factory and the creation of new <TT class=literal>Session</TT>s. 
</P>
<P>If you wish to have the <TT class=literal>SessionFactory</TT> bound to a JNDI 
namespace, specify a name (eg. <TT 
class=literal>java:comp/env/hibernate/SessionFactory</TT>) using the property 
<TT class=literal>hibernate.session_factory_name</TT>. If this property is 
omitted, the <TT class=literal>SessionFactory</TT> will not be bound to JNDI. 
(This is especially useful in environments with a read-only JNDI default 
implementation, eg. Tomcat.) </P>
<P>When binding the <TT class=literal>SessionFactory</TT> to JNDI, Hibernate 
will use the values of <TT class=literal>hibernate.jndi.url</TT>, <TT 
class=literal>hibernate.jndi.class</TT> to instantiate an initial context. If 
they are not specified, the default <TT class=literal>InitialContext</TT> will 
be used. </P>
<P>If you do choose to use JNDI, an EJB or other utility class may obtain the 
<TT class=literal>SessionFactory</TT> using a JNDI lookup. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=configuration-optional-querysubstitution></A>3.5.7.&nbsp;Query Language 
Substitution</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>You may define new Hibernate query tokens using <TT 
class=literal>hibernate.query.substitutions</TT>. For example: </P><PRE class=programlisting>hibernate.query.substitutions true=1, false=0</PRE>
<P>would cause the tokens <TT class=literal>true</TT> and <TT 
class=literal>false</TT> to be translated to integer literals in the generated 
SQL. </P><PRE class=programlisting>hibernate.query.substitutions toLowercase=LOWER</PRE>
<P>would allow you to rename the SQL <TT class=literal>LOWER</TT> function. 
</P></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=configuration-logging></A>3.6.&nbsp;Logging</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Hibernate logs various events using Apache commons-logging. </P>
<P>The commons-logging service will direct output to either Apache Log4j (if you 
include <TT class=literal>log4j.jar</TT> in your classpath) or JDK1.4 logging 
(if running under JDK1.4 or above). You may download Log4j from <TT 
class=literal>http://jakarta.apache.org</TT>. To use Log4j you will need to 
place a <TT class=literal>log4j.properties</TT> file in your classpath, an 
example properties file is distributed with Hibernate in the <TT 
class=literal>src/</TT> directory. </P>
<P>We strongly recommend that you familiarize yourself with Hibernate's log 
messages. A lot of work has been put into making the Hibernate log as detailed 
as possible, without making it unreadable. It is an essential troubleshooting 
device. Also don't forget to enable SQL logging as described above (<TT 
class=literal>hibernate.show_sql</TT>), it is your first step when looking for 
performance problems. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=configuration-namingstrategy></A>3.7.&nbsp;Implementing a <TT 
class=literal>NamingStrategy</TT></H2></DIV></DIV>
<DIV></DIV></DIV>
<P>The interface <TT class=literal>net.sf.hibernate.cfg.NamingStrategy</TT> 
allows you to specify a "naming standard" for database objects and schema 
elements. </P>
<P>You may provide rules for automatically generating database identifiers from 
Java identifiers or for processing "logical" column and table names given in the 
mapping file into "physical" table and column names. This feature helps reduce 
the verbosity of the mapping document, eliminating repetitive noise (<TT 
class=literal>TBL_</TT> prefixes, for example). The default strategy used by 
Hibernate is quite minimal. </P>
<P>You may specify a different strategy by calling <TT 
class=literal>Configuration.setNamingStrategy()</TT> before adding mappings: 
</P><PRE class=programlisting>SessionFactory sf = new Configuration()
    .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)
    .addFile("Item.hbm.xml")
    .addFile("Bid.hbm.xml")
    .buildSessionFactory();</PRE>
<P><TT class=literal>net.sf.hibernate.cfg.ImprovedNamingStrategy</TT> is a 
built-in strategy that might be a useful starting point for some applications. 
</P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=configuration-xmlconfig></A>3.8.&nbsp;XML Configuration 
File</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>An alternative approach is to specify a full configuration in a file named 
<TT class=literal>hibernate.cfg.xml</TT>. This file can be used as a replacement 
for the <TT class=literal>hibernate.properties</TT> file or, if both are 
present, override properties. </P>
<P>The XML configuration file is by default expected to be in the root o your 
<TT class=literal>CLASSPATH</TT>. Here is an example: </P><PRE class=programlisting>&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 2.0//EN"

 "http://hibernate.sourceforge.net/hibernate-configuration-2.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;!-- a SessionFactory instance listed as /jndi/name --&gt;
    &lt;session-factory
        name="java:comp/env/hibernate/SessionFactory"&gt;

        &lt;!-- properties --&gt;
        &lt;property name="connection.datasource"&gt;my/first/datasource&lt;/property&gt;
        &lt;property name="dialect"&gt;net.sf.hibernate.dialect.MySQLDialect&lt;/property&gt;
        &lt;property name="show_sql"&gt;false&lt;/property&gt;
        &lt;property name="use_outer_join"&gt;true&lt;/property&gt;
        &lt;property name="transaction.factory_class"&gt;
            net.sf.hibernate.transaction.JTATransactionFactory
        &lt;/property&gt;
        &lt;property name="jta.UserTransaction"&gt;java:comp/UserTransaction&lt;/property&gt;

        &lt;!-- mapping files --&gt;
        &lt;mapping resource="org/hibernate/auction/Item.hbm.xml"/&gt;
        &lt;mapping resource="org/hibernate/auction/Bid.hbm.xml"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</PRE>
<P>Configuring Hibernate is then as simple as </P><PRE class=programlisting>SessionFactory sf = new Configuration().configure().buildSessionFactory();</PRE>
<P>You can pick a different XML configuration file using </P><PRE class=programlisting>SessionFactory sf = new Configuration()
    .configure("catdb.cfg.xml")
    .buildSessionFactory();</PRE></DIV></DIV>
<DIV class=chapter lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A name=persistent-classes></A>Chapter&nbsp;4.&nbsp;Persistent 
Classes</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Persistent classes are classes in an application that implement the entities 
of the business problem (e.g. Customer and Order in an E-commerce application). 
Persistent classes have, as the name implies, transient and also persistent 
instance stored in the database. </P>
<P>Hibernate works best if these classes follow some simple rules, also known as 
the Plain Old Java Object (POJO) programming model. </P>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=persistent-classes-pojo></A>4.1.&nbsp;A simple POJO 
example</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Most Java applications require a persistent class representing felines. </P><PRE class=programlisting>package eg;
import java.util.Set;
import java.util.Date;

public class Cat {
    private Long id; // identifier
    private String name;
    private Date birthdate;
    private Cat mate;
    private Set kittens
    private Color color;
    private char sex;
    private float weight;

    private void setId(Long id) {
        this.id=id;
    }
    public Long getId() {
        return id;
    }

    void setName(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }

    void setMate(Cat mate) {
        this.mate = mate;
    }
    public Cat getMate() {
        return mate;
    }

    void setBirthdate(Date date) {
        birthdate = date;
    }
    public Date getBirthdate() {
        return birthdate;
    }
    void setWeight(float weight) {
        this.weight = weight;
    }
    public float getWeight() {
        return weight;
    }

    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    public Set getKittens() {
        return kittens;
    }
    // addKitten not needed by Hibernate
    public void addKitten(Cat kitten) {
        kittens.add(kitten);
    }
    void setSex(char sex) {
        this.sex=sex;
    }
    public char getSex() {
        return sex;
    }
}</PRE>
<P>There are four main rules to follow here: </P>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=persistent-classes-pojo-accessors></A>4.1.1.&nbsp;Declare accessors and 
mutators for persistent fields</H3></DIV></DIV>
<DIV></DIV></DIV>
<P><TT class=literal>Cat</TT> declares accessor methods for all its persistent 
fields. Many other ORM tools directly persist instance variables. We believe it 
is far better to decouple this implementation detail from the persistence 
mechanism. Hibernate persists JavaBeans style properties, and recognizes method 
names of the form <TT class=literal>getFoo</TT>, <TT class=literal>isFoo</TT> 
and <TT class=literal>setFoo</TT>. </P>
<P>Properties need <SPAN class=emphasis><EM>not</EM></SPAN> be declared public - 
Hibernate can persist a property with a default, <TT 
class=literal>protected</TT> or <TT class=literal>private</TT> get / set pair. 
</P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=persistent-classes-pojo-constructor></A>4.1.2.&nbsp;Implement a default 
constructor</H3></DIV></DIV>
<DIV></DIV></DIV>
<P><TT class=literal>Cat</TT> has an implicit default (no-argument) constructor. 
All persistent classes must have a default constructor (which may be non-public) 
so Hibernate can instantiate them using <TT 
class=literal>Constructor.newInstance()</TT>. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=persistent-classes-pojo-identifier></A>4.1.3.&nbsp;Provide an identifier 
property (optional)</H3></DIV></DIV>
<DIV></DIV></DIV>
<P><TT class=literal>Cat</TT> has a property called <TT class=literal>id</TT>. 
This property holds the primary key column of a database table. The property 
might have been called anything, and its type might have been any primitive 
type, any primitive "wrapper" type, <TT class=literal>java.lang.String</TT> or 
<TT class=literal>java.util.Date</TT>. (If your legacy database table has 
composite keys, you can even use a user-defined class with properties of these 
types - see the section on composite identifiers below.) </P>
<P>The identifier property is optional. You can leave it off and let Hibernate 
keep track of object identifiers internally. However, for many applications it 
is still a good (and very popular) design decision. </P>
<P>What's more, some functionality is available only to classes which declare an 
identifier property: </P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P>Cascaded updates (see "Lifecycle Objects") </P>
  <LI>
  <P><TT class=literal>Session.saveOrUpdate()</TT> </P></LI></UL></DIV>
<P>We recommend you declare consistently-named identifier properties on 
persistent classes. We further recommend that you use a nullable (ie. 
non-primitive) type. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=persistent-classes-pojo-final></A>4.1.4.&nbsp;Prefer 
non-final classes (optional)</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>A central feature of Hibernate, <SPAN class=emphasis><EM>proxies</EM></SPAN>, 
depends upon the persistent class being either non-final, or the implementation 
of an interface that declares all public methods. </P>
<P>You can persist <TT class=literal>final</TT> classes that do not implement an 
interface with Hibernate, but you won't be able to use proxies - which will 
limit your options for performance tuning somewhat. </P></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=persistent-classes-inheritance></A>4.2.&nbsp;Implementing 
inheritance</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>A subclass must also observe the first and second rules. It inherits its 
identifier property from <TT class=literal>Cat</TT>. </P><PRE class=programlisting>package eg;

public class DomesticCat extends Cat {
        private String name;

        public String getName() {
                return name;
        }
        protected void setName(String name) {
                this.name=name;
        }
}</PRE></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=persistent-classes-equalshashcode></A>4.3.&nbsp;Implementing <TT 
class=literal>equals()</TT> and <TT 
class=literal>hashCode()</TT></H2></DIV></DIV>
<DIV></DIV></DIV>
<P>You have to override the <TT class=literal>equals()</TT> and <TT 
class=literal>hashCode()</TT> methods if you intend to mix objects of persistent 
classes (e.g. in a <TT class=literal>Set</TT>). </P>
<P><SPAN class=emphasis><EM>This only applies if these objects are loaded in two 
different <TT class=literal>Session</TT>s, as Hibernate only guarantees JVM 
identity (<TT class=literal> a == b </TT>, the default implementation of <TT 
class=literal>equals()</TT>) inside a single <TT 
class=literal>Session</TT>!</EM></SPAN> </P>
<P>Even if both objecs <TT class=literal>a</TT> and <TT class=literal>b</TT> are 
the same database row (they have the same primary key value as their 
identifier), we can't guarantee that they are the same Java instance outside of 
a particular <TT class=literal>Session</TT> context. </P>
<P>The most obvious way is to implement <TT class=literal>equals()</TT>/<TT 
class=literal>hashCode()</TT> by comparing the identifier value of both objects. 
If the value is the same, both must be the same database row, they are therefore 
equal (if both are added to a <TT class=literal>Set</TT>, we will only have one 
element in the <TT class=literal>Set</TT>). Unfortunately, we can't use that 
approach. Hibernate will only assign identifier values to objects that are 
persistent, a newly created instance will not have any identifier value! We 
recommend implementing <TT class=literal>equals()</TT> and <TT 
class=literal>hashCode()</TT> using <SPAN class=emphasis><EM>Business key 
equality</EM></SPAN>. </P>
<P>Business key equality means that the <TT class=literal>equals()</TT> method 
compares only the properties that form the business key, a key that would 
identify our instance in the real world (a <SPAN 
class=emphasis><EM>natural</EM></SPAN> candidate key): </P><PRE class=programlisting>public class Cat {

    ...
    public boolean equals(Object other) {
        if (this == other) return true;
        if (!(other instanceof Cat)) return false;

        final Cat cat = (Cat) other;

        if (!getName().equals(cat.getName())) return false;
        if (!getBirthday().equals(cat.getBirthday())) return false;

        return true;
    }

    public int hashCode() {
        int result;
        result = getName().hashCode();
        result = 29 * result + getBirthday().hashCode();
        return result;
    }

}</PRE>
<P>Keep in mind that our candidate key (in this case a composite of name and 
birthday) has to be only valid for a particular comparison operation (maybe even 
only in a single use case). We don't need the stability criteria we usually 
apply to a real primary key! </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=persistent-classes-lifecycle></A>4.4.&nbsp;Lifecycle 
Callbacks</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Optionally, a persistent class might implement the interface <TT 
class=literal>Lifecycle</TT> which provides some callbacks that allow the 
persistent object to perform necessary initialization/cleanup after save or load 
and before deletion or update. </P>
<P>The Hibernate <TT class=literal>Interceptor</TT> offers a less intrusive 
alternative, however. </P>
<DIV class=programlistingco><PRE class=programlisting>public interface Lifecycle {
        public boolean onSave(Session s) throws CallbackException;   <SPAN class=co>(1)</SPAN>
        public boolean onUpdate(Session s) throws CallbackException; <SPAN class=co>(2)</SPAN>
        public boolean onDelete(Session s) throws CallbackException; <SPAN class=co>(3)</SPAN>
        public void onLoad(Session s, Serializable id);              <SPAN class=co>(4)</SPAN>
}</PRE>
<DIV class=calloutlist>
<TABLE summary="Callout list" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="5%">(1)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>onSave</TT> - called just before the object is saved 
      or inserted </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(2)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>onUpdate</TT> - called just before an object is 
      updated (when the object is passed to <TT 
      class=literal>Session.update()</TT>) </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(3)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>onDelete</TT> - called just before an object is 
      deleted </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(4)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>onLoad</TT> - called just after an object is loaded 
      </P></TD></TR></TBODY></TABLE></DIV></DIV>
<P><TT class=literal>onSave()</TT>, <TT class=literal>onDelete()</TT> and <TT 
class=literal>onUpdate()</TT> may be used to cascade saves and deletions of 
dependent objects. This is an alternative to declaring cascaded operations in 
the mapping file. <TT class=literal>onLoad()</TT> may be used to initialize 
transient properties of the object from its persistent state. It may not be used 
to load dependent objects since the <TT class=literal>Session</TT> interface may 
not be invoked from inside this method. A further intended usage of <TT 
class=literal>onLoad()</TT>, <TT class=literal>onSave()</TT> and <TT 
class=literal>onUpdate()</TT> is to store a reference to the current <TT 
class=literal>Session</TT> for later use. </P>
<P>Note that <TT class=literal>onUpdate()</TT> is not called every time the 
object's persistent state is updated. It is called only when a transient object 
is passed to <TT class=literal>Session.update()</TT>. </P>
<P>If <TT class=literal>onSave()</TT>, <TT class=literal>onUpdate()</TT> or <TT 
class=literal>onDelete()</TT> return <TT class=literal>true</TT>, the operation 
is silently vetoed. If a <TT class=literal>CallbackException</TT> is thrown, the 
operation is vetoed and the exception is passed back to the application. </P>
<P>Note that <TT class=literal>onSave()</TT> is called after an identifier is 
assigned to the object, except when native key generation is used. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=persistent-classes-validatable></A>4.5.&nbsp;Validatable 
callback</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>If the persistent class needs to check invariants before its state is 
persisted, it may implement the following interface: </P><PRE class=programlisting>public interface Validatable {
        public void validate() throws ValidationFailure;
}</PRE>
<P>The object should throw a <TT class=literal>ValidationFailure</TT> if an 
invariant was violated. An instance of <TT class=literal>Validatable</TT> should 
not change its state from inside <TT class=literal>validate()</TT>. </P>
<P>Unlike the callback methods of the <TT class=literal>Lifecycle</TT> 
interface, <TT class=literal>validate()</TT> might be called at unpredictable 
times. The application should not rely upon calls to <TT 
class=literal>validate()</TT> for business functionality. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=persistent-classes-xdoclet></A>4.6.&nbsp;Using XDOclet 
markup</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>In the next chapter we will show how Hibernate mappings may be expressed 
using a simple, readable XML format. Many Hibernate users prefer to embed 
mapping information directly in sourcecode using XDoclet <TT 
class=literal>@hibernate.tags</TT>. We will not cover this approach in this 
document, since strictly it is considered part of XDoclet. However, we include 
the following example of the <TT class=literal>Cat</TT> class with XDoclet 
mappings. </P><PRE class=programlisting>package eg;
import java.util.Set;
import java.util.Date;

/**
 * @hibernate.class
 *  table="CATS"
 */
public class Cat {
    private Long id; // identifier
    private Date birthdate;
    private Cat mate;
    private Set kittens
    private Color color;
    private char sex;
    private float weight;

    /**
     * @hibernate.id
     *  generator-class="native"
     *  column="CAT_ID"
     */
    public Long getId() {
        return id;
    }
    private void setId(Long id) {
        this.id=id;
    }

    /**
     * @hibernate.many-to-one
     *  column="MATE_ID"
     */
    public Cat getMate() {
        return mate;
    }
    void setMate(Cat mate) {
        this.mate = mate;
    }

    /**
     * @hibernate.property
     *  column="BIRTH_DATE"
     */
    public Date getBirthdate() {
        return birthdate;
    }
    void setBirthdate(Date date) {
        birthdate = date;
    }
    /**
     * @hibernate.property
     *  column="WEIGHT"
     */
    public float getWeight() {
        return weight;
    }
    void setWeight(float weight) {
        this.weight = weight;
    }

    /**
     * @hibernate.property
     *  column="COLOR"
     *  not-null="true"
     */
    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }
    /**
     * @hibernate.set
     *  lazy="true"
     *  order-by="BIRTH_DATE"
     * @hibernate.collection-key
     *  column="PARENT_ID"
     * @hibernate.collection-one-to-many
     */
    public Set getKittens() {
        return kittens;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    // addKitten not needed by Hibernate
    public void addKitten(Cat kitten) {
        kittens.add(kitten);
    }

    /**
     * @hibernate.property
     *  column="SEX"
     *  not-null="true"
     *  update="false"
     */
    public char getSex() {
        return sex;
    }
    void setSex(char sex) {
        this.sex=sex;
    }
}</PRE></DIV></DIV>
<DIV class=chapter lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A name=mapping></A>Chapter&nbsp;5.&nbsp;Basic O/R 
Mapping</H2></DIV></DIV>
<DIV></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=mapping-declaration></A>5.1.&nbsp;Mapping declaration</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Object/relational mappings are defined in an XML document. The mapping 
document is designed to be readable and hand-editable. The mapping language is 
Java-centric, meaning that mappings are constructed around persistent class 
declarations, not table declarations. </P>
<P>Note that, even though many Hibernate users choose to define XML mappings be 
hand, a number of tools exist to generate the mapping document, including 
XDoclet, Middlegen and AndroMDA. </P>
<P>Lets kick off with an example mapping: </P><PRE class=programlisting>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 2.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

        &lt;class name="Cat" table="CATS" discriminator-value="C"&gt;
                &lt;id name="id" column="uid" type="long"&gt;
                        &lt;generator class="hilo"/&gt;
                &lt;/id&gt;
                &lt;discriminator column="subclass" type="character"/&gt;
                &lt;property name="birthdate" type="date"/&gt;
                &lt;property name="color" not-null="true"/&gt;
                &lt;property name="sex" not-null="true" update="false"/&gt;
                &lt;property name="weight"/&gt;
                &lt;many-to-one name="mate" column="mate_id"/&gt;
                &lt;set name="kittens"&gt;
                        &lt;key column="mother_id"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;
                &lt;subclass name="DomesticCat" discriminator-value="D"&gt;
                        &lt;property name="name" type="string"/&gt;
                &lt;/subclass&gt;
        &lt;/class&gt;

        &lt;class name="Dog"&gt;
                &lt;!-- mapping for Dog could go here --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping&gt;</PRE>
<P>We will now discuss the content of the mapping document. We will only 
describe the document elements and attributes that are used by Hibernate at 
runtime. The mapping document also contains some extra optional attributes and 
elements that affect the database schemas exported by the schema export tool. 
(For example the <TT class=literal>not-null</TT> attribute.) </P>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=mapping-declaration-doctype></A>5.1.1.&nbsp;Doctype</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>All XML mappings should declare the doctype shown. The actual DTD may be 
found at the URL above, in the directory <TT 
class=literal>hibernate-x.x.x/src/net/sf/hibernate </TT>or in <TT 
class=literal>hibernate.jar</TT>. Hibernate will always look for the DTD in its 
classpath first. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=mapping-declaration-mapping></A>5.1.2.&nbsp;hibernate-mapping</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>This element has three optional attributes. The <TT class=literal>schema</TT> 
attribute specifies that tables referred to by this mapping belong to the named 
schema. If specified, tablenames will be qualified by the given schema name. If 
missing, tablenames will be unqualified. The <TT 
class=literal>default-cascade</TT> attribute specifies what cascade style should 
be assumed for properties and collections which do not specify a <TT 
class=literal>cascade</TT> attribute. The <TT class=literal>auto-import</TT> 
attribute lets us use unqualified class names in the query language, by default. 
</P>
<DIV class=programlistingco><PRE class=programlisting>&lt;hibernate-mapping
         schema="schemaName"                          <SPAN class=co>(1)</SPAN>
         default-cascade="none|save-update"           <SPAN class=co>(2)</SPAN>
         auto-import="true|false"                     <SPAN class=co>(3)</SPAN>
         package="package.name"                       <SPAN class=co>(4)</SPAN>
 /&gt;</PRE>
<DIV class=calloutlist>
<TABLE summary="Callout list" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="5%">(1)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>schema</TT> (optional): The name of a database 
      schema. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(2)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>default-cascade</TT> (optional - defaults to <TT 
      class=literal>none</TT>): A default cascade style. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(3)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>auto-import</TT> (optional - defaults to <TT 
      class=literal>true</TT>): Specifies whether we can use unqualified class 
      names (of classes in this mapping) in the query language. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(4)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>package</TT> (optional): Specifies a package prefix 
      to assume for unqualified class names in the mapping document. 
  </P></TD></TR></TBODY></TABLE></DIV></DIV>
<P>If you have two persistent classes with the same (unqualified) name, you 
should set <TT class=literal>auto-import="false"</TT>. Hibernate will throw an 
exception if you attempt to assign two classes to the same "imported" name. 
</P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=mapping-declaration-class></A>5.1.3.&nbsp;class</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>You may declare a persistent class using the <TT class=literal>class</TT> 
element: </P>
<DIV class=programlistingco><PRE class=programlisting>&lt;class
        name="ClassName"                              <SPAN class=co>(1)</SPAN>
        table="tableName"                             <SPAN class=co>(2)</SPAN>
        discriminator-value="discriminator_value"     <SPAN class=co>(3)</SPAN>
        mutable="true|false"                          <SPAN class=co>(4)</SPAN>
        schema="owner"                                <SPAN class=co>(5)</SPAN>
        proxy="ProxyInterface"                        <SPAN class=co>(6)</SPAN>
        dynamic-update="true|false"                   <SPAN class=co>(7)</SPAN>
        dynamic-insert="true|false"                   <SPAN class=co>(8)</SPAN>
        select-before-update="true|false"             <SPAN class=co>(9)</SPAN>
        polymorphism="implicit|explicit"              <SPAN class=co>(10)</SPAN>
        where="arbitrary sql where condition"         <SPAN class=co>(11)</SPAN>
        persister="PersisterClass"                    <SPAN class=co>(12)</SPAN>
        batch-size="N"                                <SPAN class=co>(13)</SPAN>
        optimistic-lock="none|version|dirty|all"      <SPAN class=co>(14)</SPAN>
        lazy="true|false"                             <SPAN class=co>(15)</SPAN>
/&gt;</PRE>
<DIV class=calloutlist>
<TABLE summary="Callout list" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="5%">(1)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>name</TT>: The fully qualified Java class name of the 
      persistent class (or interface). </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(2)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>table</TT>: The name of its database table. 
</P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(3)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>discriminator-value</TT> (optional - defaults to the 
      class name): A value that distiguishes individual subclasses, used for 
      polymorphic behaviour. Acceptable values include <TT 
      class=literal>null</TT> and <TT class=literal>not null</TT>. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(4)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>mutable</TT> (optional, defaults to <TT 
      class=literal>true</TT>): Specifies that instances of the class are (not) 
      mutable. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(5)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>schema</TT> (optional): Override the schema name 
      specified by the root <TT class=literal>&lt;hibernate-mapping&gt;</TT> 
      element. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(6)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>proxy</TT> (optional): Specifies an interface to use 
      for lazy initializing proxies. You may specify the name of the class 
      itself. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(7)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>dynamic-update</TT> (optional, defaults to <TT 
      class=literal>false</TT>): Specifies that <TT class=literal>UPDATE</TT> 
      SQL should be generated at runtime and contain only those columns whose 
      values have changed. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(8)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>dynamic-insert</TT> (optional, defaults to <TT 
      class=literal>false</TT>): Specifies that <TT class=literal>INSERT</TT> 
      SQL should be generated at runtime and contain only the columns whose 
      values are not null. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(9)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>select-before-update</TT> (optional, defaults to <TT 
      class=literal>false</TT>): Specifies that Hibernate should <SPAN 
      class=emphasis><EM>never</EM></SPAN> perform an SQL <TT 
      class=literal>UPDATE</TT> unless it is certain that an object is actually 
      modified. In certain cases (actually, only when a transient object has 
      been associated with a new session using <TT class=literal>update()</TT>), 
      this means that Hibernate will perform an extra SQL <TT 
      class=literal>SELECT</TT> to determine if an <TT class=literal>UPDATE</TT> 
      is actually required. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(10)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>polymorphism</TT> (optional, defaults to <TT 
      class=literal>implicit</TT>): Determines whether implicit or explicit 
      query polymorphism is used. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(11)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>where</TT> (optional) specify an arbitrary SQL <TT 
      class=literal>WHERE</TT> condition to be used when retrieving objects of 
      this class </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(12)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>persister</TT> (optional): Specifies a custom <TT 
      class=literal>ClassPersister</TT>. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(13)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>batch-size</TT> (optional, defaults to <TT 
      class=literal>1</TT>) specify a "batch size" for fetching instances of 
      this class by identifier. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(14)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>optimistic-lock</TT> (optional, defaults to <TT 
      class=literal>version</TT>): Determines the optimistic locking strategy. 
      </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(15)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>lazy</TT> (optional): Setting <TT 
      class=literal>lazy="true"</TT> is a shortcut equalivalent to specifying 
      the name of the class itself as the <TT class=literal>proxy</TT> 
      interface. </P></TD></TR></TBODY></TABLE></DIV></DIV>
<P>It is perfectly acceptable for the named persistent class to be an interface. 
You would then declare implementing classes of that interface using the <TT 
class=literal>&lt;subclass&gt;</TT> element. You may persist any <SPAN 
class=emphasis><EM>static</EM></SPAN> inner class. You should specify the class 
name using the standard form ie. <TT class=literal>eg.Foo$Bar</TT>. </P>
<P>Immutable classes, <TT class=literal>mutable="false"</TT>, may not be updated 
or deleted by the application. This allows Hibernate to make some minor 
performance optimizations. </P>
<P>The optional <TT class=literal>proxy</TT> attribute enables lazy 
initialization of persistent instances of the class. Hibernate will initially 
return CGLIB proxies which implement the named interface. The actual persistent 
object will be loaded when a method of the proxy is invoked. See "Proxies for 
Lazy Initialization" below. </P>
<P><SPAN class=emphasis><EM>Implicit</EM></SPAN> polymorphism means that 
instances of the class will be returned by a query that names any superclass or 
implemented interface or the class and that instances of any subclass of the 
class will be returned by a query that names the class itself. <SPAN 
class=emphasis><EM>Explicit</EM></SPAN> polymorphism means that class instances 
will be returned only be queries that explicitly name that class and that 
queries that name the class will return only instances of subclasses mapped 
inside this <TT class=literal>&lt;class&gt;</TT> declaration as a <TT 
class=literal>&lt;subclass&gt;</TT> or <TT 
class=literal>&lt;joined-subclass&gt;</TT>. For most purposes the default, <TT 
class=literal>polymorphism="implicit"</TT>, is appropriate. Explicit 
polymorphism is useful when two different classes are mapped to the same table 
(this allows a "lightweight" class that contains a subset of the table columns). 
</P>
<P>The <TT class=literal>persister</TT> attribute lets you customize the 
persistence strategy used for the class. You may, for example, specify your own 
subclass of <TT class=literal>net.sf.hibernate.persister.EntityPersister</TT> or 
you might even provide a completely new implementation of the interface <TT 
class=literal>net.sf.hibernate.persister.ClassPersister</TT> that implements 
persistence via, for example, stored procedure calls, serialization to flat 
files or LDAP. See <TT class=literal>net.sf.hibernate.test.CustomPersister</TT> 
for a simple example (of "persistence" to a <TT class=literal>Hashtable</TT>). 
</P>
<P>Note that the <TT class=literal>dynamic-update</TT> and <TT 
class=literal>dynamic-insert</TT> settings are not inherited by subclasses and 
so may also be specified on the <TT class=literal>&lt;subclass&gt;</TT> or <TT 
class=literal>&lt;joined-subclass&gt;</TT> elements. These settings may increase 
performance in some cases, but might actually decrease performance in others. 
Use judiciously. </P>
<P>Use of <TT class=literal>select-before-update</TT> will usually decrease 
performance. It is very useful to prevent a database update trigger being called 
unnecessarily. </P>
<P>If you enable <TT class=literal>dynamic-update</TT>, you will have a choice 
of optimistic locking strategies: </P>
<DIV class=itemizedlist>
<UL type=disc>
  <LI>
  <P><TT class=literal>version</TT> check the version/timestamp columns </P>
  <LI>
  <P><TT class=literal>all</TT> check all columns </P>
  <LI>
  <P><TT class=literal>dirty</TT> check the changed columns </P>
  <LI>
  <P><TT class=literal>none</TT> do not use optimistic locking 
</P></LI></UL></DIV>
<P>We <SPAN class=emphasis><EM>very</EM></SPAN> strongly recommend that you use 
version/timestamp columns for optimistic locking with Hibernate. This is the 
optimal strategy with respect to performance and is the only strategy that 
correctly handles modifications made outside of the session (ie. when <TT 
class=literal>Session.update()</TT> is used). Keep in mind that a version or 
timestamp property should never be null, no matter what <TT 
class=literal>unsaved-value</TT> strategy, or an instance will be detected as 
transient. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=mapping-declaration-id></A>5.1.4.&nbsp;id</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>Mapped classes <SPAN class=emphasis><EM>must</EM></SPAN> declare the primary 
key column of the database table. Most classes will also have a JavaBeans-style 
property holding the unique identifier of an instance. The <TT 
class=literal>&lt;id&gt;</TT> element defines the mapping from that property to 
the primary key column. </P>
<DIV class=programlistingco><PRE class=programlisting>&lt;id
        name="propertyName"                      <SPAN class=co>(1)</SPAN>
        type="typename"                          <SPAN class=co>(2)</SPAN>
        column="column_name"                     <SPAN class=co>(3)</SPAN>
        unsaved-value="any|none|null|id_value"   <SPAN class=co>(4)</SPAN>
        access="field|property|ClassName"&gt;       <SPAN class=co>(5)</SPAN>

        &lt;generator class="generatorClass"/&gt;
&lt;/id&gt;</PRE>
<DIV class=calloutlist>
<TABLE summary="Callout list" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="5%">(1)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>name</TT> (optional): The name of the identifier 
      property. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(2)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>type</TT> (optional): A name that indicates the 
      Hibernate type. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(3)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>column</TT> (optional - defaults to the property 
      name): The name of the primary key column. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(4)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>unsaved-value</TT> (optional - defaults to <TT 
      class=literal>null</TT>): An identifier property value that indicates that 
      an instance is newly instantiated (unsaved), distinguishing it from 
      transient instances that were saved or loaded in a previous session. 
    </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(5)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>access</TT> (optional - defaults to <TT 
      class=literal>property</TT>): The strategy Hibernate should use for 
      accessing the property value. </P></TD></TR></TBODY></TABLE></DIV></DIV>
<P>If the <TT class=literal>name</TT> attribute is missing, it is assumed that 
the class has no identifier property. </P>
<P>The <TT class=literal>unsaved-value</TT> attribute is important! If the 
identfier property of your class does not default to <TT 
class=literal>null</TT>, then you should specify the actual default. </P>
<P>There is an alternative <TT class=literal>&lt;composite-id&gt;</TT> 
declaration to allow access to legacy data with composite keys. We strongly 
discourage its use for anything else. </P>
<DIV class=sect3 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A 
name=mapping-declaration-id-generator></A>5.1.4.1.&nbsp;generator</H4></DIV></DIV>
<DIV></DIV></DIV>
<P>The required <TT class=literal>&lt;generator&gt;</TT> child element names a 
Java class used to generate unique identifiers for instances of the persistent 
class. If any parameters are required to configure or initialize the generator 
instance, they are passed using the <TT class=literal>&lt;param&gt;</TT> 
element. </P><PRE class=programlisting>&lt;id name="id" type="long" column="uid" unsaved-value="0"&gt;
        &lt;generator class="net.sf.hibernate.id.TableHiLoGenerator"&gt;
                &lt;param name="table"&gt;uid_table&lt;/param&gt;
                &lt;param name="column"&gt;next_hi_value_column&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</PRE>
<P>All generators implement the interface <TT 
class=literal>net.sf.hibernate.id.IdentifierGenerator</TT>. This is a very 
simple interface; some applications may choose to provide their own specialized 
implementations. However, Hibernate provides a range of built-in 
implementations. There are shortcut names for the built-in generators: </P>
<DIV class=variablelist>
<DL>
  <DT><SPAN class=term><TT class=literal>increment</TT></SPAN>
  <DD>
  <P>generates identifiers of type <TT class=literal>long</TT>, <TT 
  class=literal>short</TT> or <TT class=literal>int</TT> that are unique only 
  when no other process is inserting data into the same table. <SPAN 
  class=emphasis><EM>Do not use in a cluster.</EM></SPAN> </P>
  <DT><SPAN class=term><TT class=literal>identity</TT></SPAN>
  <DD>
  <P>supports identity columns in DB2, MySQL, MS SQL Server, Sybase and 
  HypersonicSQL. The returned identifier is of type <TT class=literal>long</TT>, 
  <TT class=literal>short</TT> or <TT class=literal>int</TT>. </P>
  <DT><SPAN class=term><TT class=literal>sequence</TT></SPAN>
  <DD>
  <P>uses a sequence in DB2, PostgreSQL, Oracle, SAP DB, McKoi or a generator in 
  Interbase. The returned identifier is of type <TT class=literal>long</TT>, <TT 
  class=literal>short</TT> or <TT class=literal>int</TT> </P>
  <DT><SPAN class=term><TT class=literal>hilo</TT></SPAN>
  <DD>
  <P>uses a hi/lo algorithm to efficiently generate identifiers of type <TT 
  class=literal>long</TT>, <TT class=literal>short</TT> or <TT 
  class=literal>int</TT>, given a table and column (by default <TT 
  class=literal>hibernate_unique_key</TT> and <TT class=literal>next</TT> 
  respectively) as a source of hi values. The hi/lo algorithm generates 
  identifiers that are unique only for a particular database. <SPAN 
  class=emphasis><EM>Do not use this generator with connections enlisted with 
  JTA or with a user-supplied connection.</EM></SPAN> </P>
  <DT><SPAN class=term><TT class=literal>seqhilo</TT></SPAN>
  <DD>
  <P>uses a hi/lo algorithm to efficiently generate identifiers of type <TT 
  class=literal>long</TT>, <TT class=literal>short</TT> or <TT 
  class=literal>int</TT>, given a named database sequence. </P>
  <DT><SPAN class=term><TT class=literal>uuid.hex</TT></SPAN>
  <DD>
  <P>uses a 128-bit UUID algorithm to generate identifiers of type string, 
  unique within a network (the IP address is used). The UUID is encoded as a 
  string of hexadecimal digits of length 32. </P>
  <DT><SPAN class=term><TT class=literal>uuid.string</TT></SPAN>
  <DD>
  <P>uses the same UUID algorithm. The UUID is encoded a string of length 16 
  consisting of (any) ASCII characters. <SPAN class=emphasis><EM>Do not use with 
  PostgreSQL.</EM></SPAN> </P>
  <DT><SPAN class=term><TT class=literal>native</TT></SPAN>
  <DD>
  <P>picks <TT class=literal>identity</TT>, <TT class=literal>sequence</TT> or 
  <TT class=literal>hilo</TT> depending upon the capabilities of the underlying 
  database. </P>
  <DT><SPAN class=term><TT class=literal>assigned</TT></SPAN>
  <DD>
  <P>lets the application to assign an identifier to the object before <TT 
  class=literal>save()</TT> is called. </P>
  <DT><SPAN class=term><TT class=literal>foreign</TT></SPAN>
  <DD>
  <P>uses the identifier of another associated object. Usually used in 
  conjunction with a <TT class=literal>&lt;one-to-one&gt;</TT> primary key 
  association. </P></DD></DL></DIV>
<P></P></DIV>
<DIV class=sect3 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=mapping-declaration-id-hilo></A>5.1.4.2.&nbsp;Hi/Lo 
Algorithm</H4></DIV></DIV>
<DIV></DIV></DIV>
<P>The <TT class=literal>hilo</TT> and <TT class=literal>seqhilo</TT> generators 
provide two alternate implementations of the hi/lo algorithm, a favorite 
approach to identifier generation. The first implementation requires a "special" 
database table to hold the next available "hi" value. The second uses an 
Oracle-style sequence (where supported). </P><PRE class=programlisting>&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="hilo"&gt;
                &lt;param name="table"&gt;hi_value&lt;/param&gt;
                &lt;param name="column"&gt;next_value&lt;/param&gt;
                &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</PRE><PRE class=programlisting>&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="seqhilo"&gt;
                &lt;param name="sequence"&gt;hi_value&lt;/param&gt;
                &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</PRE>
<P>Unfortunately, you can't use <TT class=literal>hilo</TT> when supplying your 
own <TT class=literal>Connection</TT> to Hibernate, or when Hibernate is using 
an application server datasource to obtain connections enlisted with JTA. 
Hibernate must be able to fetch the "hi" value in a new transaction. A standard 
approach in an EJB environment is to implement the hi/lo algorithm using a 
stateless session bean. </P></DIV>
<DIV class=sect3 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=mapping-declaration-id-uuid></A>5.1.4.3.&nbsp;UUID 
Algorithm</H4></DIV></DIV>
<DIV></DIV></DIV>
<P>The UUIDs contain: IP address, startup time of the JVM (accurate to a quarter 
second), system time and a counter value (unique within the JVM). It's not 
possible to obtain a MAC address or memory address from Java code, so this is 
the best we can do without using JNI. </P>
<P>Don't try to use <TT class=literal>uuid.string</TT> in PostgreSQL. </P></DIV>
<DIV class=sect3 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A 
name=mapping-declaration-id-sequences></A>5.1.4.4.&nbsp;Identity columns and 
Sequences</H4></DIV></DIV>
<DIV></DIV></DIV>
<P>For databases which support identity columns (DB2, MySQL, Sybase, MS SQL), 
you may use <TT class=literal>identity</TT> key generation. For databases that 
support sequences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) you may 
use <TT class=literal>sequence</TT> style key generation. Both these strategies 
require two SQL queries to insert a new object. </P><PRE class=programlisting>&lt;id name="id" type="long" column="uid"&gt;
        &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;uid_sequence&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</PRE><PRE class=programlisting>&lt;id name="id" type="long" column="uid" unsaved-value="0"&gt;
        &lt;generator class="identity"/&gt;
&lt;/id&gt;</PRE>
<P>For cross-platform development, the <TT class=literal>native</TT> strategy 
will choose from the <TT class=literal>identity</TT>, <TT 
class=literal>sequence</TT> and <TT class=literal>hilo</TT> strategies, 
dependant upon the capabilities of the underlying database. </P></DIV>
<DIV class=sect3 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A 
name=mapping-declaration-id-assigned></A>5.1.4.5.&nbsp;Assigned 
Identifiers</H4></DIV></DIV>
<DIV></DIV></DIV>
<P>If you want the application to assign identifiers (as opposed to having 
Hibernate generate them), you may use the <TT class=literal>assigned</TT> 
generator. This special generator will use the identifier value already assigned 
to the object's identifier property. Be very careful when using this feature to 
assign keys with business meaning (almost always a terrible design decision). 
</P>
<P>Due to its inherent nature, entities that use this generator cannot be saved 
via the Session's saveOrUpdate() method. Instead you have to explicitly specify 
to Hibernate if the object should be saved or updated by calling either the <TT 
class=literal>save()</TT> or <TT class=literal>update()</TT> method of the 
Session. </P></DIV></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=mapping-declaration-compositeid></A>5.1.5.&nbsp;composite-id</H3></DIV></DIV>
<DIV></DIV></DIV><PRE class=programlisting>&lt;composite-id
        name="propertyName"
        class="ClassName"
        unsaved-value="any|none"
        access="field|property|ClassName"&gt;

        &lt;key-property name="propertyName" type="typename" column="column_name"/&gt;
        &lt;key-many-to-one name="propertyName class="ClassName" column="column_name"/&gt;
        ......
&lt;/composite-id&gt;</PRE>
<P>For a table with a composite key, you may map multiple properties of the 
class as identifier properties. The <TT class=literal>&lt;composite-id&gt;</TT> 
element accepts <TT class=literal>&lt;key-property&gt;</TT> property mappings 
and <TT class=literal>&lt;key-many-to-one&gt;</TT> mappings as child elements. 
</P><PRE class=programlisting>&lt;composite-id&gt;
        &lt;key-property name="medicareNumber"/&gt;
        &lt;key-property name="dependent"/&gt;
&lt;/composite-id&gt;</PRE>
<P>Your persistent class <SPAN class=emphasis><EM>must</EM></SPAN> override <TT 
class=literal>equals()</TT> and <TT class=literal>hashCode()</TT> to implement 
composite identifier equality. It must also implements <TT 
class=literal>Serializable</TT>. </P>
<P>Unfortunately, this approach to composite identifiers means that a persistent 
object is its own identifier. There is no convenient "handle" other than the 
object itself. You must instantiate an instance of the persistent class itself 
and populate its identifier properties before you can <TT 
class=literal>load()</TT> the persistent state associated with a composite key. 
We will describe a much more convenient approach where the composite identifier 
is implemented as a seperate class in <A 
title="7.4.&nbsp;Components as composite identifiers" 
href="http://www.hibernate.org/hib_docs/reference/en/html_single/#components-compositeid">Section&nbsp;7.4, 
“Components as composite identifiers”</A>. The attributes described below apply 
only to this alternative approach: </P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P><TT class=literal>name</TT> (optional): A property of component type that 
  holds the composite identifier (see next section). </P>
  <LI>
  <P><TT class=literal>class</TT> (optional - defaults to the property type 
  determined by reflection): The component class used as a composite identifier 
  (see next section). </P>
  <LI>
  <P><TT class=literal>unsaved-value</TT> (optional - defaults to <TT 
  class=literal>none</TT>): Indicates that transient instances should be 
  considered newly instantiated, if set to <TT class=literal>any</TT>. 
</P></LI></UL></DIV></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=mapping-declaration-discriminator></A>5.1.6.&nbsp;discriminator</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>The <TT class=literal>&lt;discriminator&gt;</TT> element is required for 
polymorphic persistence using the table-per-class-hierarchy mapping strategy and 
declares a discriminator column of the table. The discriminator column contains 
marker values that tell the persistence layer what subclass to instantiate for a 
particular row. A restricted set of types may be used: <TT 
class=literal>string</TT>, <TT class=literal>character</TT>, <TT 
class=literal>integer</TT>, <TT class=literal>byte</TT>, <TT 
class=literal>short</TT>, <TT class=literal>boolean</TT>, <TT 
class=literal>yes_no</TT>, <TT class=literal>true_false</TT>. </P>
<DIV class=programlistingco><PRE class=programlisting>&lt;discriminator
        column="discriminator_column"  <SPAN class=co>(1)</SPAN>
        type="discriminator_type"      <SPAN class=co>(2)</SPAN>
        force="true|false"             <SPAN class=co>(3)</SPAN>
/&gt;</PRE>
<DIV class=calloutlist>
<TABLE summary="Callout list" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="5%">(1)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>column</TT> (optional - defaults to <TT 
      class=literal>class</TT>) the name of the discriminator column. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(2)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>type</TT> (optional - defaults to <TT 
      class=literal>string</TT>) a name that indicates the Hibernate type 
  </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(3)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>force</TT> (optional - defaults to <TT 
      class=literal>false</TT>) "force" Hibernate to specify allowed 
      discriminator values even when retrieving all instances of the root class. 
      </P></TD></TR></TBODY></TABLE></DIV></DIV>
<P>Actual values of the discriminator column are specified by the <TT 
class=literal>discriminator-value</TT> attribute of the <TT 
class=literal>&lt;class&gt;</TT> and <TT class=literal>&lt;subclass&gt;</TT> 
elements. </P>
<P>The <TT class=literal>force</TT> attribute is (only) useful if the table 
contains rows with "extra" discriminator values that are not mapped to a 
persistent class. This will not usually be the case. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=mapping-declaration-version></A>5.1.7.&nbsp;version 
(optional)</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>The <TT class=literal>&lt;version&gt;</TT> element is optional and indicates 
that the table contains versioned data. This is particularly useful if you plan 
to use <SPAN class=emphasis><EM>long transactions</EM></SPAN> (see below). </P>
<DIV class=programlistingco><PRE class=programlisting>&lt;version
        column="version_column"                            <SPAN class=co>(1)</SPAN>
        name="propertyName"                                <SPAN class=co>(2)</SPAN>
        type="typename"                                    <SPAN class=co>(3)</SPAN>
        access="field|property|ClassName"                  <SPAN class=co>(4)</SPAN>
        unsaved-value="null|negative|undefined"            <SPAN class=co>(5)</SPAN>
/&gt;</PRE>
<DIV class=calloutlist>
<TABLE summary="Callout list" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="5%">(1)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>column</TT> (optional - defaults to the property 
      name): The name of the column holding the version number. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(2)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>name</TT>: The name of a property of the persistent 
      class. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(3)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>type</TT> (optional - defaults to <TT 
      class=literal>integer</TT>): The type of the version number. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(4)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>access</TT> (optional - defaults to <TT 
      class=literal>property</TT>): The strategy Hibernate should use for 
      accessing the property value. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(5)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>unsaved-value</TT> (optional - defaults to <TT 
      class=literal>undefined</TT>): A version property value that indicates 
      that an instance is newly instantiated (unsaved), distinguishing it from 
      transient instances that were saved or loaded in a previous session. (<TT 
      class=literal>undefined</TT> specifies that the identifier property value 
      should be used.) </P></TD></TR></TBODY></TABLE></DIV></DIV>
<P>Version numbers may be of type <TT class=literal>long</TT>, <TT 
class=literal>integer</TT>, <TT class=literal>short</TT>, <TT 
class=literal>timestamp</TT> or <TT class=literal>calendar</TT>. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=mapping-declaration-timestamp></A>5.1.8.&nbsp;timestamp 
(optional)</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>The optional <TT class=literal>&lt;timestamp&gt;</TT> element indicates that 
the table contains timestamped data. This is intended as an alternative to 
versioning. Timestamps are by nature a less safe implementation of optimistic 
locking. However, sometimes the application might use the timestamps in other 
ways. </P>
<DIV class=programlistingco><PRE class=programlisting>&lt;timestamp
        column="timestamp_column"           <SPAN class=co>(1)</SPAN>
        name="propertyName"                 <SPAN class=co>(2)</SPAN>
        access="field|property|ClassName"   <SPAN class=co>(3)</SPAN>
        unsaved-value="null|undefined"      <SPAN class=co>(4)</SPAN>
/&gt;</PRE>
<DIV class=calloutlist>
<TABLE summary="Callout list" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="5%">(1)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>column</TT> (optional - defaults to the property 
      name): The name of a column holding the timestamp. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(2)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>name</TT>: The name of a JavaBeans style property of 
      Java type <TT class=literal>Date</TT> or <TT class=literal>Timestamp</TT> 
      of the persistent class. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(3)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>access</TT> (optional - defaults to <TT 
      class=literal>property</TT>): The strategy Hibernate should use for 
      accessing the property value. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(4)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>unsaved-value</TT> (optional - defaults to <TT 
      class=literal>null</TT>): A version property value that indicates that an 
      instance is newly instantiated (unsaved), distinguishing it from transient 
      instances that were saved or loaded in a previous session. (<TT 
      class=literal>undefined</TT> specifies that the identifier property value 
      should be used.) </P></TD></TR></TBODY></TABLE></DIV></DIV>
<P>Note that <TT class=literal>&lt;timestamp&gt;</TT> is equivalent to <TT 
class=literal>&lt;version type="timestamp"&gt;</TT>. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=mapping-declaration-property></A>5.1.9.&nbsp;property</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>The <TT class=literal>&lt;property&gt;</TT> element declares a persistent, 
JavaBean style property of the class. </P>
<DIV class=programlistingco><PRE class=programlisting>&lt;property
        name="propertyName"                 <SPAN class=co>(1)</SPAN>
        column="column_name"                <SPAN class=co>(2)</SPAN>
        type="typename"                     <SPAN class=co>(3)</SPAN>
        update="true|false"                 <SPAN class=co>(4)</SPAN>
        insert="true|false"                 <SPAN class=co>(4)</SPAN>
        formula="arbitrary SQL expression"  <SPAN class=co>(5)</SPAN>
        access="field|property|ClassName"   <SPAN class=co>(6)</SPAN>
/&gt;</PRE>
<DIV class=calloutlist>
<TABLE summary="Callout list" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="5%">(1)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>name</TT>: the name of the property, with an initial 
      lowercase letter. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(2)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>column</TT> (optional - defaults to the property 
      name): the name of the mapped database table column. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(3)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>type</TT> (optional): a name that indicates the 
      Hibernate type. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(4)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>update, insert</TT> (optional - defaults to <TT 
      class=literal>true</TT>) : specifies that the mapped columns should be 
      included in SQL <TT class=literal>UPDATE</TT> and/or <TT 
      class=literal>INSERT</TT> statements. Setting both to <TT 
      class=literal>false</TT> allows a pure "derived" property whose value is 
      initialized from some other property that maps to the same colum(s) or by 
      a trigger or other application. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(5)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>formula</TT> (optional): an SQL expression that 
      defines the value for a <SPAN class=emphasis><EM>computed</EM></SPAN> 
      property. Computed properties do not have a column mapping of their own. 
      </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(6)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>access</TT> (optional - defaults to <TT 
      class=literal>property</TT>): The strategy Hibernate should use for 
      accessing the property value. </P></TD></TR></TBODY></TABLE></DIV></DIV>
<P><SPAN class=emphasis><EM>typename</EM></SPAN> could be: </P>
<DIV class=orderedlist>
<OL type=1 compact>
  <LI>
  <P>The name of a Hibernate basic type (eg. <TT class=literal>integer, string, 
  character, date, timestamp, float, binary, serializable, object, blob</TT>). 
  </P>
  <LI>
  <P>The name of a Java class with a default basic type (eg. <TT 
  class=literal>int, float, char, java.lang.String, java.util.Date, 
  java.lang.Integer, java.sql.Clob</TT>). </P>
  <LI>
  <P>The name of a subclass of <TT class=literal>PersistentEnum</TT> (eg. <TT 
  class=literal>eg.Color</TT>). </P>
  <LI>
  <P>The name of a serializable Java class. </P>
  <LI>
  <P>The class name of a custom type (eg. <TT 
  class=literal>com.illflow.type.MyCustomType</TT>). </P></LI></OL></DIV>
<P>If you do not specify a type, Hibernate will use reflection upon the named 
property to take a guess at the correct Hibernate type. Hibernate will try to 
interpret the name of the return class of the property getter using rules 2, 3, 
4 in that order. However, this is not always enough. In certain cases you will 
still need the <TT class=literal>type</TT> attribute. (For example, to 
distinguish between <TT class=literal>Hibernate.DATE</TT> and <TT 
class=literal>Hibernate.TIMESTAMP</TT>, or to specify a custom type.) </P>
<P>The <TT class=literal>access</TT> attribute lets you control how Hibernate 
will access the property at runtime. By default, Hibernate will call the 
property get/set pair. If you specify <TT class=literal>access="field"</TT>, 
Hibernate will bypass the get/set pair and access the field directly, using 
reflection. You may specify your own strategy for property access by naming a 
class that implements the interface <TT 
class=literal>net.sf.hibernate.property.PropertyAccessor</TT>. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=mapping-declaration-manytoone></A>5.1.10.&nbsp;many-to-one</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>An ordinary association to another persistent class is declared using a <TT 
class=literal>many-to-one</TT> element. The relational model is a many-to-one 
association. (Its really just an object reference.) </P>
<DIV class=programlistingco><PRE class=programlisting>&lt;many-to-one
        name="propertyName"                                <SPAN class=co>(1)</SPAN>
        column="column_name"                               <SPAN class=co>(2)</SPAN>
        class="ClassName"                                  <SPAN class=co>(3)</SPAN>
        cascade="all|none|save-update|delete"              <SPAN class=co>(4)</SPAN>
        outer-join="true|false|auto"                       <SPAN class=co>(5)</SPAN>
        update="true|false"                                <SPAN class=co>(6)</SPAN>
        insert="true|false"                                <SPAN class=co>(6)</SPAN>
        property-ref="propertyNameFromAssociatedClass"     <SPAN class=co>(7)</SPAN>
        access="field|property|ClassName"                  <SPAN class=co>(8)</SPAN>
/&gt;</PRE>
<DIV class=calloutlist>
<TABLE summary="Callout list" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="5%">(1)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>name</TT>: The name of the property. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(2)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>column</TT> (optional): The name of the column. 
    </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(3)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>class</TT> (optional - defaults to the property type 
      determined by reflection): The name of the associated class. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(4)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>cascade</TT> (optional): Specifies which operations 
      should be cascaded from the parent object to the associated object. 
  </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(5)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>outer-join</TT> (optional - defaults to <TT 
      class=literal>auto</TT>): enables outer-join fetching for this association 
      when <TT class=literal>hibernate.use_outer_join</TT> is set. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(6)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>update, insert</TT> (optional - defaults to <TT 
      class=literal>true</TT>) specifies that the mapped columns should be 
      included in SQL <TT class=literal>UPDATE</TT> and/or <TT 
      class=literal>INSERT</TT> statements. Setting both to <TT 
      class=literal>false</TT> allows a pure "derived" association whose value 
      is initialized from some other property that maps to the same colum(s) or 
      by a trigger or other application. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(7)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>property-ref</TT>: (optional) The name of a property 
      of the associated class that is joined to this foreign key. If not 
      specified, the primary key of the associated class is used. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(8)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>access</TT> (optional - defaults to <TT 
      class=literal>property</TT>): The strategy Hibernate should use for 
      accessing the property value. </P></TD></TR></TBODY></TABLE></DIV></DIV>
<P>The <TT class=literal>cascade</TT> attribute permits the following values: 
<TT class=literal>all</TT>, <TT class=literal>save-update</TT>, <TT 
class=literal>delete</TT>, <TT class=literal>none</TT>. Setting a value other 
than <TT class=literal>none</TT> will propagate certain operations to the 
associated (child) object. See "Lifecycle Objects" below. </P>
<P>The <TT class=literal>outer-join</TT> attribute accepts three different 
values: </P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P><TT class=literal>auto</TT> (default) Fetch the association using an 
  outerjoin if the associated class has no proxy </P>
  <LI>
  <P><TT class=literal>true</TT> Always fetch the association using an outerjoin 
  </P>
  <LI>
  <P><TT class=literal>false</TT> Never fetch the association using an outerjoin 
  </P></LI></UL></DIV>
<P>A typical <TT class=literal>many-to-one</TT> declaration looks as simple as 
</P><PRE class=programlisting>&lt;many-to-one name="product" class="Product" column="PRODUCT_ID"/&gt;</PRE>
<P>The <TT class=literal>property-ref</TT> attribute should only be used for 
mapping legacy data where a foreign key refers to a unique key of the associated 
table other than the primary key. This is an ugly relational model. For example, 
suppose the <TT class=literal>Product</TT> class had a unique serial number, 
that is not the primary key. (The <TT class=literal>unique</TT> attribute 
controls Hibernate's DDL generation with the SchemaExport tool.) </P><PRE class=programlisting>&lt;property name="serialNumber" unique="true" type="string" column="SERIAL_NUMBER"/&gt;</PRE>
<P>Then the mapping for <TT class=literal>OrderItem</TT> might use: </P><PRE class=programlisting>&lt;many-to-one name="product" property-ref="serialNumber" column="PRODUCT_SERIAL_NUMBER"/&gt;</PRE>
<P>This is certainly not encouraged, however. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=mapping-declaration-onetoone></A>5.1.11.&nbsp;one-to-one</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>A one-to-one association to another persistent class is declared using a <TT 
class=literal>one-to-one</TT> element. </P>
<DIV class=programlistingco><PRE class=programlisting>&lt;one-to-one
        name="propertyName"                                <SPAN class=co>(1)</SPAN>
        class="ClassName"                                  <SPAN class=co>(2)</SPAN>
        cascade="all|none|save-update|delete"              <SPAN class=co>(3)</SPAN>
        constrained="true|false"                           <SPAN class=co>(4)</SPAN>
        outer-join="true|false|auto"                       <SPAN class=co>(5)</SPAN>
        property-ref="propertyNameFromAssociatedClass"     <SPAN class=co>(6)</SPAN>
        access="field|property|ClassName"                  <SPAN class=co>(7)</SPAN>
/&gt;</PRE>
<DIV class=calloutlist>
<TABLE summary="Callout list" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="5%">(1)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>name</TT>: The name of the property. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(2)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>class</TT> (optional - defaults to the property type 
      determined by reflection): The name of the associated class. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(3)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>cascade</TT> (optional) specifies which operations 
      should be cascaded from the parent object to the associated object. 
  </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(4)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>constrained</TT> (optional) specifies that a foreign 
      key constraint on the primary key of the mapped table references the table 
      of the associated class. This option affects the order in which <TT 
      class=literal>save()</TT> and <TT class=literal>delete()</TT> are cascaded 
      (and is also used by the schema export tool). </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(5)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>outer-join</TT> (optional - defaults to <TT 
      class=literal>auto</TT>): Enable outer-join fetching for this association 
      when <TT class=literal>hibernate.use_outer_join</TT> is set. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(6)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>property-ref</TT>: (optional) The name of a property 
      of the associated class that is joined to the primary key of this class. 
      If not specified, the primary key of the associated class is used. 
  </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(7)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>access</TT> (optional - defaults to <TT 
      class=literal>property</TT>): The strategy Hibernate should use for 
      accessing the property value. </P></TD></TR></TBODY></TABLE></DIV></DIV>
<P>There are two varieties of one-to-one association: </P>
<DIV class=itemizedlist>
<UL type=disc>
  <LI>
  <P>primary key associations </P>
  <LI>
  <P>unique foreign key associations </P></LI></UL></DIV>
<P>Primary key associations don't need an extra table column; if two rows are 
related by the association then the two table rows share the same primary key 
value. So if you want two objects to be related by a primary key association, 
you must make sure that they are assigned the same identifier value! </P>
<P>For a primary key association, add the following mappings to <TT 
class=literal>Employee</TT> and <TT class=literal>Person</TT>, respectively. 
</P><PRE class=programlisting>&lt;one-to-one name="person" class="Person"/&gt;</PRE><PRE class=programlisting>&lt;one-to-one name="employee" class="Employee" constrained="true"/&gt;</PRE>
<P>Now we must ensure that the primary keys of related rows in the PERSON and 
EMPLOYEE tables are equal. We use a special Hibernate identifier generation 
strategy called <TT class=literal>foreign</TT>: </P><PRE class=programlisting>&lt;class name="person" table="PERSON"&gt;
    &lt;id name="id" column="PERSON_ID"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;employee&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    ...
    &lt;one-to-one name="employee"
        class="Employee"
        constrained="true"/&gt;
&lt;/class&gt;</PRE>
<P>A newly saved instance of <TT class=literal>Person</TT> is then assigned the 
same primar key value as the <TT class=literal>Employee</TT> instance refered 
with the <TT class=literal>employee</TT> property of that <TT 
class=literal>Person</TT>. </P>
<P>Alternatively, a foreign key with a unique constraint, from <TT 
class=literal>Employee</TT> to <TT class=literal>Person</TT>, may be expressed 
as: </P><PRE class=programlisting>&lt;many-to-one name="person" class="Person" column="PERSON_ID" unique="true"/&gt;</PRE>
<P>And this association may be made bidirectional by adding the following to the 
<TT class=literal>Person</TT> mapping: </P><PRE class=programlisting>&lt;one-to-one name"employee" class="Employee" property-ref="person"/&gt;</PRE></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=mapping-declaration-component></A>5.1.12.&nbsp;component, 
dynamic-component</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>The <TT class=literal>&lt;component&gt;</TT> element maps properties of a 
child object to columns of the table of a parent class. Components may, in turn, 
declare their own properties, components or collections. See "Components" below. 
</P>
<DIV class=programlistingco><PRE class=programlisting>&lt;component 
        name="propertyName"                 <SPAN class=co>(1)</SPAN>
        class="className"                   <SPAN class=co>(2)</SPAN>
        insert="true|false"                 <SPAN class=co>(3)</SPAN>
        upate="true|false"                  <SPAN class=co>(4)</SPAN>
        access="field|property|ClassName"&gt;  <SPAN class=co>(5)</SPAN>
        
        &lt;property ...../&gt;
        &lt;many-to-one .... /&gt;
        ........
&lt;/component&gt;</PRE>
<DIV class=calloutlist>
<TABLE summary="Callout list" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="5%">(1)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>name</TT>: The name of the property. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(2)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>class</TT> (optional - defaults to the property type 
      determined by reflection): The name of the component (child) class. 
  </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(3)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>insert</TT>: Do the mapped columns appear in SQL <TT 
      class=literal>INSERT</TT>s? </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(4)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>update</TT>: Do the mapped columns appear in SQL <TT 
      class=literal>UPDATE</TT>s? </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(5)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>access</TT> (optional - defaults to <TT 
      class=literal>property</TT>): The strategy Hibernate should use for 
      accessing the property value. </P></TD></TR></TBODY></TABLE></DIV></DIV>
<P>The child <TT class=literal>&lt;property&gt;</TT> tags map properties of the 
child class to table columns. </P>
<P>The <TT class=literal>&lt;component&gt;</TT> element allows a <TT 
class=literal>&lt;parent&gt;</TT> subelement that maps a property of the 
component class as a reference back to the containing entity. </P>
<P>The <TT class=literal>&lt;dynamic-component&gt;</TT> element allows a <TT 
class=literal>Map</TT> to be mapped as a component, where the property names 
refer to keys of the map. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=mapping-declaration-subclass></A>5.1.13.&nbsp;subclass</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>Finally, polymorphic persistence requires the declaration of each subclass of 
the root persistent class. For the (recommended) table-per-class-hierarchy 
mapping strategy, the <TT class=literal>&lt;subclass&gt;</TT> declaration is 
used. </P>
<DIV class=programlistingco><PRE class=programlisting>&lt;subclass
        name="ClassName"                              <SPAN class=co>(1)</SPAN>
        discriminator-value="discriminator_value"     <SPAN class=co>(2)</SPAN>
        proxy="ProxyInterface"                        <SPAN class=co>(3)</SPAN>
        lazy="true|false"                             <SPAN class=co>(4)</SPAN>
        dynamic-update="true|false"
        dynamic-insert="true|false"&gt;

        &lt;property .... /&gt;
        .....
&lt;/subclass&gt;</PRE>
<DIV class=calloutlist>
<TABLE summary="Callout list" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="5%">(1)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>name</TT>: The fully qualified class name of the 
      subclass. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(2)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>discriminator-value</TT> (optional - defaults to the 
      class name): A value that distiguishes individual subclasses. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(3)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>proxy</TT> (optional): Specifies a class or interface 
      to use for lazy initializing proxies. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(4)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>lazy</TT> (optional): Setting <TT 
      class=literal>lazy="true"</TT> is a shortcut equalivalent to specifying 
      the name of the class itself as the <TT class=literal>proxy</TT> 
      interface. </P></TD></TR></TBODY></TABLE></DIV></DIV>
<P>Each subclass should declare its own persistent properties and subclasses. 
<TT class=literal>&lt;version&gt;</TT> and <TT class=literal>&lt;id&gt;</TT> 
properties are assumed to be inherited from the root class. Each subclass in a 
heirarchy must define a unique <TT class=literal>discriminator-value</TT>. If 
none is specified, the fully qualified Java class name is used. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=mapping-declaration-joinedsubclass></A>5.1.14.&nbsp;joined-subclass</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>Alternatively, a subclass that is persisted to its own table 
(table-per-subclass mapping strategy) is declared using a <TT 
class=literal>&lt;joined-subclass&gt;</TT> element. </P>
<DIV class=programlistingco><PRE class=programlisting>&lt;joined-subclass
        name="ClassName"                    <SPAN class=co>(1)</SPAN>
        proxy="ProxyInterface"              <SPAN class=co>(2)</SPAN>
        lazy="true|false"                   <SPAN class=co>(3)</SPAN>
        dynamic-update="true|false"
        dynamic-insert="true|false"&gt;

        &lt;key .... &gt;

        &lt;property .... /&gt;
        .....
&lt;/subclass&gt;</PRE>
<DIV class=calloutlist>
<TABLE summary="Callout list" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="5%">(1)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>name</TT>: The fully qualified class name of the 
      subclass. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(2)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>proxy</TT> (optional): Specifies a class or interface 
      to use for lazy initializing proxies. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(3)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>lazy</TT> (optional): Setting <TT 
      class=literal>lazy="true"</TT> is a shortcut equalivalent to specifying 
      the name of the class itself as the <TT class=literal>proxy</TT> 
      interface. </P></TD></TR></TBODY></TABLE></DIV></DIV>
<P>No discriminator column is required for this mapping strategy. Each subclass 
must, however, declare a table column holding the object identifier using the 
<TT class=literal>&lt;key&gt;</TT> element. The mapping at the start of the 
chapter would be re-written as: </P><PRE class=programlisting>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

        &lt;class name="Cat" table="CATS"&gt;
                &lt;id name="id" column="uid" type="long"&gt;
                        &lt;generator class="hilo"/&gt;
                &lt;/id&gt;
                &lt;property name="birthdate" type="date"/&gt;
                &lt;property name="color" not-null="true"/&gt;
                &lt;property name="sex" not-null="true"/&gt;
                &lt;property name="weight"/&gt;
                &lt;many-to-one name="mate"/&gt;
                &lt;set name="kittens"&gt;
                        &lt;key column="MOTHER"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;
                &lt;joined-subclass name="DomesticCat" table="DOMESTIC_CATS"&gt;
                	&lt;key column="CAT"/&gt;
                        &lt;property name="name" type="string"/&gt;
                &lt;/joined-subclass&gt;
        &lt;/class&gt;

        &lt;class name="eg.Dog"&gt;
                &lt;!-- mapping for Dog could go here --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping&gt;</PRE></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=mapping-declaration-collections></A>5.1.15.&nbsp;map, 
set, list, bag</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>Collections are discussed later. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=mapping-declaration-import></A>5.1.16.&nbsp;import</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>Suppose your application has two persistent classes with the same name, and 
you don't want to specify the fully qualified (package) name in Hibernate 
queries. Classes may be "imported" explicitly, rather than relying upon <TT 
class=literal>auto-import="true"</TT>. You may even import classes and 
interfaces that are not explicitly mapped. </P><PRE class=programlisting>&lt;import class="java.lang.Object" rename="Universe"/&gt;</PRE>
<DIV class=programlistingco><PRE class=programlisting>&lt;import
        class="ClassName"              <SPAN class=co>(1)</SPAN>
        rename="ShortName"             <SPAN class=co>(2)</SPAN>
/&gt;</PRE>
<DIV class=calloutlist>
<TABLE summary="Callout list" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="5%">(1)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>class</TT>: The fully qualified class name of of any 
      Java class. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(2)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>rename</TT> (optional - defaults to the unqualified 
      class name): A name that may be used in the query language. 
  </P></TD></TR></TBODY></TABLE></DIV></DIV></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=mapping-types></A>5.2.&nbsp;Hibernate Types</H2></DIV></DIV>
<DIV></DIV></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=mapping-types-entitiesvalues></A>5.2.1.&nbsp;Entities 
and values</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>To understand the behaviour of various Java language-level objects with 
respect to the persistence service, we need to classify them into two groups: 
</P>
<P>An <SPAN class=emphasis><EM>entity</EM></SPAN> exists independently of any 
other objects holding references to the entity. Contrast this with the usual 
Java model where an unreferenced object is garbage collected. Entities must be 
explicitly saved and deleted (except that saves and deletions may be <SPAN 
class=emphasis><EM>cascaded</EM></SPAN> from a parent entity to its children). 
This is different from the ODMG model of object persistence by reachablity - and 
corresponds more closely to how application objects are usually used in large 
systems. Entities support circular and shared references. They may also be 
versioned. </P>
<P>An entity's persistent state consists of references to other entities and 
instances of <SPAN class=emphasis><EM>value</EM></SPAN> types. Values are 
primitives, collections, components and certain immutable objects. Unlike 
entities, values (in particular collections and components) <SPAN 
class=emphasis><EM>are</EM></SPAN> persisted and deleted by reachability. Since 
value objects (and primitives) are persisted and deleted along with their 
containing entity they may not be independently versioned. Values have no 
independent identity, so they cannot be shared by two entities or collections. 
</P>
<P>All Hibernate types except collections support null semantics. </P>
<P>Up until now, we've been using the term "persistent class" to refer to 
entities. We will continue to do that. Strictly speaking, however, not all 
user-defined classes with persistent state are entities. A <SPAN 
class=emphasis><EM>component</EM></SPAN> is a user defined class with value 
semantics. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=mapping-types-basictypes></A>5.2.2.&nbsp;Basic value 
types</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>The <SPAN class=emphasis><EM>basic types</EM></SPAN> may be roughly 
categorized into </P>
<DIV class=variablelist>
<DL>
  <DT><SPAN class=term><TT class=literal>integer, long, short, float, double, 
  character, byte, boolean, yes_no, true_false</TT></SPAN>
  <DD>
  <P>Type mappings from Java primitives or wrapper classes to appropriate 
  (vendor-specific) SQL column types. <TT class=literal>boolean, yes_no</TT> and 
  <TT class=literal>true_false</TT> are all alternative encodings for a Java <TT 
  class=literal>boolean</TT> or <TT class=literal>java.lang.Boolean</TT>. </P>
  <DT><SPAN class=term><TT class=literal>string</TT></SPAN>
  <DD>
  <P>A type mapping from <TT class=literal>java.lang.String</TT> to <TT 
  class=literal>VARCHAR</TT> (or Oracle <TT class=literal>VARCHAR2</TT>). </P>
  <DT><SPAN class=term><TT class=literal>date, time, timestamp</TT></SPAN>
  <DD>
  <P>Type mappings from <TT class=literal>java.util.Date</TT> and its subclasses 
  to SQL types <TT class=literal>DATE</TT>, <TT class=literal>TIME</TT> and <TT 
  class=literal>TIMESTAMP</TT> (or equivalent). </P>
  <DT><SPAN class=term><TT class=literal>calendar, calendar_date</TT></SPAN>
  <DD>
  <P>Type mappings from <TT class=literal>java.util.Calendar</TT> to SQL types 
  <TT class=literal>TIMESTAMP</TT> and <TT class=literal>DATE</TT> (or 
  equivalent). </P>
  <DT><SPAN class=term><TT class=literal>big_decimal</TT></SPAN>
  <DD>
  <P>A type mapping from <TT class=literal>java.math.BigDecimal</TT> to <TT 
  class=literal>NUMERIC</TT> (or Oracle <TT class=literal>NUMBER</TT>). </P>
  <DT><SPAN class=term><TT class=literal>locale, timezone, currency</TT></SPAN>
  <DD>
  <P>Type mappings from <TT class=literal>java.util.Locale</TT>, <TT 
  class=literal>java.util.TimeZone</TT> and <TT 
  class=literal>java.util.Currency</TT> to <TT class=literal>VARCHAR</TT> (or 
  Oracle <TT class=literal>VARCHAR2</TT>). Instances of <TT 
  class=literal>Locale</TT> and <TT class=literal>Currency</TT> are mapped to 
  their ISO codes. Instances of <TT class=literal>TimeZone</TT> are mapped to 
  their <TT class=literal>ID</TT>. </P>
  <DT><SPAN class=term><TT class=literal>class</TT></SPAN>
  <DD>
  <P>A type mapping from <TT class=literal>java.lang.Class</TT> to <TT 
  class=literal>VARCHAR</TT> (or Oracle <TT class=literal>VARCHAR2</TT>). A <TT 
  class=literal>Class</TT> is mapped to its fully qualified name. </P>
  <DT><SPAN class=term><TT class=literal>binary</TT></SPAN>
  <DD>
  <P>Maps byte arrays to an appropriate SQL binary type. </P>
  <DT><SPAN class=term><TT class=literal>text</TT></SPAN>
  <DD>
  <P>Maps long Java strings to a SQL <TT class=literal>CLOB</TT> or <TT 
  class=literal>TEXT</TT> type. </P>
  <DT><SPAN class=term><TT class=literal>serializable</TT></SPAN>
  <DD>
  <P>Maps serializable Java types to an appropriate SQL binary type. You may 
  also indicate the Hibernate type <TT class=literal>serializable</TT> with the 
  name of a serializable Java class or interface that does not default to a 
  basic type or implement <TT class=literal>PersistentEnum</TT>. </P>
  <DT><SPAN class=term><TT class=literal>clob, blob</TT></SPAN>
  <DD>
  <P>Type mappings for the JDBC classes <TT class=literal>java.sql.Clob</TT> and 
  <TT class=literal>java.sql.Blob</TT>. These types may be inconvenient for some 
  applications, since the blob or clob object may not be reused outside of a 
  transaction. (Furthermore, driver support is patchy and inconsistent.) 
  </P></DD></DL></DIV>
<P></P>
<P>Unique identifiers of entities and collections may be of any basic type 
except <TT class=literal>binary</TT>, <TT class=literal>blob</TT> and <TT 
class=literal>clob</TT>. (Composite identifiers are also allowed, see below.) 
</P>
<P>The basic value types have corresponding <TT class=literal>Type</TT> 
constants defined on <TT class=literal>net.sf.hibernate.Hibernate</TT>. For 
example, <TT class=literal>Hibernate.STRING</TT> represents the <TT 
class=literal>string</TT> type. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=mapping-types-enum></A>5.2.3.&nbsp;Persistent enum 
types</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>An <SPAN class=emphasis><EM>enumerated</EM></SPAN> type is a common Java 
idiom where a class has a constant (small) number of immutable instances. You 
may create a persistent enumerated type by implementing <TT 
class=literal>net.sf.hibernate.PersistentEnum</TT>, defining the operations <TT 
class=literal>toInt()</TT> and <TT class=literal>fromInt()</TT>: </P><PRE class=programlisting>package eg;
import net.sf.hibernate.PersistentEnum;

public class Color implements PersistentEnum {
    private final int code;
    private Color(int code) {
        this.code = code;
    }
    public static final Color TABBY = new Color(0);
    public static final Color GINGER = new Color(1);
    public static final Color BLACK = new Color(2);

    public int toInt() { return code; }

    public static Color fromInt(int code) {
        switch (code) {
            case 0: return TABBY;
            case 1: return GINGER;
            case 2: return BLACK;
            default: throw new RuntimeException("Unknown color code");
        }
    }
}</PRE>
<P>The Hibernate type name is simply the name of the enumerated class, in this 
case <TT class=literal>eg.Color</TT>. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=mapping-types-custom></A>5.2.4.&nbsp;Custom value 
types</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>It is relatively easy for developers to create their own value types. For 
example, you might want to persist properties of type <TT 
class=literal>java.lang.BigInteger</TT> to <TT class=literal>VARCHAR</TT> 
columns. Hibernate does not provide a built-in type for this. But custom types 
are not limited to mapping a property (or collection element) to a single table 
column. So, for example, you might have a Java property <TT 
class=literal>getName()</TT>/<TT class=literal>setName()</TT> of type <TT 
class=literal>java.lang.String</TT> that is persisted to the columns <TT 
class=literal>FIRST_NAME</TT>, <TT class=literal>INITIAL</TT>, <TT 
class=literal>SURNAME</TT>. </P>
<P>To implement a custom type, implement either <TT 
class=literal>net.sf.hibernate.UserType</TT> or <TT 
class=literal>net.sf.hibernate.CompositeUserType</TT> and declare properties 
using the fully qualified classname of the type. Check out <TT 
class=literal>net.sf.hibernate.test.DoubleStringType</TT> to see the kind of 
things that are possible. </P><PRE class=programlisting>&lt;property name="twoStrings" type="net.sf.hibernate.test.DoubleStringType"&gt;
    &lt;column name="first_string"/&gt;
    &lt;column name="second_string"/&gt;
&lt;/property&gt;</PRE>
<P>Notice the use of <TT class=literal>&lt;column&gt;</TT> tags to map a 
property to multiple columns. </P>
<P>Even though Hibernate's rich range of built-in types and support for 
components means you will very rarely <SPAN class=emphasis><EM>need</EM></SPAN> 
to use a custom type, it is nevertheless considered good form to use custom 
types for (non-entity) classes that occur frequently in your application. For 
example, a <TT class=literal>MonetoryAmount</TT> class is a good candidate for a 
<TT class=literal>CompositeUserType</TT>, even though it could easily be mapped 
as a component. One motivation for this is abstraction. With a custom type, your 
mapping documents would be future-proofed against possible changes in your way 
of representing monetory values. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=mapping-types-anymapping></A>5.2.5.&nbsp;Any type 
mappings</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>There is one further type of property mapping. The <TT 
class=literal>&lt;any&gt;</TT> mapping element defines a polymorphic association 
to classes from multiple tables. This type of mapping always requires more than 
one column. The first column holds the type of the associated entity. The 
remaining columns hold the identifier. It is impossible to specify a foreign key 
constraint for this kind of association, so this is most certainly not meant as 
the usual way of mapping (polymorphic) associations. You should use this only in 
very special cases (eg. audit logs, user session data, etc). </P><PRE class=programlisting>&lt;any name="anyEntity" id-type="long" meta-type="eg.custom.Class2TablenameType"&gt;
    &lt;column name="table_name"/&gt;
    &lt;column name="id"/&gt;
&lt;/any&gt;</PRE>
<P>The <TT class=literal>meta-type</TT> attribute lets the application specify a 
custom type that maps database column values to persistent classes which have 
identifier properties of the type specified by <TT class=literal>id-type</TT>. 
If the meta-type returns instances of <TT class=literal>java.lang.Class</TT>, 
nothing else is required. On the other hand, if it is a basic type like <TT 
class=literal>string</TT> or <TT class=literal>character</TT>, you must specify 
the mapping from values to classes. </P><PRE class=programlisting>&lt;any name="anyEntity" id-type="long" meta-type="string"&gt;
    &lt;meta-value value="TBL_ANIMAL" class="Animal"/&gt;
    &lt;meta-value value="TBL_HUMAN" class="Human"/&gt;
    &lt;meta-value value="TBL_ALIEN" class="Alien"/&gt;
    &lt;column name="table_name"/&gt;
    &lt;column name="id"/&gt;
&lt;/any&gt;</PRE>
<DIV class=programlistingco><PRE class=programlisting>&lt;any
        name="propertyName"                      <SPAN class=co>(1)</SPAN>
        id-type="idtypename"                     <SPAN class=co>(2)</SPAN>
        meta-type="metatypename"                 <SPAN class=co>(3)</SPAN>
        cascade="none|all|save-update"           <SPAN class=co>(4)</SPAN>
        access="field|property|ClassName"        <SPAN class=co>(5)</SPAN>
&gt;
        &lt;meta-value ... /&gt;
        &lt;meta-value ... /&gt;
        .....
        &lt;column .... /&gt;
        &lt;column .... /&gt;
        .....
&lt;/any&gt;</PRE>
<DIV class=calloutlist>
<TABLE summary="Callout list" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="5%">(1)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>name</TT>: the property name. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(2)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>id-type</TT>: the identifier type. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(3)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>meta-type</TT> (optional - defaults to <TT 
      class=literal>class</TT>): a type that maps <TT 
      class=literal>java.lang.Class</TT> to a single database column or, 
      alternatively, a type that is allowed for a discriminator mapping. 
  </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(4)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>cascade</TT> (optional- defaults to <TT 
      class=literal>none</TT>): the cascade style. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(5)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>access</TT> (optional - defaults to <TT 
      class=literal>property</TT>): The strategy Hibernate should use for 
      accessing the property value. </P></TD></TR></TBODY></TABLE></DIV></DIV>
<P>The old <TT class=literal>object</TT> type that filled a similar role in 
Hibernate 1.2 is still supported, but is now semi-deprecated. </P></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=mapping-quotedidentifiers></A>5.3.&nbsp;SQL quoted 
identifiers</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>You may force Hibernate to quote an identifier in the generated SQL by 
enclosing the table or column name in backticks in the mapping document. 
Hibernate will use the correct quotation style for the SQL <TT 
class=literal>Dialect</TT> (usually double quotes, but brackets for SQL Server 
and backticks for MySQL). </P><PRE class=programlisting>&lt;class name="LineItem" table="`Line Item`"&gt;
    &lt;id name="id" column="`Item Id`"/&gt;&lt;generator class="assigned"/&gt;&lt;/id&gt;
    &lt;property name="itemNumber" column="`Item #`"/&gt;
    ...
&lt;/class&gt;</PRE></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=mapping-modularfiles></A>5.4.&nbsp;Modular mapping files</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>It is possible to define <TT class=literal>subclass</TT> and <TT 
class=literal>joined-subclass</TT> mappings in seperate mapping documents, 
directly beneath <TT class=literal>hibernate-mapping</TT>. This allows you to 
extend a class hierachy just by adding a new mapping file. You must specify an 
<TT class=literal>extends</TT> attribute in the subclass mapping, naming a 
previously mapped superclass. Use of this feature makes the ordering of the 
mapping documents important! </P><PRE class=programlisting>&lt;hibernate-mapping&gt;
        &lt;subclass name="eg.subclass.DomesticCat" extends="eg.Cat" discriminator-value="D"&gt;
             &lt;property name="name" type="string"/&gt;
        &lt;/subclass&gt;
&lt;/hibernate-mapping&gt;</PRE></DIV></DIV>
<DIV class=chapter lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A name=collections></A>Chapter&nbsp;6.&nbsp;Collection 
Mapping</H2></DIV></DIV>
<DIV></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=collections-persistent></A>6.1.&nbsp;Persistent 
Collections</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>This section does not contain much example Java code. We assume you already 
know how to use Java's collections framework. If so, there's not really anything 
more to know - with a single caveat, you may use Java collections the same way 
you always have. </P>
<P>Hibernate can persist instances of <TT class=literal>java.util.Map</TT>, <TT 
class=literal>java.util.Set</TT>, <TT class=literal>java.util.SortedMap</TT>, 
<TT class=literal>java.util.SortedSet</TT>, <TT 
class=literal>java.util.List</TT>, and any array of persistent entities or 
values. Properties of type <TT class=literal>java.util.Collection</TT> or <TT 
class=literal>java.util.List</TT> may also be persisted with "bag" semantics. 
</P>
<P>Now the caveat: persistent collections do not retain any extra semantics 
added by the class implementing the collection interface (eg. iteration order of 
a <TT class=literal>LinkedHashSet</TT>). The persistent collections actually 
behave like <TT class=literal>HashMap</TT>, <TT class=literal>HashSet</TT>, <TT 
class=literal>TreeMap</TT>, <TT class=literal>TreeSet</TT> and <TT 
class=literal>ArrayList</TT> respectively. Furthermore, the Java type of a 
property holding a collection must be the interface type (ie. <TT 
class=literal>Map</TT>, <TT class=literal>Set</TT> or <TT 
class=literal>List</TT>; never <TT class=literal>HashMap</TT>, <TT 
class=literal>TreeSet</TT> or <TT class=literal>ArrayList</TT>). This 
restriction exists because, when you're not looking, Hibernate sneakily replaces 
your instances of <TT class=literal>Map</TT>, <TT class=literal>Set</TT> and <TT 
class=literal>List</TT> with instances of its own persistent implementations of 
<TT class=literal>Map</TT>, <TT class=literal>Set</TT> or <TT 
class=literal>List</TT>. (So also be careful when using <TT 
class=literal>==</TT> on your collections.) </P><PRE class=programlisting>Cat cat = new DomesticCat();
Cat kitten = new DomesticCat();
....
Set kittens = new HashSet();
kittens.add(kitten);
cat.setKittens(kittens);
session.save(cat);
kittens = cat.getKittens(); //Okay, kittens collection is a Set
(HashSet) cat.getKittens(); //Error!</PRE>
<P>Collections obey the usual rules for value types: no shared references, 
created and deleted along with containing entity. Due to the underlying 
relational model, they do not support null value semantics; Hibernate does not 
distinguish between a null collection reference and an empty collection. </P>
<P>Collections are automatically persisted when referenced by a persistent 
object and automatically deleted when unreferenced. If a collection is passed 
from one persistent object to another, its elements might be moved from one 
table to another. You shouldn't have to worry much about any of this. Just use 
Hibernate's collections the same way you use ordinary Java collections, but make 
sure you understand the semantics of bidirectional associations (discussed 
later) before using them. </P>
<P>Collection instances are distinguished in the database by a foreign key to 
the owning entity. This foreign key is referred to as the <SPAN 
class=emphasis><EM>collection key </EM></SPAN>. The collection key is mapped by 
the <TT class=literal>&lt;key&gt;</TT> element. </P>
<P>Collections may contain almost any other Hibernate type, including all basic 
types, custom types, entity types and components. This is an important 
definition: An object in a collection can either be handled with "pass by value" 
semantics (it therefore fully depends on the collection owner) or it can be a 
reference to another entity with an own lifecycle. Collections may not contain 
other collections. The contained type is referred to as the <SPAN 
class=emphasis><EM>collection element type</EM></SPAN>. Collection elements are 
mapped by <TT class=literal>&lt;element&gt;</TT>, <TT 
class=literal>&lt;composite-element&gt;</TT>, <TT 
class=literal>&lt;one-to-many&gt;</TT>, <TT 
class=literal>&lt;many-to-many&gt;</TT> or <TT 
class=literal>&lt;many-to-any&gt;</TT>. The first two map elements with value 
semantics, the other three are used to map entity associations. </P>
<P>All collection types except <TT class=literal>Set</TT> and bag have an <SPAN 
class=emphasis><EM>index </EM></SPAN>column - a column that maps to an array or 
<TT class=literal>List</TT> index or <TT class=literal>Map</TT> key. The index 
of a <TT class=literal>Map</TT> may be of any basic type, an entity type or even 
a composite type (it may not be a collection). The index of an array or list is 
always of type <TT class=literal>integer</TT>. Indexes are mapped using <TT 
class=literal>&lt;index&gt;</TT>, <TT 
class=literal>&lt;index-many-to-many&gt;</TT>, <TT 
class=literal>&lt;composite-index&gt;</TT> or <TT 
class=literal>&lt;index-many-to-any&gt;</TT>. </P>
<P>There are quite a range of mappings that can be generated for collections, 
covering many common relational models. We suggest you experiment with the 
schema generation tool to get a feeling for how various mapping declarations 
translate to database tables. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=collections-mapping></A>6.2.&nbsp;Mapping a Collection</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Collections are declared by the <TT class=literal>&lt;set&gt;</TT>, <TT 
class=literal>&lt;list&gt;</TT>, <TT class=literal>&lt;map&gt;</TT>, <TT 
class=literal>&lt;bag&gt;</TT>, <TT class=literal>&lt;array&gt;</TT> and <TT 
class=literal>&lt;primitive-array&gt;</TT> elements. <TT 
class=literal>&lt;map&gt;</TT> is representative: </P>
<DIV class=programlistingco><PRE class=programlisting>&lt;map
    name="propertyName"                                         <SPAN class=co>(1)</SPAN>
    table="table_name"                                          <SPAN class=co>(2)</SPAN>
    schema="schema_name"                                        <SPAN class=co>(3)</SPAN>
    lazy="true|false"                                           <SPAN class=co>(4)</SPAN>
    inverse="true|false"                                        <SPAN class=co>(5)</SPAN>
    cascade="all|none|save-update|delete|all-delete-orphan"     <SPAN class=co>(6)</SPAN>
    sort="unsorted|natural|comparatorClass"                     <SPAN class=co>(7)</SPAN>
    order-by="column_name asc|desc"                             <SPAN class=co>(8)</SPAN>
    where="arbitrary sql where condition"                       <SPAN class=co>(9)</SPAN>
    outer-join="true|false|auto"                                <SPAN class=co>(10)</SPAN>
    batch-size="N"                                              <SPAN class=co>(11)</SPAN>
    access="field|property|ClassName"                           <SPAN class=co>(12)</SPAN>
&gt;

    &lt;key .... /&gt;
    &lt;index .... /&gt;
    &lt;element .... /&gt;
&lt;/map&gt;</PRE>
<DIV class=calloutlist>
<TABLE summary="Callout list" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="5%">(1)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>name</TT> the collection property name </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(2)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>table</TT> (optional - defaults to property name) the 
      name of the collection table (not used for one-to-many associations) 
    </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(3)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>schema</TT> (optional) the name of a table schema to 
      override the schema declared on the root element </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(4)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>lazy</TT> (optional - defaults to <TT 
      class=literal>false</TT>) enable lazy initialization (not used for arrays) 
      </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(5)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>inverse</TT> (optional - defaults to <TT 
      class=literal>false</TT>) mark this collection as the "inverse" end of a 
      bidirectional association </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(6)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>cascade</TT> (optional - defaults to <TT 
      class=literal>none</TT>) enable operations to cascade to child entities 
      </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(7)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>sort</TT> (optional) specify a sorted collection with 
      <TT class=literal>natural</TT> sort order, or a given comparator class 
    </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(8)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>order-by</TT> (optional, JDK1.4 only) specify a table 
      column (or columns) that define the iteration order of the <TT 
      class=literal>Map</TT>, <TT class=literal>Set</TT> or bag, together with 
      an optional <TT class=literal>asc</TT> or <TT class=literal>desc</TT> 
    </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(9)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>where</TT> (optional) specify an arbitrary SQL <TT 
      class=literal>WHERE</TT> condition to be used when retrieving or removing 
      the collection (useful if the collection should contain only a subset of 
      the available data) </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(10)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>outer-join</TT> (optional) specify that the 
      collection should be fetched by outer join, whenever possible. Only one 
      collection may be fetched by outer join per SQL <TT 
      class=literal>SELECT</TT>. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(11)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>batch-size</TT> (optional, defaults to <TT 
      class=literal>1</TT>) specify a "batch size" for lazily fetching instances 
      of this collection. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(12)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>access</TT> (optional - defaults to <TT 
      class=literal>property</TT>): The strategy Hibernate should use for 
      accessing the property value. </P></TD></TR></TBODY></TABLE></DIV></DIV>
<P>The mapping of a <TT class=literal>List</TT> or array requires a seperate 
table column holding the array or list index (the <TT class=literal>i</TT> in 
<TT class=literal>foo[i]</TT>). If your relational model doesn't have an index 
column, e.g. if you're working with legacy data, use an unordered <TT 
class=literal>Set</TT> instead. This seems to put people off who assume that <TT 
class=literal>List</TT> should just be a more convenient way of accessing an 
unordered collection. Hibernate collections strictly obey the actual semantics 
attached to the <TT class=literal>Set</TT>, <TT class=literal>List</TT> and <TT 
class=literal>Map</TT> interfaces. <TT class=literal>List</TT> elements don't 
just spontaneously rearrange themselves! </P>
<P>On the other hand, people who planned to use the <TT class=literal>List</TT> 
to emulate <SPAN class=emphasis><EM>bag</EM></SPAN> semantics have a legitimate 
grievance here. A bag is an unordered, unindexed collection which may contain 
the same element multiple times. The Java collections framework lacks a <TT 
class=literal>Bag</TT> interface, hence you have to emulate it with a <TT 
class=literal>List</TT>. Hibernate lets you map properties of type <TT 
class=literal>List</TT> or <TT class=literal>Collection</TT> with the <TT 
class=literal>&lt;bag&gt;</TT> element. Note that bag semantics are not really 
part of the <TT class=literal>Collection</TT> contract and they actually 
conflict with the semantics of the <TT class=literal>List</TT> contract 
(however, you can sort the bag arbitrarily, discussed later in this chapter). 
</P>
<P>Note: Large Hibernate bags mapped with <TT class=literal>inverse="false"</TT> 
are inefficient and should be avoided; Hibernate can't create, delete or update 
rows individually, because there is no key that may be used to identify an 
individual row. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=collections-ofvalues></A>6.3.&nbsp;Collections of Values and Many-To-Many 
Associations</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>A collection table is required for any collection of values and any 
collection of references to other entities mapped as a many-to-many association 
(the natural semantics for a Java collection). The table requires (foreign) key 
column(s), element column(s) and possibly index column(s). </P>
<P>The foreign key from the collection table to the table of the owning class is 
declared using a <TT class=literal>&lt;key&gt;</TT> element. </P>
<DIV class=programlistingco><PRE class=programlisting>&lt;key column="column_name"/&gt;</PRE>
<DIV class=calloutlist>
<TABLE summary="Callout list" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="5%">(1)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>column</TT> (required): The name of the foreign key 
      column. </P></TD></TR></TBODY></TABLE></DIV></DIV>
<P>For indexed collections like maps and lists, we require an <TT 
class=literal>&lt;index&gt;</TT> element. For lists, this column contains 
sequential integers numbered from zero. Make sure that your index really starts 
from zero if you have to deal with legacy data. For maps, the column may contain 
any values of any Hibernate type. </P>
<DIV class=programlistingco><PRE class=programlisting>&lt;index
        column="column_name"                <SPAN class=co>(1)</SPAN>
        type="typename"                     <SPAN class=co>(2)</SPAN>
/&gt;</PRE>
<DIV class=calloutlist>
<TABLE summary="Callout list" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="5%">(1)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>column</TT> (required): The name of the column 
      holding the collection index values. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(2)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>type</TT> (optional, defaults to <TT 
      class=literal>integer</TT>): The type of the collection index. 
  </P></TD></TR></TBODY></TABLE></DIV></DIV>
<P>Alternatively, a map may be indexed by objects of entity type. We use the <TT 
class=literal>&lt;index-many-to-many&gt;</TT> element. </P>
<DIV class=programlistingco><PRE class=programlisting>&lt;index-many-to-many
        column="column_name"                <SPAN class=co>(1)</SPAN>
        class="ClassName"                   <SPAN class=co>(2)</SPAN>
/&gt;</PRE>
<DIV class=calloutlist>
<TABLE summary="Callout list" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="5%">(1)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>column</TT> (required): The name of the foreign key 
      column for the collection index values. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(2)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>class</TT> (required): The entity class used as the 
      collection index. </P></TD></TR></TBODY></TABLE></DIV></DIV>
<P>For a collection of values, we use the <TT class=literal>&lt;element&gt;</TT> 
tag. </P>
<DIV class=programlistingco><PRE class=programlisting>&lt;element
        column="column_name"                <SPAN class=co>(1)</SPAN>
        type="typename"                     <SPAN class=co>(2)</SPAN>
/&gt;</PRE>
<DIV class=calloutlist>
<TABLE summary="Callout list" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="5%">(1)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>column</TT> (required): The name of the column 
      holding the collection element values. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(2)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>type</TT> (required): The type of the collection 
      element. </P></TD></TR></TBODY></TABLE></DIV></DIV>
<P>A collection of entities with its own table corresponds to the relational 
notion of <SPAN class=emphasis><EM>many-to-many association</EM></SPAN>. A many 
to many association is the most natural mapping of a Java collection but is not 
usually the best relational model. </P>
<DIV class=programlistingco><PRE class=programlisting>&lt;many-to-many
        column="column_name"                               <SPAN class=co>(1)</SPAN>
        class="ClassName"                                  <SPAN class=co>(2)</SPAN>
        outer-join="true|false|auto"                       <SPAN class=co>(3)</SPAN>
    /&gt;</PRE>
<DIV class=calloutlist>
<TABLE summary="Callout list" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="5%">(1)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>column</TT> (required): The name of the element 
      foreign key column. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(2)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>class</TT> (required): The name of the associated 
      class. </P></TD></TR>
  <TR>
    <TD vAlign=top align=left width="5%">(3)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>outer-join</TT> (optional - defaults to <TT 
      class=literal>auto</TT>): enables outer-join fetching for this association 
      when <TT class=literal>hibernate.use_outer_join</TT> is set. 
  </P></TD></TR></TBODY></TABLE></DIV></DIV>
<P>Some examples, first, a set of strings: </P><PRE class=programlisting>&lt;set name="names" table="NAMES"&gt;
    &lt;key column="GROUPID"/&gt;
    &lt;element column="NAME" type="string"/&gt;
&lt;/set&gt;</PRE>
<P>A bag containing integers (with an iteration order determined by the <TT 
class=literal>order-by</TT> attribute): </P><PRE class=programlisting>&lt;bag name="sizes" table="SIZES" order-by="SIZE ASC"&gt;
    &lt;key column="OWNER"/&gt;
    &lt;element column="SIZE" type="integer"/&gt;
&lt;/bag&gt;</PRE>
<P>An array of entities - in this case, a many to many association (note that 
the entities are lifecycle objects, <TT class=literal>cascade="all"</TT>): </P><PRE class=programlisting>&lt;array name="foos" table="BAR_FOOS" cascade="all"&gt;
    &lt;key column="BAR_ID"/&gt;
    &lt;index column="I"/&gt;
    &lt;many-to-many column="FOO_ID" class="org.hibernate.Foo"/&gt;
&lt;/array&gt;</PRE>
<P>A map from string indices to dates: </P><PRE class=programlisting>&lt;map name="holidays" table="holidays" schema="dbo" order-by="hol_name asc"&gt;
    &lt;key column="id"/&gt;
    &lt;index column="hol_name" type="string"/&gt;
    &lt;element column="hol_date" type="date"/&gt;
&lt;/map&gt;</PRE>
<P>A list of components (discussed in the next chapter): </P><PRE class=programlisting>&lt;list name="carComponents" table="car_components"&gt;
    &lt;key column="car_id"/&gt;
    &lt;index column="posn"/&gt;
    &lt;composite-element class="org.hibernate.car.CarComponent"&gt;
            &lt;property name="price" type="float"/&gt;
            &lt;property name="type" type="org.hibernate.car.ComponentType"/&gt;
            &lt;property name="serialNumber" column="serial_no" type="string"/&gt;
    &lt;/composite-element&gt;
&lt;/list&gt;</PRE></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=collections-onetomany></A>6.4.&nbsp;One-To-Many 
Associations</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>A <SPAN class=emphasis><EM>one to many association</EM></SPAN> links the 
tables of two classes <SPAN class=emphasis><EM>directly</EM></SPAN>, with no 
intervening collection table. (This implements a <SPAN 
class=emphasis><EM>one-to-many</EM></SPAN> relational model.) This relational 
model loses some of the semantics of Java collections: </P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P>No null values may be contained in a map, set or list </P>
  <LI>
  <P>An instance of the contained entity class may not belong to more than one 
  instance of the collection </P>
  <LI>
  <P>An instance of the contained entity class may not appear at more than one 
  value of the collection index </P></LI></UL></DIV>
<P>An association from <TT class=literal>Foo</TT> to <TT class=literal>Bar</TT> 
requires the addition of a key column and possibly an index column to the table 
of the contained entity class, <TT class=literal>Bar</TT>. These columns are 
mapped using the <TT class=literal>&lt;key&gt;</TT> and <TT 
class=literal>&lt;index&gt;</TT> elements described above. </P>
<P>The <TT class=literal>&lt;one-to-many&gt;</TT> tag indicates a one to many 
association. </P>
<DIV class=programlistingco><PRE class=programlisting>&lt;one-to-many class="ClassName"/&gt;</PRE>
<DIV class=calloutlist>
<TABLE summary="Callout list" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="5%">(1)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>class</TT> (required): The name of the associated 
      class. </P></TD></TR></TBODY></TABLE></DIV></DIV>
<P>Example: </P><PRE class=programlisting>&lt;set name="bars"&gt;
    &lt;key column="foo_id"/&gt;
    &lt;one-to-many class="org.hibernate.Bar"/&gt;
&lt;/set&gt;</PRE>
<P>Notice that the <TT class=literal>&lt;one-to-many&gt;</TT> element does not 
need to declare any columns. Nor is it necessary to specify the <TT 
class=literal>table</TT> name anywhere. </P>
<P><SPAN class=emphasis><EM>Very Important Note:</EM></SPAN> If the <TT 
class=literal>&lt;key&gt;</TT> column of a <TT 
class=literal>&lt;one-to-many&gt;</TT> association is declared <TT 
class=literal>NOT NULL</TT>, Hibernate may cause constraint violations when it 
creates or updates the association. To prevent this problem, <SPAN 
class=emphasis><EM>you must use a bidirectional association</EM></SPAN> with the 
many valued end (the set or bag) marked as <TT 
class=literal>inverse="true"</TT>. See the discussion of bidirectional 
associations later in this chapter. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=collections-lazy></A>6.5.&nbsp;Lazy 
Initialization</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Collections (other than arrays) may be lazily initialized, meaning they load 
their state from the database only when the application needs to access it. 
Initialization happens transparently to the user so the application would not 
normally need to worry about this (in fact, transparent lazy initialization is 
the main reason why Hibernate needs its own collection implementations). 
However, if the application tries something like this: </P><PRE class=programlisting>s = sessions.openSession();
User u = (User) s.find("from User u where u.name=?", userName, Hibernate.STRING).get(0);
Map permissions = u.getPermissions();
s.connection().commit();
s.close();

Integer accessLevel = (Integer) permissions.get("accounts");  // Error!</PRE>
<P>It could be in for a nasty surprise. Since the permissions collection was not 
initialized when the <TT class=literal>Session</TT> was committed, the 
collection will never be able to load its state. The fix is to move the line 
that reads from the collection to just before the commit. (There are other more 
advanced ways to solve this problem, however.) </P>
<P>Alternatively, use a non-lazy collection. Since lazy initialization can lead 
to bugs like that above, non-laziness is the default. However, it is intended 
that lazy initialization be used for almost all collections, especially for 
collections of entities (for reasons of efficiency). </P>
<P>Exceptions that occur while lazily initializing a collection are wrapped in a 
<TT class=literal>LazyInitializationException</TT>. </P>
<P>Declare a lazy collection using the optional <TT class=literal>lazy</TT> 
attribute: </P><PRE class=programlisting>&lt;set name="names" table="NAMES" lazy="true"&gt;
    &lt;key column="group_id"/&gt;
    &lt;element column="NAME" type="string"/&gt;
&lt;/set&gt;</PRE>
<P>In some application architectures, particularly where the code that accesses 
data using Hibernate, and the code that uses it are in different application 
layers, it can be a problem to ensure that the <TT class=literal>Session</TT> is 
open when a collection is initialized. They are two basic ways to deal with this 
issue: </P>
<DIV class=itemizedlist>
<UL type=disc>
  <LI>
  <P>In a web-based application, a servlet filter can be used to close the <TT 
  class=literal>Session</TT> only at the very end of a user request, once the 
  rendering of the view is complete. Of course, this places heavy demands upon 
  the correctness of the exception handling of your application infrastructure. 
  It is vitally important that the <TT class=literal>Session</TT> is closed and 
  the transaction ended before returning to the user, even when an exception 
  occurs during rendering of the view. The servlet filter has to be able to 
  access the <TT class=literal>Session</TT> for this approach. We recommend that 
  a <TT class=literal>ThreadLocal</TT> variable be used to hold the current <TT 
  class=literal>Session</TT> (see chapter 1, <A 
  title="1.4.&nbsp;Playing with cats" 
  href="http://www.hibernate.org/hib_docs/reference/en/html_single/#quickstart-playingwithcats">Section&nbsp;1.4, 
  “Playing with cats”</A>, for an example implementation). </P>
  <LI>
  <P>In an application with a seperate business tier, the business logic must 
  "prepare" all collections that will be needed by the web tier before 
  returning. This means that the business tier should load all the data and 
  return all the data already initialized to the presentation/web tier that is 
  required for a particular use case. Usually, the application calls <TT 
  class=literal>Hibernate.initialize()</TT> for each collection that will be 
  needed in the web tier (this call must occur before the session is closed) or 
  retrieves the collection eagerly using a Hibernate query with a <TT 
  class=literal>FETCH</TT> clause. </P>
  <LI>
  <P>You may also attach a previously loaded object to a new <TT 
  class=literal>Session</TT> with <TT class=literal>update()</TT> or <TT 
  class=literal>lock()</TT> before accessing unitialized collections (or other 
  proxies). Hibernate can not do this automatically, as it would introduce ad 
  hoc transaction semantics! </P></LI></UL></DIV>
<P>You can use the <TT class=literal>filter()</TT> method of the Hibernate 
Session API to get the size of a collection without initializing it: </P><PRE class=programlisting>( (Integer) s.filter( collection, "select count(*)" ).get(0) ).intValue()</PRE>
<P><TT class=literal>filter()</TT> or <TT class=literal>createFilter()</TT> are 
also used to efficiently retrieve subsets of a collection without needing to 
initialize the whole collection. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=collections-sorted></A>6.6.&nbsp;Sorted Collections</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Hibernate supports collections implementing <TT 
class=literal>java.util.SortedMap</TT> and <TT 
class=literal>java.util.SortedSet</TT>. You must specify a comparator in the 
mapping file: </P><PRE class=programlisting>&lt;set name="aliases" table="person_aliases" sort="natural"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" sort="my.custom.HolidayComparator" lazy="true"&gt;
    &lt;key column="year_id"/&gt;
    &lt;index column="hol_name" type="string"/&gt;
    &lt;element column="hol_date type="date"/&gt;
&lt;/map&gt;</PRE>
<P>Allowed values of the <TT class=literal>sort</TT> attribute are <TT 
class=literal>unsorted</TT>, <TT class=literal>natural</TT> and the name of a 
class implementing <TT class=literal>java.util.Comparator</TT>. </P>
<P>Sorted collections actually behave like <TT 
class=literal>java.util.TreeSet</TT> or <TT 
class=literal>java.util.TreeMap</TT>. </P>
<P>If you want the database itself to order the collection elements use the <TT 
class=literal>order-by</TT> attribute of <TT class=literal>set</TT>, <TT 
class=literal>bag</TT> or <TT class=literal>map</TT> mappings. This solution is 
only available under JDK 1.4 or higher (it is implemented using <TT 
class=literal>LinkedHashSet</TT> or <TT class=literal>LinkedHashMap</TT>). This 
performs the ordering in the SQL query, not in memory. </P><PRE class=programlisting>&lt;set name="aliases" table="person_aliases" order-by="name asc"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" order-by="hol_date, hol_name" lazy="true"&gt;
    &lt;key column="year_id"/&gt;
    &lt;index column="hol_name" type="string"/&gt;
    &lt;element column="hol_date type="date"/&gt;
&lt;/map&gt;</PRE>
<P>Note that the value of the <TT class=literal>order-by</TT> attribute is an 
SQL ordering, not a HQL ordering! </P>
<P>Associations may even be sorted by some arbitrary criteria at runtime using a 
<TT class=literal>filter()</TT>. </P><PRE class=programlisting>sortedUsers = s.filter( group.getUsers(), "order by this.name" );</PRE></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=collections-idbag></A>6.7.&nbsp;<TT 
class=literal>Using an &lt;idbag&gt;</TT></H2></DIV></DIV>
<DIV></DIV></DIV>
<P>If you've fully embraced our view that composite keys are a bad thing and 
that entities should have synthetic identifiers (surrogate keys), then you might 
find it a bit odd that the many to many associations and collections of values 
that we've shown so far all map to tables with composite keys! Now, this point 
is quite arguable; a pure association table doesn't seem to benefit much from a 
surrogate key (though a collection of composite values <SPAN 
class=emphasis><EM>might</EM></SPAN>). Nevertheless, Hibernate provides a 
(slightly experimental) feature that allows you to map many to many associations 
and collections of values to a table with a surrogate key. </P>
<P>The <TT class=literal>&lt;idbag&gt;</TT> element lets you map a <TT 
class=literal>List</TT> (or <TT class=literal>Collection</TT>) with bag 
semantics. </P><PRE class=programlisting>&lt;idbag name="lovers" table="LOVERS" lazy="true"&gt;
    &lt;collection-id column="ID" type="long"&gt;
        &lt;generator class="hilo"/&gt;
    &lt;/collection-id&gt;
    &lt;key column="PERSON1"/&gt;
    &lt;many-to-many column="PERSON2" class="eg.Person" outer-join="true"/&gt;
&lt;/idbag&gt;</PRE>
<P>As you can see, an <TT class=literal>&lt;idbag&gt;</TT> has a synthetic id 
generator, just like an entity class! A different surrogate key is assigned to 
each collection row. Hibernate does not provide any mechanism to discover the 
surrogate key value of a particular row, however. </P>
<P>Note that the update performance of an <TT class=literal>&lt;idbag&gt;</TT> 
is <SPAN class=emphasis><EM>much</EM></SPAN> better than a regular <TT 
class=literal>&lt;bag&gt;</TT>! Hibernate can locate individual rows efficiently 
and update or delete them individually, just like a list, map or set. </P>
<P>In the current implementation, the <TT class=literal>identity</TT> identifier 
generation strategy is not supported for <TT class=literal>&lt;idbag&gt;</TT> 
collection identifiers. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=collections-bidirectional></A>6.8.&nbsp;Bidirectional 
Associations</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>A <SPAN class=emphasis><EM>bidirectional association</EM></SPAN> allows 
navigation from both "ends" of the association. Two kinds of bidirectional 
association are supported: </P>
<DIV class=variablelist>
<DL>
  <DT><SPAN class=term>one-to-many</SPAN>
  <DD>
  <P>set or bag valued at one end, single-valued at the other </P>
  <DT><SPAN class=term>many-to-many</SPAN>
  <DD>
  <P>set or bag valued at both ends </P></DD></DL></DIV>
<P></P>
<P>Please note that Hibernate does not support bidirectional one-to-many 
associations with an indexed collection (list, map or array) as the "many" end, 
you have to use a set or bag mapping. </P>
<P>You may specify a bidirectional many-to-many association simply by mapping 
two many-to-many associations to the same database table and declaring one end 
as <SPAN class=emphasis><EM>inverse</EM></SPAN> (which one is your choice). 
Here's an example of a bidirectional many-to-many association from a class back 
to <SPAN class=emphasis><EM>itself</EM></SPAN> (each category can have many 
items and each item can be in many categories): </P><PRE class=programlisting>&lt;class name="org.hibernate.auction.Category"&gt;
    &lt;id name="id" column="ID"/&gt;
    ...
    &lt;bag name="items" table="CATEGORY_ITEM" lazy="true"&gt;
        &lt;key column="CATEGORY_ID"/&gt;
        &lt;many-to-many class="org.hibernate.auction.Item" column="ITEM_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;

&lt;class name="org.hibernate.auction.Item"&gt;
    &lt;id name="id" column="ID"/&gt;
    ...

    &lt;!-- inverse end --&gt;
    &lt;bag name="categories" table="CATEGORY_ITEM" inverse="true" lazy="true"&gt;
        &lt;key column="ITEM_ID"/&gt;
        &lt;many-to-many class="org.hibernate.auction.Category" column="CATEGORY_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;</PRE>
<P>Changes made only to the inverse end of the association are <SPAN 
class=emphasis><EM>not</EM></SPAN> persisted. This means that Hibernate has two 
representations in memory for every bidirectional association, one link from A 
to B and another link from B to A. This is easier to understand if you think 
about the Java object model and how we create a many-to-many relationship in 
Java: </P><PRE class=programlisting>category.getItems().add(item);          // The category now "knows" about the relationship
item.getCategories().add(category);     // The item now "knows" about the relationship

session.update(item);                     // No effect, nothing will be saved!
session.update(category);                 // The relationship will be saved</PRE>
<P>The non-inverse side is used to save the in-memory representation to the 
database. We would get an unneccessary INSERT/UPDATE and probably even a foreign 
key violation if both would trigger changes! The same is of course also true for 
bidirectional one-to-many associations. </P>
<P>You may map a bidirectional one-to-many association by mapping a one-to-many 
association to the same table column(s) as a many-to-one association and 
declaring the many-valued end <TT class=literal>inverse="true"</TT>. </P><PRE class=programlisting>&lt;class name="eg.Parent"&gt;
    &lt;id name="id" column="id"/&gt;
    ....
    &lt;set name="children" inverse="true" lazy="true"&gt;
        &lt;key column="parent_id"/&gt;
        &lt;one-to-many class="eg.Child"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="eg.Child"&gt;
    &lt;id name="id" column="id"/&gt;
    ....
    &lt;many-to-one name="parent" class="eg.Parent" column="parent_id"/&gt;
&lt;/class&gt;</PRE>
<P>Mapping one end of an association with <TT class=literal>inverse="true"</TT> 
doesn't affect the operation of cascades, both are different concepts! 
</P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=collections-ternary></A>6.9.&nbsp;Ternary Associations</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>There are two possible approaches to mapping a ternary association. One 
approach is to use composite elements (discussed below). Another is to use a <TT 
class=literal>Map</TT> with an association as its index: </P><PRE class=programlisting>&lt;map name="contracts" lazy="true"&gt;
    &lt;key column="employer_id"/&gt;
    &lt;index-many-to-many column="employee_id" class="Employee"/&gt;
    &lt;one-to-many column="contract_id" class="Contract"/&gt;
&lt;/map&gt;</PRE><PRE class=programlisting>&lt;map name="connections" lazy="true"&gt;
    &lt;key column="node1_id"/&gt;
    &lt;index-many-to-many column="node2_id" class="Node"/&gt;
    &lt;many-to-many column="connection_id" class="Connection"/&gt;
&lt;/map&gt;</PRE></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=collections-heterogeneous></A>6.10.&nbsp;Heterogeneous 
Associations</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>The <TT class=literal>&lt;many-to-any&gt;</TT> and <TT 
class=literal>&lt;index-many-to-any&gt;</TT> elements provide for true 
heterogeneous associations. These mapping elements work in the same way as the 
<TT class=literal>&lt;any&gt;</TT> element - and should also be used rarely, if 
ever. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=collections-example></A>6.11.&nbsp;Collection examples</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>The previous sections are pretty confusing. So lets look at an example. This 
class: </P><PRE class=programlisting>package eg;
import java.util.Set;

public class Parent {
    private long id;
    private Set children;

    public long getId() { return id; }
    private void setId(long id) { this.id=id; }

    private Set getChildren() { return children; }
    private void setChildren(Set children) { this.children=children; }

    ....
    ....
}</PRE>
<P>has a collection of <TT class=literal>eg.Child</TT> instances. If each child 
has at most one parent, the most natural mapping is a one-to-many association: 
</P><PRE class=programlisting>&lt;hibernate-mapping&gt;

    &lt;class name="eg.Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" lazy="true"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="eg.Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="eg.Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</PRE>
<P>This maps to the following table definitions: </P><PRE class=programlisting>create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255), parent_id bigint )
alter table child add constraint childfk0 (parent_id) references parent</PRE>
<P>If the parent is <SPAN class=emphasis><EM>required</EM></SPAN>, use a 
bidirectional one-to-many association: </P><PRE class=programlisting>&lt;hibernate-mapping&gt;

    &lt;class name="eg.Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" inverse="true" lazy="true"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="eg.Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="eg.Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
        &lt;many-to-one name="parent" class="eg.Parent" column="parent_id" not-null="true"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</PRE>
<P>Notice the <TT class=literal>NOT NULL</TT> constraint: </P><PRE class=programlisting>create table parent ( id bigint not null primary key )
create table child ( id bigint not null
                     primary key,
                     name varchar(255),
                     parent_id bigint not null )
alter table child add constraint childfk0 (parent_id) references parent</PRE>
<P>On the other hand, if a child might have multiple parents, a many-to-many 
association is appropriate: </P><PRE class=programlisting>&lt;hibernate-mapping&gt;

    &lt;class name="eg.Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" lazy="true" table="childset"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;many-to-many class="eg.Child" column="child_id"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="eg.Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</PRE>
<P>Table definitions: </P><PRE class=programlisting>create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255) )
create table childset ( parent_id bigint not null,
                        child_id bigint not null,
                        primary key ( parent_id, child_id ) )
alter table childset add constraint childsetfk0 (parent_id) references parent
alter table childset add constraint childsetfk1 (child_id) references child</PRE></DIV></DIV>
<DIV class=chapter lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A name=components></A>Chapter&nbsp;7.&nbsp;Component 
Mapping</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>The notion of a <SPAN class=emphasis><EM>component</EM></SPAN> is re-used in 
several different contexts, for different purposes, throughout Hibernate. </P>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=components-dependentobjects></A>7.1.&nbsp;Dependent 
objects</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>A component is a contained object that is persisted as a value type, not an 
entity. The term "component" refers to the object-oriented notion of composition 
(not to architecture-level components). For example, you might model a person 
like this: </P><PRE class=programlisting>public class Person {
    private java.util.Date birthday;
    private Name name;
    private String key;
    public String getKey() {
        return key;
    }
    private void setKey(String key) {
        this.key=key;
    }
    public java.util.Date getBirthday() {
        return birthday;
    }
    public void setBirthday(java.util.Date birthday) {
        this.birthday = birthday;
    }
    public Name getName() {
        return name;
    }
    public void setName(Name name) {
        this.name = name;
    }
    ......
    ......
}</PRE><PRE class=programlisting>public class Name {
    char initial;
    String first;
    String last;
    public String getFirst() {
        return first;
    }
    void setFirst(String first) {
        this.first = first;
    }
    public String getLast() {
        return last;
    }
    void setLast(String last) {
        this.last = last;
    }
    public char getInitial() {
        return initial;
    }
    void setInitial(char initial) {
        this.initial = initial;
    }
}</PRE>
<P>Now <TT class=literal>Name</TT> may be persisted as a component of <TT 
class=literal>Person</TT>. Notice that <TT class=literal>Name</TT> defines 
getter and setter methods for its persistent properties, but doesn't need to 
declare any interfaces or identifier properties. </P>
<P>Our Hibernate mapping would look like: </P><PRE class=programlisting>&lt;class name="eg.Person" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid.hex"/&gt;
    &lt;/id&gt;
    &lt;property name="birthday" type="date"/&gt;
    &lt;component name="Name" class="eg.Name"&gt; &lt;!-- class attribute optional --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</PRE>
<P>The person table would have the columns <TT class=literal>pid</TT>, <TT 
class=literal>birthday</TT>, <TT class=literal>initial</TT>, <TT 
class=literal>first</TT> and <TT class=literal>last</TT>. </P>
<P>Like all value types, components do not support shared references. The null 
value semantics of a component are <SPAN class=emphasis><EM>ad hoc</EM></SPAN>. 
When reloading the containing object, Hibernate will assume that if all 
component columns are null, then the entire component is null. This should be 
okay for most purposes. </P>
<P>The properties of a component may be of any Hibernate type (collections, 
many-to-one associations, other components, etc). Nested components should <SPAN 
class=emphasis><EM>not</EM></SPAN> be considered an exotic usage. Hibernate is 
intended to support a very fine-grained object model. </P>
<P>The <TT class=literal>&lt;component&gt;</TT> element allows a <TT 
class=literal>&lt;parent&gt;</TT> subelement that maps a property of the 
component class as a reference back to the containing entity. </P><PRE class=programlisting>&lt;class name="eg.Person" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid.hex"/&gt;
    &lt;/id&gt;
    &lt;property name="birthday" type="date"/&gt;
    &lt;component name="Name" class="eg.Name"&gt;
        &lt;parent name="namedPerson"/&gt; &lt;!-- reference back to the Person --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</PRE></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=components-incollections></A>7.2.&nbsp;Collections of dependent 
objects</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Collections of components are supported (eg. an array of type <TT 
class=literal>Name</TT>). Declare your component collection by replacing the <TT 
class=literal>&lt;element&gt;</TT> tag with a <TT 
class=literal>&lt;composite-element&gt;</TT> tag. </P><PRE class=programlisting>&lt;set name="someNames" table="some_names" lazy="true"&gt;
    &lt;key column="id"/&gt;
    &lt;composite-element class="eg.Name"&gt; &lt;!-- class attribute required --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/composite-element&gt;
&lt;/set&gt;</PRE>
<P>Note: if you define a <TT class=literal>Set</TT> of composite elements, it is 
very important to implement <TT class=literal>equals()</TT> and <TT 
class=literal>hashCode()</TT> correctly. </P>
<P>Composite elements may contain components but not collections. If your 
composite element itself contains components, use the <TT 
class=literal>&lt;nested-composite-element&gt;</TT> tag. This is a pretty exotic 
case - a collection of components which themselves have components. By this 
stage you should be asking yourself if a one-to-many association is more 
appropriate. Try remodelling the composite element as an entity - but note that 
even though the Java model is the same, the relational model and persistence 
semantics are still slightly different. </P>
<P>Please note that a composite element mapping doesn't support null-able 
properties if you're using a <TT class=literal>&lt;set&gt;</TT>. Hibernate has 
to use each columns value to identify a record when deleting objects (there is 
no separate primary key column in the composite element table), which is not 
possible with null values. You have to either use only not-null properties in a 
composite-element or choose a <TT class=literal>&lt;list&gt;</TT>, <TT 
class=literal>&lt;map&gt;</TT>, <TT class=literal>&lt;bag&gt;</TT> or <TT 
class=literal>&lt;idbag&gt;</TT>. </P>
<P>A special case of a composite element is a composite element with a nested 
<TT class=literal>&lt;many-to-one&gt;</TT> element. A mapping like this allows 
you to map extra columns of a many-to-many association table to the composite 
element class. The following is a many-to-many association from <TT 
class=literal>Order</TT> to <TT class=literal>Item</TT> where <TT 
class=literal>purchaseDate</TT>, <TT class=literal>price</TT> and <TT 
class=literal>quantity</TT> are properties of the association: </P><PRE class=programlisting>&lt;class name="eg.Order" .... &gt;
    ....
    &lt;set name="purchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="eg.Purchase"&gt;
            &lt;property name="purchaseDate"/&gt;
            &lt;property name="price"/&gt;
            &lt;property name="quantity"/&gt;
            &lt;many-to-one name="item" class="eg.Item"/&gt; &lt;!-- class attribute is optional --&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</PRE>
<P>Even ternary (or quaternary, etc) associations are possible:</P><PRE class=programlisting>&lt;class name="eg.Order" .... &gt;
    ....
    &lt;set name="purchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="eg.OrderLine"&gt;
            &lt;many-to-one name="purchaseDetails class="eg.Purchase"/&gt;
            &lt;many-to-one name="item" class="eg.Item"/&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</PRE>
<P>Composite elements may appear in queries using the same syntax as 
associations to other entities. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=components-asmapindex></A>7.3.&nbsp;Components as Map 
indices</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>The <TT class=literal>&lt;composite-index&gt;</TT> element lets you map a 
component class as the key of a <TT class=literal>Map</TT>. Make sure you 
override <TT class=literal>hashCode()</TT> and <TT class=literal>equals()</TT> 
correctly on the component class. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=components-compositeid></A>7.4.&nbsp;Components as composite 
identifiers</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>You may use a component as an identifier of an entity class. Your component 
class must satisfy certain requirements: </P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P>It must implement <TT class=literal>java.io.Serializable</TT>. </P>
  <LI>
  <P>It must re-implement <TT class=literal>equals()</TT> and <TT 
  class=literal>hashCode()</TT>, consistently with the database's notion of 
  composite key equality. </P></LI></UL></DIV>
<P>You can't use an <TT class=literal>IdentifierGenerator</TT> to generate 
composite keys. Instead the application must assign its own identifiers. </P>
<P>Since a composite identifier must be assigned to the object before saving it, 
we can't use <TT class=literal>unsaved-value</TT> of the identifier to 
distinguish between newly instantiated instances and instances saved in a 
previous session. </P>
<P>You may instead implement <TT class=literal>Interceptor.isUnsaved()</TT> if 
you wish to use <TT class=literal>saveOrUpdate()</TT> or cascading save / 
update. As an alternative, you may also set the <TT 
class=literal>unsaved-value</TT> attribute on a <TT 
class=literal>&lt;version&gt;</TT> (or <TT class=literal>&lt;timestamp&gt;</TT>) 
element to specify a value that indicates a new transient instance. In this 
case, the version of the entity is used instead of the (assigned) identifier and 
you don't have to implement <TT class=literal>Interceptor.isUnsaved()</TT> 
yourself. </P>
<P>Use the <TT class=literal>&lt;composite-id&gt;</TT> tag (same attributes and 
elements as <TT class=literal>&lt;component&gt;</TT>) in place of <TT 
class=literal>&lt;id&gt;</TT> for the declaration of a composite identifier 
class: </P><PRE class=programlisting>&lt;class name="eg.Foo" table"FOOS"&gt;
    &lt;composite-id name="compId" class="eg.FooCompositeID"&gt;
        &lt;key-property name="string"/&gt;
        &lt;key-property name="short"/&gt;
        &lt;key-property name="date" column="date_" type="date"/&gt;
    &lt;/composite-id&gt;
    &lt;property name="name"/&gt;
    ....
&lt;/class&gt;</PRE>
<P>Now, any foreign keys into the table <TT class=literal>FOOS</TT> are also 
composite. You must declare this in your mappings for other classes. An 
association to <TT class=literal>Foo</TT> would be declared like this: </P><PRE class=programlisting>&lt;many-to-one name="foo" class="eg.Foo"&gt;
&lt;!-- the "class" attribute is optional, as usual --&gt;
    &lt;column name="foo_string"/&gt;
    &lt;column name="foo_short"/&gt;
    &lt;column name="foo_date"/&gt;
&lt;/many-to-one&gt;</PRE>
<P>This new <TT class=literal>&lt;column&gt;</TT> tag is also used by 
multi-column custom types. Actually it is an alternative to the <TT 
class=literal>column</TT> attribute everywhere. A collection with elements of 
type <TT class=literal>Foo</TT> would use: </P><PRE class=programlisting>&lt;set name="foos"&gt;
    &lt;key column="owner_id"/&gt;
    &lt;many-to-many class="eg.Foo"&gt;
        &lt;column name="foo_string"/&gt;
        &lt;column name="foo_short"/&gt;
        &lt;column name="foo_date"/&gt;
    &lt;/many-to-many&gt;
&lt;/set&gt;</PRE>
<P>On the other hand, <TT class=literal>&lt;one-to-many&gt;</TT>, as usual, 
declares no columns. </P>
<P>If <TT class=literal>Foo</TT> itself contains collections, they will also 
need a composite foreign key. </P><PRE class=programlisting>&lt;class name="eg.Foo"&gt;
    ....
    ....
    &lt;set name="dates" lazy="true"&gt;
        &lt;key&gt;   &lt;!-- a collection inherits the composite key type --&gt;
            &lt;column name="foo_string"/&gt;
            &lt;column name="foo_short"/&gt;
            &lt;column name="foo_date"/&gt;
        &lt;/key&gt;
        &lt;element column="foo_date" type="date"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</PRE></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=components-dynamic></A>7.5.&nbsp;Dynamic components</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>You may even map a property of type <TT class=literal>Map</TT>: </P><PRE class=programlisting>&lt;dynamic-component name="userAttributes"&gt;
    &lt;property name="foo" column="FOO"/&gt;
    &lt;property name="bar" column="BAR"/&gt;
    &lt;many-to-one name="baz" class="eg.Baz" column="BAZ"/&gt;
&lt;/dynamic-component&gt;</PRE>
<P>The semantics of a <TT class=literal>&lt;dynamic-component&gt;</TT> mapping 
are identical to <TT class=literal>&lt;component&gt;</TT>. The advantage of this 
kind of mapping is the ability to determine the actual properties of the bean at 
deployment time, just by editing the mapping document. (Runtime manipulation of 
the mapping document is also possible, using a DOM parser.) </P></DIV></DIV>
<DIV class=chapter lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A name=inheritance></A>Chapter&nbsp;8.&nbsp;Inheritance 
Mapping</H2></DIV></DIV>
<DIV></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=inheritance-strategies></A>8.1.&nbsp;The Three Strategies</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Hibernate supports the three basic inheritance mapping strategies. </P>
<DIV class=itemizedlist>
<UL type=disc>
  <LI>
  <P>table per class hierarchy </P>
  <LI>
  <P>table per subclass </P>
  <LI>
  <P>table per concrete class (some limitations) </P></LI></UL></DIV>
<P>It is even possible to use different mapping strategies for different 
branches of the same inheritance hierarchy, but the same limitations apply as 
apply to table-per-concrete class mappings. Hibernate does not support mixing 
<TT class=literal>&lt;subclass&gt;</TT> mappings and <TT 
class=literal>&lt;joined-subclass&gt;</TT> mappings inside the same <TT 
class=literal>&lt;class&gt;</TT> element. </P>
<P>Suppose we have an interface <TT class=literal>Payment</TT>, with 
implementors <TT class=literal>CreditCardPayment</TT>, <TT 
class=literal>CashPayment</TT>, <TT class=literal>ChequePayment</TT>. The 
table-per-hierarchy mapping would look like: </P><PRE class=programlisting>&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        ...
    &lt;/subclass&gt;
&lt;/class&gt;</PRE>
<P>Exactly one table is required. There is one big limitation of this mapping 
strategy: columns declared by the subclasses may not have <TT class=literal>NOT 
NULL</TT> constraints. </P>
<P>A table-per-subclass mapping would look like: </P><PRE class=programlisting>&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;joined-subclass name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class&gt;</PRE>
<P>Four tables are required. The three subclass tables have primary key 
associations to the superclass table (so the relational model is actually a 
one-to-one association). </P>
<P>Note that Hibernate's implementation of table-per-subclass requires no 
discriminator column. Other object/relational mappers use a different 
implementation of table-per-subclass which requires a type discriminator column 
in the superclass table. The approach taken by Hibernate is much more difficult 
to implement but arguably more correct from a relational point of view. </P>
<P>For either of these two mapping strategies, a polymorphic association to <TT 
class=literal>Payment</TT> is mapped using <TT 
class=literal>&lt;many-to-one&gt;</TT>. </P><PRE class=programlisting>&lt;many-to-one name="payment"
    column="PAYMENT"
    class="Payment"/&gt;</PRE>
<P>The table-per-concrete-class strategy is very different.</P><PRE class=programlisting>&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CREDIT_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="CashPayment" table="CASH_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CASH_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CASH_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CHEQUE_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CHEQUE_AMOUNT"/&gt;
    ...
&lt;/class&gt;</PRE>
<P>Three tables were required. Notice that nowhere do we mention the <TT 
class=literal>Payment</TT> interface explicitly. Instead, we make use of 
Hibernate's <SPAN class=emphasis><EM>implicit polymorphism</EM></SPAN>. Also 
notice that properties of <TT class=literal>Payment</TT> are mapped in each of 
the subclasses. </P>
<P>In this case, a polymorphic association to <TT class=literal>Payment</TT> is 
mapped using <TT class=literal>&lt;any&gt;</TT>. </P><PRE class=programlisting>&lt;any name="payment"
        meta-type="class"
        id-type="long"&gt;
    &lt;column name="PAYMENT_CLASS"/&gt;
    &lt;column name="PAYMENT_ID"/&gt;
&lt;/any&gt;</PRE>
<P>It would be better if we defined a <TT class=literal>UserType</TT> as the <TT 
class=literal>meta-type</TT>, to handle the mapping from type discriminator 
strings to <TT class=literal>Payment</TT> subclass. </P><PRE class=programlisting>&lt;any name="payment"
        meta-type="PaymentMetaType"
        id-type="long"&gt;
    &lt;column name="PAYMENT_TYPE"/&gt; &lt;!-- CREDIT, CASH or CHEQUE --&gt;
    &lt;column name="PAYMENT_ID"/&gt;
&lt;/any&gt;</PRE>
<P>There is one further thing to notice about this mapping. Since the subclasses 
are each mapped in their own <TT class=literal>&lt;class&gt;</TT> element (and 
since <TT class=literal>Payment</TT> is just an interface), each of the 
subclasses could easily be part of another table-per-class or table-per-subclass 
inheritance hierarchy! (And you can still use polymorphic queries against the 
<TT class=literal>Payment</TT> interface.) </P><PRE class=programlisting>&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="CREDIT_CARD" type="string"/&gt;
    &lt;property name="amount" column="CREDIT_AMOUNT"/&gt;
    ...
    &lt;subclass name="MasterCardPayment" discriminator-value="MDC"/&gt;
    &lt;subclass name="VisaPayment" discriminator-value="VISA"/&gt;
&lt;/class&gt;

&lt;class name="NonelectronicTransaction" table="NONELECTRONIC_TXN"&gt;
    &lt;id name="id" type="long" column="TXN_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    ...
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="amount" column="CASH_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="amount" column="CHEQUE_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class&gt;</PRE>
<P>Once again, we don't mention <TT class=literal>Payment</TT> explicitly. If we 
execute a query against the <TT class=literal>Payment</TT> interface - for 
example, <TT class=literal>from Payment</TT> - Hibernate automatically returns 
instances of <TT class=literal>CreditCardPayment</TT> (and its subclasses, since 
they also implement <TT class=literal>Payment</TT>), <TT 
class=literal>CashPayment</TT> and <TT class=literal>ChequePayment</TT> but not 
instances of <TT class=literal>NonelectronicTransaction</TT>. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=inheritance-limitations></A>8.2.&nbsp;Limitations</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Hibernate assumes that an association maps to exactly one foreign key column. 
Multiple associations per foreign key are tolerated (you might need to specify 
<TT class=literal>inverse="true"</TT> or <TT class=literal>insert="false" 
update="false"</TT>), but there is no way to map any association to multiple 
foreign keys. This means that: </P>
<DIV class=itemizedlist>
<UL type=disc>
  <LI>
  <P>when an association is modified, it is always the same foreign key that is 
  updated </P>
  <LI>
  <P>when an association is fetched lazily, a single database query is used </P>
  <LI>
  <P>when an association is fetched eagerly, it may be fetched using a single 
  outer join </P></LI></UL></DIV>
<P>In particular, it implies that polymorphic one-to-many associations to 
classes mapped using the table-per-concrete-class strategy are <SPAN 
class=emphasis><EM>not supported</EM></SPAN>. (Fetching this association would 
require multiple queries or multiple joins.) </P>
<P>The following table shows the limitations of table-per-concrete-class 
mappings, and of implicit polymorphism, in Hibernate. </P>
<DIV class=table><A name=d0e5682></A>
<P class=title><B>Table&nbsp;8.1.&nbsp;Features of inheritance mappings</B></P>
<TABLE summary="Features of inheritance mappings" border=1>
  <COLGROUP>
  <COL align=left>
  <COL align=left>
  <COL align=left>
  <COL align=left>
  <COL align=left>
  <COL align=left>
  <COL align=left>
  <COL align=left></COLGROUP>
  <THEAD>
  <TR>
    <TH align=left>Inheritance strategy</TH>
    <TH align=left>Polymorphic many-to-one</TH>
    <TH align=left>Polymorphic one-to-one</TH>
    <TH align=left>Polymorphic one-to-many</TH>
    <TH align=left>Polymorphic many-to-many</TH>
    <TH align=left>Polymorphic <TT class=literal>load()/get()</TT></TH>
    <TH align=left>Polymorphic queries</TH>
    <TH align=left>Polymorphic joins</TH>
    <TH align=left>Outer join fetching</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD align=left>table-per-class-hierarchy</TD>
    <TD align=left><TT class=literal>&lt;many-to-one&gt;</TT></TD>
    <TD align=left><TT class=literal>&lt;one-to-one&gt;</TT></TD>
    <TD align=left><TT class=literal>&lt;one-to-many&gt;</TT></TD>
    <TD align=left><TT class=literal>&lt;many-to-many&gt;</TT></TD>
    <TD align=left><TT class=literal>s.get(Payment.class, id)</TT></TD>
    <TD align=left><TT class=literal>from Payment p</TT></TD>
    <TD align=left><TT class=literal>from Order o join o.payment p</TT></TD>
    <TD align=left><SPAN class=emphasis><EM>supported</EM></SPAN></TD></TR>
  <TR>
    <TD align=left>table-per-subclass</TD>
    <TD align=left><TT class=literal>&lt;many-to-one&gt;</TT></TD>
    <TD align=left><TT class=literal>&lt;one-to-one&gt;</TT></TD>
    <TD align=left><TT class=literal>&lt;one-to-many&gt;</TT></TD>
    <TD align=left><TT class=literal>&lt;many-to-many&gt;</TT></TD>
    <TD align=left><TT class=literal>s.get(Payment.class, id)</TT></TD>
    <TD align=left><TT class=literal>from Payment p</TT></TD>
    <TD align=left><TT class=literal>from Order o join o.payment p</TT></TD>
    <TD align=left><SPAN class=emphasis><EM>supported</EM></SPAN></TD></TR>
  <TR>
    <TD align=left>table-per-concrete-class (implicit polymorphism)</TD>
    <TD align=left><TT class=literal>&lt;any&gt;</TT></TD>
    <TD align=left><SPAN class=emphasis><EM>not supported</EM></SPAN></TD>
    <TD align=left><SPAN class=emphasis><EM>not supported</EM></SPAN></TD>
    <TD align=left><TT class=literal>&lt;many-to-any&gt;</TT></TD>
    <TD align=left><SPAN class=emphasis><EM>use a query</EM></SPAN></TD>
    <TD align=left><TT class=literal>from Payment p</TT></TD>
    <TD align=left><SPAN class=emphasis><EM>not supported</EM></SPAN></TD>
    <TD align=left><SPAN class=emphasis><EM>not 
  supported</EM></SPAN></TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<DIV class=chapter lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A name=manipulatingdata></A>Chapter&nbsp;9.&nbsp;Manipulating 
Persistent Data</H2></DIV></DIV>
<DIV></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=manipulatingdata-creating></A>9.1.&nbsp;Creating a persistent 
object</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>An object (entity instance) is either <SPAN 
class=emphasis><EM>transient</EM></SPAN> or <SPAN 
class=emphasis><EM>persistent</EM></SPAN> with respect to a particular <TT 
class=literal>Session</TT>. Newly instantiated objects are, of course, 
transient. The session offers services for saving (ie. persisting) transient 
instances: </P><PRE class=programlisting>DomesticCat fritz = new DomesticCat();
fritz.setColor(Color.GINGER);
fritz.setSex('M');
fritz.setName("Fritz");
Long generatedId = (Long) sess.save(fritz);</PRE><PRE class=programlisting>DomesticCat pk = new DomesticCat();
pk.setColor(Color.TABBY);
pk.setSex('F');
pk.setName("PK");
pk.setKittens( new HashSet() );
pk.addKitten(fritz);
sess.save( pk, new Long(1234) );</PRE>
<P>The single-argument <TT class=literal>save()</TT> generates and assigns a 
unique identifier to <TT class=literal>fritz</TT>. The two-argument form 
attempts to persist <TT class=literal>pk</TT> using the given identifier. We 
generally discourage the use of the two-argument form since it may be used to 
create primary keys with business meaning. It is most useful in certain special 
situations like using Hibernate to persist a BMP entity bean. </P>
<P>Associated objects may be made persistent in any order you like unless you 
have a <TT class=literal>NOT NULL</TT> constraint upon a foreign key column. 
There is never a risk of violating foreign key constraints. However, you might 
violate a <TT class=literal>NOT NULL</TT> constraint if you <TT 
class=literal>save()</TT> the objects in the wrong order. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=manipulatingdata-loading></A>9.2.&nbsp;Loading an object</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>The <TT class=literal>load()</TT> methods of <TT class=literal>Session</TT> 
give you a way to retrieve a persistent instance if you already know its 
identifier. One version takes a class object and will load the state into a 
newly instantiated object. The second version allows you to supply an instance 
into which the state will be loaded. The form which takes an instance is 
particularly useful if you plan to use Hibernate with BMP entity beans and is 
provided for exactly that purpose. You may discover other uses. (DIY instance 
pooling etc.) </P><PRE class=programlisting>Cat fritz = (Cat) sess.load(Cat.class, generatedId);</PRE><PRE class=programlisting>// you need to wrap primitive identifiers
long pkId = 1234;
DomesticCat pk = (DomesticCat) sess.load( Cat.class, new Long(pkId) );</PRE><PRE class=programlisting>Cat cat = new DomesticCat();
// load pk's state into cat
sess.load( cat, new Long(pkId) );
Set kittens = cat.getKittens();</PRE>
<P>Note that <TT class=literal>load()</TT> will throw an unrecoverable exception 
if there is no matching database row. If the class is mapped with a proxy, <TT 
class=literal>load()</TT> returns an object that is an uninitialized proxy and 
does not actually hit the database until you invoke a method of the object. This 
behaviour is very useful if you wish to create an association to an object 
without actually loading it from the database. </P>
<P>If you are not certain that a matching row exists, you should use the <TT 
class=literal>get()</TT> method, which hits the database immediately and returns 
null if there is no matching row. </P><PRE class=programlisting>Cat cat = (Cat) sess.get(Cat.class, id);
if (cat==null) {
    cat = new Cat();
    sess.save(cat, id);
}
return cat;</PRE>
<P>You may also load an objects using an SQL <TT class=literal>SELECT ... FOR 
UPDATE</TT>. See the next section for a discussion of Hibernate <TT 
class=literal>LockMode</TT>s. </P><PRE class=programlisting>Cat cat = (Cat) sess.get(Cat.class, id, LockMode.UPGRADE);</PRE>
<P>Note that any associated instances or contained collections are <SPAN 
class=emphasis><EM>not</EM></SPAN> selected <TT class=literal>FOR UPDATE</TT>. 
</P>
<P>It is possible to re-load an object and all its collections at any time, 
using the <TT class=literal>refresh()</TT> method. This is useful when database 
triggers are used to initialize some of the properties of the object. </P><PRE class=programlisting>sess.save(cat);
sess.flush(); //force the SQL INSERT
sess.refresh(cat); //re-read the state (after the trigger executes)</PRE></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=manipulatingdata-querying></A>9.3.&nbsp;Querying</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>If you don't know the identifier(s) of the object(s) you are looking for, use 
the <TT class=literal>find() </TT>methods of <TT class=literal>Session</TT>. 
Hibernate supports a simple but powerful object oriented query language. </P><PRE class=programlisting>List cats = sess.find(
    "from Cat as cat where cat.birthdate = ?",
    date,
    Hibernate.DATE
);

List mates = sess.find(
    "select mate from Cat as cat join cat.mate as mate " +
    "where cat.name = ?",
    name,
    Hibernate.STRING
);

List cats = sess.find( "from Cat as cat where cat.mate.bithdate is null" );

List moreCats = sess.find(
    "from Cat as cat where " + 
    "cat.name = 'Fritz' or cat.id = ? or cat.id = ?",
    new Object[] { id1, id2 },
    new Type[] { Hibernate.LONG, Hibernate.LONG }
);

List mates = sess.find(
    "from Cat as cat where cat.mate = ?",
    izi,
    Hibernate.entity(Cat.class)
);

List problems = sess.find(
    "from GoldFish as fish " +
    "where fish.birthday &gt; fish.deceased or fish.birthday is null"
);</PRE>
<P>The second argument to <TT class=literal>find()</TT> accepts an object or 
array of objects. The third argument accepts a Hibernate type or array of 
Hibernate types. These given types are used to bind the given objects to the <TT 
class=literal>?</TT> query placeholders (which map to IN parameters of a JDBC 
<TT class=literal>PreparedStatement</TT>). Just as in JDBC, you should use this 
binding mechanism in preference to string manipulation. </P>
<P>The <TT class=literal>Hibernate</TT> class defines a number of static methods 
and constants, providing access to most of the built-in types, as instances of 
<TT class=literal>net.sf.hibernate.type.Type</TT>. </P>
<P>If you expect your query to return a very large number of objects, but you 
don't expect to use them all, you might get better performance from the <TT 
class=literal>iterate()</TT> methods, which return a <TT 
class=literal>java.util.Iterator</TT>. The iterator will load objects on demand, 
using the identifiers returned by an initial SQL query (n+1 selects total). </P><PRE class=programlisting>// fetch ids
Iterator iter = sess.iterate("from eg.Qux q order by q.likeliness"); 
while ( iter.hasNext() ) {
    Qux qux = (Qux) iter.next();  // fetch the object
    // something we couldnt express in the query
    if ( qux.calculateComplicatedAlgorithm() ) {
        // delete the current instance
        iter.remove();
        // dont need to process the rest
        break;
    }
}</PRE>
<P>Unfortunately <TT class=literal>java.util.Iterator</TT> does not declare any 
exceptions, so any SQL or Hibernate exceptions that occur are wrapped in a <TT 
class=literal>LazyInitializationException</TT> (a subclass of <TT 
class=literal>RuntimeException</TT>). </P>
<P>The <TT class=literal>iterate()</TT> method also performs better if you 
expect that many of the objects are already loaded and cached by the session, or 
if the query results contain the same objects many times. (When no data is 
cached or repeated, <TT class=literal>find()</TT> is almost always faster.) 
Heres an example of a query that should be called using <TT 
class=literal>iterate()</TT>: </P><PRE class=programlisting>Iterator iter = sess.iterate(
    "select customer, product " + 
    "from Customer customer, " +
    "Product product " +
    "join customer.purchases purchase " +
    "where product = purchase.product"
);</PRE>
<P>Calling the previous query using <TT class=literal>find()</TT> would return a 
very large JDBC <TT class=literal>ResultSet</TT> containing the same data many 
times. </P>
<P>Hibernate queries sometimes return tuples of objects, in which case each 
tuple is returned as an array: </P><PRE class=programlisting>Iterator foosAndBars = sess.iterate(
    "select foo, bar from Foo foo, Bar bar " +
    "where bar.date = foo.date"
);
while ( foosAndBars.hasNext() ) {
    Object[] tuple = (Object[]) foosAndBars.next();
    Foo foo = tuple[0]; Bar bar = tuple[1];
    ....
}</PRE>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=manipulatingdata-scalarqueries></A>9.3.1.&nbsp;Scalar 
queries</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>Queries may specify a property of a class in the <TT 
class=literal>select</TT> clause. They may even call SQL aggregate functions. 
Properties or aggregates are considered "scalar" results. </P><PRE class=programlisting>Iterator results = sess.iterate(
        "select cat.color, min(cat.birthdate), count(cat) from Cat cat " +
        "group by cat.color"
);
while ( results.hasNext() ) {
    Object[] row = results.next();
    Color type = (Color) row[0];
    Date oldest = (Date) row[1];
    Integer count = (Integer) row[2];
    .....
}</PRE><PRE class=programlisting>Iterator iter = sess.iterate(
    "select cat.type, cat.birthdate, cat.name from DomesticCat cat"
);</PRE><PRE class=programlisting>List list = sess.find(
    "select cat, cat.mate.name from DomesticCat cat"
);</PRE></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=manipulatingdata-queryinterface></A>9.3.2.&nbsp;The 
Query interface</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>If you need to specify bounds upon your result set (the maximum number of 
rows you want to retrieve and / or the first row you want to retrieve) you 
should obtain an instance of <TT class=literal>net.sf.hibernate.Query</TT>: </P><PRE class=programlisting>Query q = sess.createQuery("from DomesticCat cat");
q.setFirstResult(20);
q.setMaxResults(10);
List cats = q.list();</PRE>
<P>You may even define a named query in the mapping document. (Remember to use a 
<TT class=literal>CDATA</TT> section if your query contains characters that 
could be interpreted as markup.) </P><PRE class=programlisting>&lt;query name="eg.DomesticCat.by.name.and.minimum.weight"&gt;&lt;![CDATA[
    from eg.DomesticCat as cat
        where cat.name = ?
        and cat.weight &gt; ?
] ]&gt;&lt;/query&gt;</PRE><PRE class=programlisting>Query q = sess.getNamedQuery("eg.DomesticCat.by.name.and.minimum.weight");
q.setString(0, name);
q.setInt(1, minWeight);
List cats = q.list();</PRE>
<P>The query interface supports the use of named parameters. Named parameters 
are identifiers of the form <TT class=literal>:name</TT> in the query string. 
There are methods on <TT class=literal>Query</TT> for binding values to named 
parameters or JDBC-style <TT class=literal>?</TT> parameters. <SPAN 
class=emphasis><EM>Contrary to JDBC, Hibernate numbers parameters from 
zero.</EM></SPAN> The advantages of named parameters are: </P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P>named parameters are insensitive to the order they occur in the query 
  string </P>
  <LI>
  <P>they may occur multiple times in the same query </P>
  <LI>
  <P>they are self-documenting </P></LI></UL></DIV><PRE class=programlisting>//named parameter (preferred)
Query q = sess.createQuery("from DomesticCat cat where cat.name = :name");
q.setString("name", "Fritz");
Iterator cats = q.iterate();</PRE><PRE class=programlisting>//positional parameter
Query q = sess.createQuery("from DomesticCat cat where cat.name = ?");
q.setString(0, "Izi");
Iterator cats = q.iterate();</PRE><PRE class=programlisting>//named parameter list
List names = new ArrayList();
names.add("Izi");
names.add("Fritz");
Query q = sess.createQuery("from DomesticCat cat where cat.name in (:namesList)");
q.setParameterList("namesList", names);
List cats = q.list();</PRE></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=manipulatingdata-scrolling></A>9.3.3.&nbsp;Scrollable 
iteration</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>If your JDBC driver supports scrollable <TT class=literal>ResultSet</TT>s, 
the <TT class=literal>Query</TT> interface may be used to obtain a <TT 
class=literal>ScrollableResults</TT> which allows more flexible navigation of 
the query results. </P><PRE class=programlisting>Query q = sess.createQuery("select cat.name, cat from DomesticCat cat " +
                            "order by cat.name");
ScrollableResults cats = q.scroll();
if ( cats.first() ) {

    // find the first name on each page of an alphabetical list of cats by name
    firstNamesOfPages = new ArrayList();
    do {
        String name = cats.getString(0);
        firstNamesOfPages.add(name);
    }
    while ( cats.scroll(PAGE_SIZE) );

    // Now get the first page of cats
    pageOfCats = new ArrayList();
    cats.beforeFirst();
    int i=0;
    while( ( PAGE_SIZE &gt; i++ ) &amp;&amp; cats.next() ) pageOfCats.add( cats.get(1) );

}</PRE>
<P>The behaviour of <TT class=literal>scroll()</TT> is similar to <TT 
class=literal>iterate()</TT>, except that objects may be initialized selectively 
by <TT class=literal>get(int)</TT>, instead of an entire row being initialized 
at once. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=manipulatingdata-filtering></A>9.3.4.&nbsp;Filtering 
collections</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>A collection <SPAN class=emphasis><EM>filter</EM></SPAN> is a special type of 
query that may be applied to a persistent collection or array. The query string 
may refer to <TT class=literal>this</TT>, meaning the current collection 
element. </P><PRE class=programlisting>Collection blackKittens = session.filter(
    pk.getKittens(), "where this.color = ?", Color.BLACK, Hibernate.enum(Color.class)
);</PRE>
<P>The returned collection is considered a bag. </P>
<P>Observe that filters do not require a <TT class=literal>from</TT> clause 
(though they may have one if required). Filters are not limited to returning the 
collection elements themselves. </P><PRE class=programlisting>Collection blackKittenMates = session.filter(
    pk.getKittens(), "select this.mate where this.color = eg.Color.BLACK"
);</PRE></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=manipulatingdata-criteria></A>9.3.5.&nbsp;Criteria 
queries</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>HQL is extremely powerful but some people prefer to build queries 
dynamically, using an object oriented API, rather than embedding strings in 
their Java code. For these people, Hibernate provides an intuitive <TT 
class=literal>Criteria</TT> query API. </P><PRE class=programlisting>Criteria crit = session.createCriteria(Cat.class);
crit.add( Expression.eq("color", eg.Color.BLACK) );
crit.setMaxResults(10);
List cats = crit.list();</PRE>
<P>If you are uncomfortable with SQL-like syntax, this is perhaps the easiest 
way to get started with Hibernate. This API is also more extensible than HQL. 
Applications might provide their own implementations of the <TT 
class=literal>Criterion</TT> interface. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=manipulatingdata-nativesql></A>9.3.6.&nbsp;Queries in 
native SQL</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>You may express a query in SQL, using <TT 
class=literal>createSQLQuery()</TT>. You must enclose SQL aliases in braces. 
</P><PRE class=programlisting>List cats = session.createSQLQuery(
    "SELECT {cat.*} FROM CAT {cat} WHERE ROWNUM&lt;10",
    "cat",
    Cat.class
).list();</PRE><PRE class=programlisting>List cats = session.createSQLQuery(
    "SELECT {cat}.ID AS {cat.id}, {cat}.SEX AS {cat.sex}, " +
           "{cat}.MATE AS {cat.mate}, {cat}.SUBCLASS AS {cat.class}, ... " +
    "FROM CAT {cat} WHERE ROWNUM&lt;10",
    "cat",
    Cat.class
).list()</PRE>
<P>SQL queries may contain named and positional parameters, just like Hibernate 
queries. </P></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=manipulatingdata-updating></A>9.4.&nbsp;Updating objects</H2></DIV></DIV>
<DIV></DIV></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=manipulatingdata-updating-insession></A>9.4.1.&nbsp;Updating in the same 
Session</H3></DIV></DIV>
<DIV></DIV></DIV>
<P><SPAN class=emphasis><EM>Transactional persistent instances</EM></SPAN> (ie. 
objects loaded, saved, created or queried by the <TT class=literal>Session</TT>) 
may be manipulated by the application and any changes to persistent state will 
be persisted when the <TT class=literal>Session</TT> is <SPAN 
class=emphasis><EM>flushed</EM></SPAN> (discussed later in this chapter). So the 
most straightforward way to update the state of an object is to <TT 
class=literal>load()</TT> it, and then manipulate it directly, while the <TT 
class=literal>Session</TT> is open: </P><PRE class=programlisting>DomesticCat cat = (DomesticCat) sess.load( Cat.class, new Long(69) );
cat.setName("PK");
sess.flush();  // changes to cat are automatically detected and persisted</PRE>
<P>Sometimes this programming model is inefficient since it would require both 
an SQL <TT class=literal>SELECT</TT> (to load an object) and an SQL <TT 
class=literal>UPDATE</TT> (to persist its updated state) in the same session. 
Therefore Hibernate offers an alternate approach. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=manipulatingdata-updating-detached></A>9.4.2.&nbsp;Updating detached 
objects</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>Many applications need to retrieve an object in one transaction, send it to 
the UI layer for manipulation, then save the changes in a new transaction. 
(Applications that use this kind of approach in a high-concurrency environment 
usually use versioned data to ensure transaction isolation.) This approach 
requires a slightly different programming model to the one described in the last 
section. Hibernate supports this model by providing the method <TT 
class=literal>Session.update()</TT>. </P><PRE class=programlisting>// in the first session
Cat cat = (Cat) firstSession.load(Cat.class, catId);
Cat potentialMate = new Cat();
firstSession.save(potentialMate);

// in a higher tier of the application
cat.setMate(potentialMate);

// later, in a new session
secondSession.update(cat);  // update cat
secondSession.update(mate); // update mate</PRE>
<P>If the <TT class=literal>Cat</TT> with identifier <TT 
class=literal>catId</TT> had already been loaded by <TT 
class=literal>secondSession</TT> when the application tried to update it, an 
exception would have been thrown. </P>
<P>The application should individually <TT class=literal>update()</TT> transient 
instances reachable from the given transient instance if and <SPAN 
class=emphasis><EM>only</EM></SPAN> if it wants their state also updated. 
(Except for lifecycle objects, discussed later.) </P>
<P>Hibernate users have requested a general purpose method that either saves a 
transient instance by generating a new identifier or update the persistent state 
associated with its current identifier. The <TT 
class=literal>saveOrUpdate()</TT> method now implements this functionality. </P>
<P>Hibernate distinguishes "new" (unsaved) instances from "existing" (saved or 
loaded in a previous session) instances by the value of their identifier (or 
version, or timestamp) property. The <TT class=literal>unsaved-value</TT> 
attribute of the <TT class=literal>&lt;id&gt;</TT> (or <TT 
class=literal>&lt;version&gt;</TT>, or <TT class=literal>&lt;timestamp&gt;</TT>) 
mapping specifies which values should be interpreted as representing a "new" 
instance. </P><PRE class=programlisting>&lt;id name="id" type="long" column="uid" unsaved-value="null"&gt;
    &lt;generator class="hilo"/&gt;
&lt;/id&gt;</PRE>
<P>The allowed values of <TT class=literal>unsaved-value</TT> are: </P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P><TT class=literal>any</TT> - always save </P>
  <LI>
  <P><TT class=literal>none</TT> - always update </P>
  <LI>
  <P><TT class=literal>null</TT> - save when identifier is null (this is the 
  default) </P>
  <LI>
  <P>valid identifier value - save when identifier is null or the given value 
  </P>
  <LI>
  <P><TT class=literal>undefined</TT> - the default for <TT 
  class=literal>version</TT> or <TT class=literal>timestamp</TT>, then 
  identifier check is used </P></LI></UL></DIV><PRE class=programlisting>// in the first session
Cat cat = (Cat) firstSession.load(Cat.class, catID);

// in a higher tier of the application
Cat mate = new Cat();
cat.setMate(mate);

// later, in a new session
secondSession.saveOrUpdate(cat);   // update existing state (cat has a non-null id)
secondSession.saveOrUpdate(mate);  // save the new instance (mate has a null id)</PRE>
<P>The usage and semantics of <TT class=literal>saveOrUpdate()</TT> seems to be 
confusing for new users. Firstly, so long as you are not trying to use instances 
from one session in another new session, you should not need to use <TT 
class=literal>update()</TT> or <TT class=literal>saveOrUpdate()</TT>. Some whole 
applications will never use either of these methods. </P>
<P>Usually <TT class=literal>update()</TT> or <TT 
class=literal>saveOrUpdate()</TT> are used in the following scenario: </P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P>the application loads an object in the first session </P>
  <LI>
  <P>the object is passed up to the UI tier </P>
  <LI>
  <P>some modifications are made to the object </P>
  <LI>
  <P>the object is passed back down to the business logic tier </P>
  <LI>
  <P>the application persists these modifications by calling <TT 
  class=literal>update()</TT> in a second session </P></LI></UL></DIV>
<P><TT class=literal>saveOrUpdate()</TT> does the following: </P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P>if the object is already persistent in this session, do nothing </P>
  <LI>
  <P>if the object has no identifier property, <TT class=literal>save()</TT> it 
  </P>
  <LI>
  <P>if the object's identifier matches the criteria specified by <TT 
  class=literal>unsaved-value</TT>, <TT class=literal>save()</TT> it </P>
  <LI>
  <P>if the object is versioned (<TT class=literal>version</TT> or <TT 
  class=literal>timestamp</TT>), then the version will take precedence to 
  identifier check, unless the versions <TT 
  class=literal>unsaved-value="undefined"</TT> (default value) </P>
  <LI>
  <P>if another object associated with the session has the same identifier, 
  throw an exception </P></LI></UL></DIV></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=manipulatingdata-update-lock></A>9.4.3.&nbsp;Reattaching 
detached objects</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>The <TT class=literal>lock()</TT> method allows the application to 
reassociate an unmodified object with a new session. </P><PRE class=programlisting>//just reassociate:
sess.lock(fritz, LockMode.NONE);
//do a version check, then reassociate:
sess.lock(izi, LockMode.READ);
//do a version check, using SELECT ... FOR UPDATE, then reassociate:
sess.lock(pk, LockMode.UPGRADE);</PRE></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=manipulatingdata-deleting></A>9.5.&nbsp;Deleting persistent 
objects</H2></DIV></DIV>
<DIV></DIV></DIV>
<P><TT class=literal>Session.delete()</TT> will remove an object's state from 
the database. Of course, your application might still hold a reference to it. So 
it's best to think of <TT class=literal>delete()</TT> as making a persistent 
instance transient. </P><PRE class=programlisting>sess.delete(cat);</PRE>
<P>You may also delete many objects at once by passing a Hibernate query string 
to <TT class=literal>delete()</TT>. </P>
<P>You may now delete objects in any order you like, without risk of foreign key 
constraint violations. Of course, it is still possible to violate a <TT 
class=literal>NOT NULL</TT> constraint on a foreign key column by deleting 
objects in the wrong order. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=manipulatingdata-flushing></A>9.6.&nbsp;Flush</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>From time to time the <TT class=literal>Session</TT> will execute the SQL 
statements needed to synchronize the JDBC connection's state with the state of 
objects held in memory. This process, <SPAN 
class=emphasis><EM>flush</EM></SPAN>, occurs by default at the following points 
</P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P>from some invocations of <TT class=literal>find()</TT> or <TT 
  class=literal>iterate()</TT> </P>
  <LI>
  <P>from <TT class=literal>net.sf.hibernate.Transaction.commit()</TT> </P>
  <LI>
  <P>from <TT class=literal>Session.flush()</TT> </P></LI></UL></DIV>
<P>The SQL statements are issued in the following order </P>
<DIV class=orderedlist>
<OL type=1 compact>
  <LI>
  <P>all entity insertions, in the same order the corresponding objects were 
  saved using <TT class=literal>Session.save()</TT> </P>
  <LI>
  <P>all entity updates </P>
  <LI>
  <P>all collection deletions </P>
  <LI>
  <P>all collection element deletions, updates and insertions </P>
  <LI>
  <P>all collection insertions </P>
  <LI>
  <P>all entity deletions, in the same order the corresponding objects were 
  deleted using <TT class=literal>Session.delete()</TT> </P></LI></OL></DIV>
<P>(An exception is that objects using <TT class=literal>native</TT> ID 
generation are inserted when they are saved.) </P>
<P>Except when you explicity <TT class=literal>flush()</TT>, there are 
absolutely no guarantees about <SPAN class=emphasis><EM>when</EM></SPAN> the <TT 
class=literal>Session</TT> executes the JDBC calls, only the <SPAN 
class=emphasis><EM>order</EM></SPAN> in which they are executed. However, 
Hibernate does guarantee that the <TT class=literal>Session.find(..)</TT> 
methods will never return stale data; nor will they return the wrong data. </P>
<P>It is possible to change the default behavior so that flush occurs less 
frequently. The <TT class=literal>FlushMode</TT> class defines three different 
modes. This is most useful in the case of "readonly" transactions, where it 
might be used to achieve a (very) slight performance increase. </P><PRE class=programlisting>sess = sf.openSession();
Transaction tx = sess.beginTransaction();
sess.setFlushMode(FlushMode.COMMIT); //allow queries to return stale state
Cat izi = (Cat) sess.load(Cat.class, id);
izi.setName(iznizi);
// execute some queries....
sess.find("from Cat as cat left outer join cat.kittens kitten");
//change to izi is not flushed!
...
tx.commit(); //flush occurs</PRE></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=manipulatingdata-endingsession></A>9.7.&nbsp;Ending a 
Session</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Ending a session involves four distinct phases: </P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P>flush the session </P>
  <LI>
  <P>commit the transaction </P>
  <LI>
  <P>close the session </P>
  <LI>
  <P>handle exceptions </P></LI></UL></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=manipulatingdata-endingsession-flushing></A>9.7.1.&nbsp;Flushing the 
Session</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>If you happen to be using the <TT class=literal>Transaction</TT> API, you 
don't need to worry about this step. It will be performed implicitly when the 
transaction is committed. Otherwise you should call <TT 
class=literal>Session.flush()</TT> to ensure that all changes are synchronized 
with the database. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=manipulatingdata-endingsession-commit></A>9.7.2.&nbsp;Committing the 
database transaction</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>If you are using the Hibernate <TT class=literal>Transaction</TT> API, this 
looks like: </P><PRE class=programlisting>tx.commit(); // flush the Session and commit the transaction</PRE>
<P>If you are managing JDBC transactions yourself you should manually <TT 
class=literal>commit()</TT> the JDBC connection. </P><PRE class=programlisting>sess.flush();
sess.connection().commit();  // not necessary for JTA datasource</PRE>
<P>If you decide <SPAN class=emphasis><EM>not</EM></SPAN> to commit your 
changes: </P><PRE class=programlisting>tx.rollback();  // rollback the transaction</PRE>
<P>or: </P><PRE class=programlisting>// not necessary for JTA datasource, important otherwise
sess.connection().rollback();</PRE>
<P>If you rollback the transaction you should immediately close and discard the 
current session to ensure that Hibernate's internal state is consistent. 
</P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=manipulatingdata-endingsession-close></A>9.7.3.&nbsp;Closing the 
Session</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>A call to <TT class=literal>Session.close()</TT> marks the end of a session. 
The main implication of <TT class=literal>close()</TT> is that the JDBC 
connection will be relinquished by the session. </P><PRE class=programlisting>tx.commit();
sess.close();</PRE><PRE class=programlisting>sess.flush();
sess.connection().commit();  // not necessary for JTA datasource
sess.close();</PRE>
<P>If you provided your own connection, <TT class=literal>close()</TT> returns a 
reference to it, so you can manually close it or return it to the pool. 
Otherwise <TT class=literal>close() </TT>returns it to the pool. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=manipulatingdata-endingsession-exceptions></A>9.7.4.&nbsp;Exception 
handling</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>If the <TT class=literal>Session</TT> throws an exception (including any <TT 
class=literal>SQLException</TT>), you should immediately rollback the 
transaction, call <TT class=literal>Session.close()</TT> and discard the <TT 
class=literal>Session</TT> instance. Certain methods of <TT 
class=literal>Session</TT> will <SPAN class=emphasis><EM>not</EM></SPAN> leave 
the session in a consistent state. </P>
<P>The following exception handling idiom is recommended: </P><PRE class=programlisting>Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();
    // do some work
    ...
    tx.commit();
}
catch (Exception e) {
    if (tx!=null) tx.rollback();
    throw e;
}
finally {
    sess.close();
}</PRE>
<P>Or, when manually managing JDBC transactions: </P><PRE class=programlisting>Session sess = factory.openSession();
try {
    // do some work
    ...
    sess.flush();
    sess.connection().commit();
}
catch (Exception e) {
    sess.connection().rollback();
    throw e;
}
finally {
    sess.close();
}</PRE>
<P>Or, when using a datasource enlisted with JTA: </P><PRE class=programlisting>UserTransaction ut = .... ;
Session sess = factory.openSession();
try {
    // do some work
    ...
    sess.flush();
}
catch (Exception e) {
    ut.setRollbackOnly();
    throw e;
}
finally {
    sess.close();
}</PRE></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=manipulatingdata-graphs></A>9.8.&nbsp;Lifecyles and object 
graphs</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>To save or update all objects in a graph of associated objects, you must 
either </P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P><TT class=literal>save()</TT>, <TT class=literal>saveOrUpdate()</TT> or <TT 
  class=literal>update()</TT> each individual object OR </P>
  <LI>
  <P>map associated objects using <TT class=literal>cascade="all"</TT> or <TT 
  class=literal>cascade="save-update"</TT>. </P></LI></UL></DIV>
<P>Likewise, to delete all objects in a graph, either </P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P><TT class=literal>delete()</TT> each individual object OR </P>
  <LI>
  <P>map associated objects using <TT class=literal>cascade="all"</TT>, <TT 
  class=literal>cascade="all-delete-orphan"</TT> or <TT 
  class=literal>cascade="delete"</TT>. </P></LI></UL></DIV>
<P>Recommendation: </P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P>If the child object's lifespan is bounded by the lifespan of the of the 
  parent object make it a <SPAN class=emphasis><EM>lifecycle object</EM></SPAN> 
  by specifying <TT class=literal>cascade="all"</TT>. </P>
  <LI>
  <P>Otherwise, <TT class=literal>save()</TT> and <TT 
  class=literal>delete()</TT> it explicitly from application code. If you really 
  want to save yourself some extra typing, use <TT 
  class=literal>cascade="save-update"</TT> and explicit <TT 
  class=literal>delete()</TT>. </P></LI></UL></DIV>
<P>Mapping an association (many-to-one, or collection) with <TT 
class=literal>cascade="all"</TT> marks the association as a <SPAN 
class=emphasis><EM>parent/child</EM></SPAN> style relationship where 
save/update/deletion of the parent results in save/update/deletion of the 
child(ren). Futhermore, a mere reference to a child from a persistent parent 
will result in save / update of the child. The metaphor is incomplete, however. 
A child which becomes unreferenced by its parent is <SPAN 
class=emphasis><EM>not</EM></SPAN> automatically deleted, except in the case of 
a <TT class=literal>&lt;one-to-many&gt;</TT> association mapped with <TT 
class=literal>cascade="all-delete-orphan"</TT>. The precise semantics of 
cascading operations are as follows: </P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P>If a parent is saved, all children are passed to <TT 
  class=literal>saveOrUpdate()</TT> </P>
  <LI>
  <P>If a parent is passed to <TT class=literal>update()</TT> or <TT 
  class=literal>saveOrUpdate()</TT>, all children are passed to <TT 
  class=literal>saveOrUpdate()</TT> </P>
  <LI>
  <P>If a transient child becomes referenced by a persistent parent, it is 
  passed to <TT class=literal>saveOrUpdate()</TT> </P>
  <LI>
  <P>If a parent is deleted, all children are passed to <TT 
  class=literal>delete()</TT> </P>
  <LI>
  <P>If a transient child is dereferenced by a persistent parent, <SPAN 
  class=emphasis><EM>nothing special happens</EM></SPAN> (the application should 
  explicitly delete the child if necessary) unless <TT 
  class=literal>cascade="all-delete-orphan"</TT>, in which case the "orphaned" 
  child is deleted. </P></LI></UL></DIV>
<P>Hibernate does not fully implement "persistence by reachability", which would 
imply (inefficient) persistent garbage collection. However, due to popular 
demand, Hibernate does support the notion of entities becoming persistent when 
referenced by another persistent object. Associations marked <TT 
class=literal>cascade="save-update"</TT> behave in this way. If you wish to use 
this approach throughout your application, its easier to specify the <TT 
class=literal>default-cascade</TT> attribute of the <TT 
class=literal>&lt;hibernate-mapping&gt;</TT> element. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=manipulatingdata-interceptors></A>9.9.&nbsp;Interceptors</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>The <TT class=literal>Interceptor</TT> interface provides callbacks from the 
session to the application allowing the application to inspect and / or 
manipulate properties of a persistent object before it is saved, updated, 
deleted or loaded. One possible use for this is to track auditing information. 
For example, the following <TT class=literal>Interceptor</TT> automatically sets 
the <TT class=literal>createTimestamp</TT> when an <TT 
class=literal>Auditable</TT> is created and updates the <TT 
class=literal>lastUpdateTimestamp</TT> property when an <TT 
class=literal>Auditable</TT> is updated. </P><PRE class=programlisting>package net.sf.hibernate.test;

import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;

import net.sf.hibernate.Interceptor;
import net.sf.hibernate.type.Type;

public class AuditInterceptor implements Interceptor, Serializable {

    private int updates;
    private int creates;

    public void onDelete(Object entity,
                         Serializable id,
                         Object[] state,
                         String[] propertyNames,
                         Type[] types) {
        // do nothing
    }

    public boolean onFlushDirty(Object entity, 
                                Serializable id, 
                                Object[] currentState,
                                Object[] previousState,
                                String[] propertyNames,
                                Type[] types) {

        if ( entity instanceof Auditable ) {
            updates++;
            for ( int i=0; i &lt; propertyNames.length; i++ ) {
                if ( "lastUpdateTimestamp".equals( propertyNames[i] ) ) {
                    currentState[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public boolean onLoad(Object entity, 
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {
        return false;
    }

    public boolean onSave(Object entity,
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {
        
        if ( entity instanceof Auditable ) {
            creates++;
            for ( int i=0; i&lt;propertyNames.length; i++ ) {
                if ( "createTimestamp".equals( propertyNames[i] ) ) {
                    state[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public void postFlush(Iterator entities) {
        System.out.println("Creations: " + creates + ", Updates: " + updates);
    }

    public void preFlush(Iterator entities) {
        updates=0;
        creates=0;
    }
    
    ......
    ......
    
}</PRE>
<P>The interceptor would be specified when a session is created. </P><PRE class=programlisting>Session session = sf.openSession( new AuditInterceptor() );</PRE></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=manipulatingdata-metadata></A>9.10.&nbsp;Metadata API</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Hibernate requires a very rich meta-level model of all entity and value 
types. From time to time, this model is very useful to the application itself. 
For example, the application might use Hibernate's metadata to implement a 
"smart" deep-copy algorithm that understands which objects should be copied (eg. 
mutable value types) and which should not (eg. immutable value types and, 
possibly, associated entities). </P>
<P>Hibernate exposes metadata via the <TT class=literal>ClassMetadata</TT> and 
<TT class=literal>CollectionMetadata</TT> interfaces and the <TT 
class=literal>Type</TT> hierarchy. Instances of the metadata interfaces may be 
obtained from the <TT class=literal>SessionFactory</TT>. </P><PRE class=programlisting>Cat fritz = ......;
Long id = (Long) catMeta.getIdentifier(fritz);
ClassMetadata catMeta = sessionfactory.getClassMetadata(Cat.class);
Object[] propertyValues = catMeta.getPropertyValues(fritz);
String[] propertyNames = catMeta.getPropertyNames();
Type[] propertyTypes = catMeta.getPropertyTypes();
// get a Map of all properties which are not collections or associations
// TODO: what about components?
Map namedValues = new HashMap();
for ( int i=0; i&lt;propertyNames.length; i++ ) {
    if ( !propertyTypes[i].isEntityType() &amp;&amp; !propertyTypes[i].isCollectionType() ) {
        namedValues.put( propertyNames[i], propertyValues[i] );
    }
}</PRE></DIV></DIV>
<DIV class=chapter lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A name=transactions></A>Chapter&nbsp;10.&nbsp;Transactions And 
Concurrency</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Hibernate is not itself a database. It is a lightweight object-relational 
mapping tool. Transaction management is delegated to the underlying database 
connection. If the connection is enlisted with JTA, operations performed by the 
<TT class=literal>Session</TT> are atomically part of the wider JTA transaction. 
Hibernate can be seen as a thin adapter to JDBC, adding object- oriented 
semantics. </P>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=transactions-basics></A>10.1.&nbsp;Configurations, Sessions and 
Factories</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>A <TT class=literal>SessionFactory</TT> is an expensive-to-create, threadsafe 
object intended to be shared by all application threads. A <TT 
class=literal>Session</TT> is an inexpensive, non-threadsafe object that should 
be used once, for a single business process, and then discarded. For example, 
when using Hibernate in a servlet-based application, servlets could obtain a <TT 
class=literal>SessionFactory</TT> using </P><PRE class=programlisting>SessionFactory sf = (SessionFactory)getServletContext().getAttribute("my.session.factory");</PRE>
<P>Each call to a service method could create a new <TT 
class=literal>Session</TT>, <TT class=literal>flush()</TT> it, <TT 
class=literal>commit()</TT> its connection, <TT class=literal>close()</TT> it 
and finally discard it. (The <TT class=literal>SessionFactory</TT> may also be 
kept in JNDI or in a static <SPAN class=emphasis><EM>Singleton</EM></SPAN> 
helper variable.) </P>
<P>In a stateless session bean, a similar approach could be used. The bean would 
obtain a <TT class=literal>SessionFactory</TT> in <TT 
class=literal>setSessionContext()</TT>. Then each business method would create a 
<TT class=literal>Session</TT>, <TT class=literal>flush()</TT> it and <TT 
class=literal>close()</TT> it. Of course, the application should not <TT 
class=literal>commit()</TT> the connection. (Leave that to JTA, the database 
connection participates automatically in container-managed transactions.) </P>
<P>We use the Hibernate <TT class=literal>Transaction</TT> API as discussed 
previously, a single <TT class=literal>commit()</TT> of a Hibernate <TT 
class=literal>Transaction</TT> flushes the state and commits any underlying 
database connection (with special handling of JTA transactions). </P>
<P>Ensure you understand the semantics of <TT class=literal>flush()</TT>. 
Flushing synchronizes the persistent store with in-memory changes but <SPAN 
class=emphasis><EM>not</EM></SPAN> vice-versa. Note that for all Hibernate JDBC 
connections/transactions, the transaction isolation level for that connection 
applies to all operations executed by Hibernate! </P>
<P>The next few sections will discuss alternative approaches that utilize 
versioning to ensure transaction atomicity. These are considered "advanced" 
approaches to be used with care. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=transactions-threads></A>10.2.&nbsp;Threads and 
connections</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>You should observe the following practices when creating Hibernate Sessions: 
</P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P>Never create more than one concurrent <TT class=literal>Session</TT> or <TT 
  class=literal>Transaction</TT> instance per database connection. </P>
  <LI>
  <P>Be extremely careful when creating more than one <TT 
  class=literal>Session</TT> per database per transaction. The <TT 
  class=literal>Session</TT> itself keeps track of updates made to loaded 
  objects, so a different <TT class=literal>Session</TT> might see stale data. 
  </P>
  <LI>
  <P>The <TT class=literal>Session</TT> is <SPAN 
  class=emphasis><EM>not</EM></SPAN> threadsafe! Never access the same <TT 
  class=literal>Session</TT> in two concurrent threads. A <TT 
  class=literal>Session</TT> is usually only a single unit-of-work! 
</P></LI></UL></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=transactions-identity></A>10.3.&nbsp;Considering object 
identity</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>The application may concurrently access the same persistent state in two 
different units-of-work. However, an instance of a persistent class is never 
shared between two <TT class=literal>Session</TT> instances. Hence there are two 
different notions of identity: </P>
<DIV class=variablelist>
<DL>
  <DT><SPAN class=term>Database Identity</SPAN>
  <DD>
  <P><TT class=literal>foo.getId().equals( bar.getId() )</TT> </P>
  <DT><SPAN class=term>JVM Identity</SPAN>
  <DD>
  <P><TT class=literal>foo==bar</TT> </P></DD></DL></DIV>
<P>Then for objects attached to a <SPAN 
class=emphasis><EM>particular</EM></SPAN> <TT class=literal>Session</TT>, the 
two notions are equivalent. However, while the application might concurrently 
access the "same" (persistent identity) business object in two different 
sessions, the two instances will actually be "different" (JVM identity). </P>
<P>This approach leaves Hibernate and the database to worry about concurrency. 
The application never needs to synchronize on any business object, as long as it 
sticks to a single thread per <TT class=literal>Session</TT> or object identity 
(within a <TT class=literal>Session</TT> the application may safely use <TT 
class=literal>==</TT> to compare objects). </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=transactions-optimistic></A>10.4.&nbsp;Optimistic concurrency 
control</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Many business processes require a whole series of interactions with the user 
interleaved with database accesses. In web and enterprise applications it is not 
acceptable for a database transaction to span a user interaction. </P>
<P>Maintaining isolation of business processes becomes the partial 
responsibility of the application tier, hence we call this process a long 
running <SPAN class=emphasis><EM>application transaction</EM></SPAN>. A single 
application transaction usually spans several database transactions. It will be 
atomar if only one of these database transactions (the last one) stores the 
updated data, all others simply read data. </P>
<P>The only approach that is consistent with high concurrency and high 
scalability is optimistic concurrency control with versioning. Hibernate 
provides for three possible approaches to writing application code that uses 
optimistic concurrency. </P>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=transactions-optimistic-longsession></A>10.4.1.&nbsp;Long session with 
automatic versioning</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>A single <TT class=literal>Session</TT> instance and its persistent instances 
are used for the whole application transaction. </P>
<P>The <TT class=literal>Session</TT> uses optimistic locking with versioning to 
ensure that many database transactions appear to the application as a single 
logical application transaction. The <TT class=literal>Session</TT> is 
disconnected from any underlying JDBC connection when waiting for user 
interaction. This approach is the most efficient in terms of database access. 
The application need not concern itself with version checking or with 
reattaching detached instances. </P><PRE class=programlisting>// foo is an instance loaded earlier by the Session
session.reconnect();
foo.setProperty("bar");
session.flush();
session.connection().commit();
session.disconnect();</PRE>
<P>The <TT class=literal>foo</TT> object still knows which <TT 
class=literal>Session</TT> it was loaded it. As soon as the <TT 
class=literal>Session</TT> has a JDBC connection, we commit the changes to the 
object. </P>
<P>This pattern is problematic if our <TT class=literal>Session</TT> is too big 
to be stored during user think time, e.g. an <TT class=literal>HttpSession</TT> 
should be kept as small as possible. As the <TT class=literal>Session</TT> is 
also the (mandatory) first-level cache and contains all loaded objects, we can 
propably use this strategy only for a few request/response cycles. This is 
indeed recommended, as the <TT class=literal>Session</TT> will soon also have 
stale data. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=transactions-optimistic-detached></A>10.4.2.&nbsp;Many 
sessions with automatic versioning</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>Each interaction with the persistent store occurs in a new <TT 
class=literal>Session</TT>. However, the same persistent instances are reused 
for each interaction with the database. The application manipulates the state of 
detached instances originally loaded in another <TT class=literal>Session</TT> 
and then "reassociates" them using <TT class=literal>Session.update()</TT> or 
<TT class=literal>Session.saveOrUpdate()</TT>. </P><PRE class=programlisting>// foo is an instance loaded by a previous Session
foo.setProperty("bar");
session = factory.openSession();
session.saveOrUpdate(foo);
session.flush();
session.connection().commit();
session.close();</PRE>
<P>You may also call <TT class=literal>lock()</TT> instead of <TT 
class=literal>update()</TT> and use <TT class=literal>LockMode.READ</TT> 
(performing a version check, bypassing all caches) if you are sure that the 
object has not been modified. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=transactions-optimistic-manual></A>10.4.3.&nbsp;Application version 
checking</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>Each interaction with the database occurs in a new <TT 
class=literal>Session</TT> that reloads all persistent instances from the 
database before manipulating them. This approach forces the application to carry 
out its own version checking to ensure application transaction isolation. (Of 
course, Hibernate will still <SPAN class=emphasis><EM>update</EM></SPAN> version 
numbers for you.) This approach is the least efficient in terms of database 
access. It is the approach most similar to entity EJBs. </P><PRE class=programlisting>// foo is an instance loaded by a previous Session
session = factory.openSession();
int oldVersion = foo.getVersion();
session.load( foo, foo.getKey() );
if ( oldVersion!=foo.getVersion ) throw new StaleObjectStateException();
foo.setProperty("bar");
session.flush();
session.connection().commit();
session.close();</PRE>
<P>Of course, if you are operating in a low-data-concurrency environment and 
don't require version checking, you may use this approach and just skip the 
version check. </P></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=transactions-disconnection></A>10.5.&nbsp;Session 
disconnection</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>The first approach described above is to maintain a single <TT 
class=literal>Session</TT> for a whole business process thats spans user think 
time. (For example, a servlet might keep a <TT class=literal>Session</TT> in the 
user's <TT class=literal>HttpSession</TT>.) For performance reasons you should 
</P>
<DIV class=orderedlist>
<OL type=1 compact>
  <LI>
  <P>commit the <TT class=literal>Transaction</TT> (or JDBC connection) and then 
  </P>
  <LI>
  <P>disconnect the <TT class=literal>Session</TT> from the JDBC connection 
  </P></LI></OL></DIV>
<P>before waiting for user activity. The method <TT 
class=literal>Session.disconnect()</TT> will disconnect the session from the 
JDBC connection and return the connection to the pool (unless you provided the 
connection). </P>
<P><TT class=literal>Session.reconnect()</TT> obtains a new connection (or you 
may supply one) and restarts the session. After reconnection, to force a version 
check on data you aren't updating, you may call <TT 
class=literal>Session.lock()</TT> on any objects that might have been updated by 
another transaction. You don't need to lock any data that you <SPAN 
class=emphasis><EM>are</EM></SPAN> updating. </P>
<P>Heres an example: </P><PRE class=programlisting>SessionFactory sessions;
List fooList;
Bar bar;
....
Session s = sessions.openSession();

Transaction tx = null;
try {
    tx = s.beginTransaction();

    fooList = s.find(
    	"select foo from eg.Foo foo where foo.Date = current date"
        // uses db2 date function
    );
    bar = (Bar) s.create(Bar.class);

    tx.commit();
}
catch (Exception e) {
    if (tx!=null) tx.rollback();
    s.close();
    throw e;
}
s.disconnect();</PRE>
<P>Later on: </P><PRE class=programlisting>s.reconnect();

try {
    tx = s.beginTransaction();

    bar.setFooTable( new HashMap() );
    Iterator iter = fooList.iterator();
    while ( iter.hasNext() ) {
        Foo foo = (Foo) iter.next();
        s.lock(foo, LockMode.READ);    //check that foo isn't stale
        bar.getFooTable().put( foo.getName(), foo );
    }

    tx.commit();
}
catch (Exception e) {
    if (tx!=null) tx.rollback();
    throw e;
}
finally {
    s.close();
}</PRE>
<P>You can see from this how the relationship between <TT 
class=literal>Transaction</TT>s and <TT class=literal>Session</TT>s is 
many-to-one, A <TT class=literal>Session</TT> represents a conversation between 
the application and the database. The <TT class=literal>Transaction</TT> breaks 
that conversation up into atomic units of work at the database level. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=transactions-locking></A>10.6.&nbsp;Pessimistic Locking</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>It is not intended that users spend much time worring about locking 
strategies. Its usually enough to specify an isolation level for the JDBC 
connections and then simply let the database do all the work. However, advanced 
users may sometimes wish to obtain exclusive pessimistic locks, or re-obtain 
locks at the start of a new transaction. </P>
<P>Hibernate will always use the locking mechanism of the database, never lock 
objects in memory! </P>
<P>The <TT class=literal>LockMode</TT> class defines the different lock levels 
that may be acquired by Hibernate. A lock is obtained by the following 
mechanisms: </P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P><TT class=literal>LockMode.WRITE</TT> is acquired automatically when 
  Hibernate updates or inserts a row. </P>
  <LI>
  <P><TT class=literal>LockMode.UPGRADE</TT> may be acquired upon explicit user 
  request using <TT class=literal>SELECT ... FOR UPDATE</TT> on databases which 
  support that syntax. </P>
  <LI>
  <P><TT class=literal>LockMode.UPGRADE_NOWAIT</TT> may be acquired upon 
  explicit user request using a <TT class=literal>SELECT ... FOR UPDATE 
  NOWAIT</TT> under Oracle. </P>
  <LI>
  <P><TT class=literal>LockMode.READ</TT> is acquired automatically when 
  Hibernate reads data under Repeatable Read or Serializable isolation level. 
  May be re-acquired by explicit user request. </P>
  <LI>
  <P><TT class=literal>LockMode.NONE</TT> represents the absence of a lock. All 
  objects switch to this lock mode at the end of a <TT 
  class=literal>Transaction</TT>. Objects associated with the session via a call 
  to <TT class=literal>update()</TT> or <TT class=literal>saveOrUpdate()</TT> 
  also start out in this lock mode. </P></LI></UL></DIV>
<P>The "explicit user request" is expressed in one of the following ways: </P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P>A call to <TT class=literal>Session.load()</TT>, specifying a <TT 
  class=literal>LockMode</TT>. </P>
  <LI>
  <P>A call to <TT class=literal>Session.lock()</TT>. </P>
  <LI>
  <P>A call to <TT class=literal>Query.setLockMode()</TT>. </P></LI></UL></DIV>
<P>If <TT class=literal>Session.load()</TT> is called with <TT 
class=literal>UPGRADE</TT> or <TT class=literal>UPGRADE_NOWAIT</TT>, and the 
requested object was not yet loaded by the session, the object is loaded using 
<TT class=literal>SELECT ... FOR UPDATE</TT>. If <TT class=literal>load()</TT> 
is called for an object that is already loaded with a less restrictive lock than 
the one requested, Hibernate calls <TT class=literal>lock()</TT> for that 
object. </P>
<P><TT class=literal>Session.lock()</TT> performs a version number check if the 
specified lock mode is <TT class=literal>READ</TT>, <TT 
class=literal>UPGRADE</TT> or <TT class=literal>UPGRADE_NOWAIT</TT>. (In the 
case of <TT class=literal>UPGRADE</TT> or <TT class=literal>UPGRADE_NOWAIT</TT>, 
<TT class=literal>SELECT ... FOR UPDATE</TT> is used.) </P>
<P>If the database does not support the requested lock mode, Hibernate will use 
an appropriate alternate mode (instead of throwing an exception). This ensures 
that applications will be portable. </P></DIV></DIV>
<DIV class=chapter lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A name=queryhql></A>Chapter&nbsp;11.&nbsp;HQL: The Hibernate 
Query Language</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Hibernate is equiped with an extremely powerful query language that (quite 
intentionally) looks very much like SQL. But don't be fooled by the syntax; HQL 
is fully object-oriented, understanding notions like inheritence, polymorphism 
and association. </P>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=queryhql-casesensitivity></A>11.1.&nbsp;Case Sensitivity</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Queries are case-insensitive, except for names of Java classes and 
properties. So <TT class=literal>SeLeCT</TT> is the same as <TT 
class=literal>sELEct</TT> is the same as <TT class=literal>SELECT</TT> but <TT 
class=literal>net.sf.hibernate.eg.FOO</TT> is not <TT 
class=literal>net.sf.hibernate.eg.Foo</TT> and <TT class=literal>foo.barSet</TT> 
is not <TT class=literal>foo.BARSET</TT>. </P>
<P>This manual uses lowercase HQL keywords. Some users find queries with 
uppercase keywords more readable, but we find this convention ugly when embedded 
in Java code. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=queryhql-from></A>11.2.&nbsp;The 
from clause</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>The simplest possible Hibernate query is of the form: </P><PRE class=programlisting>from eg.Cat</PRE>
<P>which simply returns all instances of the class <TT 
class=literal>eg.Cat</TT>. </P>
<P>Most of the time, you will need to assign an <SPAN 
class=emphasis><EM>alias</EM></SPAN>, since you will want to refer to the <TT 
class=literal>Cat</TT> in other parts of the query. </P><PRE class=programlisting>from eg.Cat as cat</PRE>
<P>This query assigns the alias <TT class=literal>cat</TT> to <TT 
class=literal>Cat</TT> instances, so we could use that alias later in the query. 
The <TT class=literal>as</TT> keyword is optional; we could also write: </P><PRE class=programlisting>from eg.Cat cat</PRE>
<P>Multiple classes may appear, resulting in a cartesian product or "cross" 
join. </P><PRE class=programlisting>from Formula, Parameter</PRE><PRE class=programlisting>from Formula as form, Parameter as param</PRE>
<P>It is considered good practice to name query aliases using an initial 
lowercase, consistent with Java naming standards for local variables (eg. <TT 
class=literal>domesticCat</TT>). </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=queryhql-joins></A>11.3.&nbsp;Associations and joins</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>We may also assign aliases to associated entities, or even to elements of a 
collection of values, using a <TT class=literal>join</TT>. </P><PRE class=programlisting>from eg.Cat as cat 
    inner join cat.mate as mate
    left outer join cat.kittens as kitten

from eg.Cat as cat left join cat.mate.kittens as kittens

from Formula form full join form.parameter param</PRE>
<P>The supported join types are borrowed from ANSI SQL </P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P><TT class=literal>inner join</TT> </P>
  <LI>
  <P><TT class=literal>left outer join</TT> </P>
  <LI>
  <P><TT class=literal>right outer join</TT> </P>
  <LI>
  <P><TT class=literal>full join</TT> (not usually useful) </P></LI></UL></DIV>
<P>The <TT class=literal>inner join</TT>, <TT class=literal>left outer join</TT> 
and <TT class=literal>right outer join</TT> constructs may be abbreviated. </P><PRE class=programlisting>from eg.Cat as cat 
    join cat.mate as mate
    left join cat.kittens as kitten</PRE>
<P>In addition, a "fetch" join allows associations or collections of values to 
be initialized along with their parent objects, using a single select. This is 
particularly useful in the case of a collection. It effectively overrides the 
outer join and lazy declarations of the mapping file for associations and 
collections. </P><PRE class=programlisting>from eg.Cat as cat 
    inner join fetch cat.mate
    left join fetch cat.kittens</PRE>
<P>A fetch join does not usually need to assign an alias, because the associated 
objects should not be used in the <TT class=literal>where</TT> clause (or any 
other clause). Also, the associated objects are not returned directly in the 
query results. Instead, they may be accessed via the parent object. </P>
<P>Note that, in the current implementation, only one collection role may be 
fetched in a query (everything else would be non-performant). Note also that the 
<TT class=literal>fetch</TT> construct may not be used in queries called using 
<TT class=literal>scroll()</TT> or <TT class=literal>iterate()</TT>. Finally, 
note that <TT class=literal>full join fetch</TT> and <TT class=literal>right 
join fetch</TT> are not meaningful. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=queryhql-select></A>11.4.&nbsp;The 
select clause</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>The <TT class=literal>select</TT> clause picks which objects and properties 
to return in the query result set. Consider: </P><PRE class=programlisting>select mate 
from eg.Cat as cat 
    inner join cat.mate as mate</PRE>
<P>The query will select <TT class=literal>mate</TT>s of other <TT 
class=literal>Cat</TT>s. Actually, you may express this query more compactly as: 
</P><PRE class=programlisting>select cat.mate from eg.Cat cat</PRE>
<P>You may even select collection elements, using the special <TT 
class=literal>elements</TT> function. The following query returns all kittens of 
any cat. </P><PRE class=programlisting>select elements(cat.kittens) from eg.Cat cat</PRE>
<P>Queries may return properties of any value type including properties of 
component type: </P><PRE class=programlisting>select cat.name from eg.DomesticCat cat
where cat.name like 'fri%'

select cust.name.firstName from Customer as cust</PRE>
<P>Queries may return multiple objects and/or properties as an array of type <TT 
class=literal>Object[]</TT> </P><PRE class=programlisting>select mother, offspr, mate.name 
from eg.DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</PRE>
<P>or as an actual typesafe Java object </P><PRE class=programlisting>select new Family(mother, mate, offspr)
from eg.DomesticCat as mother
    join mother.mate as mate
    left join mother.kittens as offspr</PRE>
<P>assuming that the class <TT class=literal>Family</TT> has an appropriate 
constructor. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=queryhql-aggregation></A>11.5.&nbsp;Aggregate functions</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>HQL queries may even return the results of aggregate functions on properties: 
</P><PRE class=programlisting>select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat)
from eg.Cat cat</PRE>
<P>Collections may also appear inside aggregate functions in the <TT 
class=literal>select</TT> clause. </P><PRE class=programlisting>select cat, count( elements(cat.kittens) ) 
from eg.Cat cat group by cat</PRE>
<P>The supported aggregate functions are </P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P><TT class=literal>avg(...), sum(...), min(...), max(...)</TT> </P>
  <LI>
  <P><TT class=literal>count(*)</TT> </P>
  <LI>
  <P><TT class=literal>count(...), count(distinct ...), count(all...)</TT> 
  </P></LI></UL></DIV>
<P>The <TT class=literal>distinct</TT> and <TT class=literal>all</TT> keywords 
may be used and have the same semantics as in SQL. </P><PRE class=programlisting>select distinct cat.name from eg.Cat cat

select count(distinct cat.name), count(cat) from eg.Cat cat</PRE></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=queryhql-polymorphism></A>11.6.&nbsp;Polymorphic queries</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>A query like: </P><PRE class=programlisting>from eg.Cat as cat</PRE>
<P>returns instances not only of <TT class=literal>Cat</TT>, but also of 
subclasses like <TT class=literal>DomesticCat</TT>. Hibernate queries may name 
<SPAN class=emphasis><EM>any</EM></SPAN> Java class or interface in the <TT 
class=literal>from</TT> clause. The query will return instances of all 
persistent classes that extend that class or implement the interface. The 
following query would return all persistent objects: </P><PRE class=programlisting>from java.lang.Object o</PRE>
<P>The interface <TT class=literal>Named</TT> might be implemented by various 
persistent classes: </P><PRE class=programlisting>from eg.Named n, eg.Named m where n.name = m.name</PRE>
<P>Note that these last two queries will require more than one SQL <TT 
class=literal>SELECT</TT>. This means that the <TT class=literal>order by</TT> 
clause does not correctly order the whole result set. (It also means you can't 
call these queries using <TT class=literal>Query.scroll()</TT>.) </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=queryhql-where></A>11.7.&nbsp;The 
where clause</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>The <TT class=literal>where</TT> clause allows you to narrow the list of 
instances returned. </P><PRE class=programlisting>from eg.Cat as cat where cat.name='Fritz'</PRE>
<P>returns instances of <TT class=literal>Cat</TT> named 'Fritz'. </P><PRE class=programlisting>select foo 
from eg.Foo foo, eg.Bar bar
where foo.startDate = bar.date</PRE>
<P>will return all instances of <TT class=literal>Foo</TT> for which there 
exists an instance of <TT class=literal>bar</TT> with a <TT 
class=literal>date</TT> property equal to the <TT class=literal>startDate</TT> 
property of the <TT class=literal>Foo</TT>. Compound path expressions make the 
<TT class=literal>where</TT> clause extremely powerful. Consider: </P><PRE class=programlisting>from eg.Cat cat where cat.mate.name is not null</PRE>
<P>This query translates to an SQL query with a table (inner) join. If you were 
to write something like </P><PRE class=programlisting>from eg.Foo foo  
where foo.bar.baz.customer.address.city is not null</PRE>
<P>you would end up with a query that would require four table joins in SQL. 
</P>
<P>The <TT class=literal>=</TT> operator may be used to compare not only 
properties, but also instances: </P><PRE class=programlisting>from eg.Cat cat, eg.Cat rival where cat.mate = rival.mate

select cat, mate 
from eg.Cat cat, eg.Cat mate
where cat.mate = mate</PRE>
<P>The special property (lowercase) <TT class=literal>id</TT> may be used to 
reference the unique identifier of an object. (You may also use its property 
name.) </P><PRE class=programlisting>from eg.Cat as cat where cat.id = 123

from eg.Cat as cat where cat.mate.id = 69</PRE>
<P>The second query is efficient. No table join is required! </P>
<P>Properties of composite identifiers may also be used. Suppose <TT 
class=literal>Person</TT> has a composite identifier consisting of <TT 
class=literal>country</TT> and <TT class=literal>medicareNumber</TT>. </P><PRE class=programlisting>from bank.Person person
where person.id.country = 'AU' 
    and person.id.medicareNumber = 123456

from bank.Account account
where account.owner.id.country = 'AU' 
    and account.owner.id.medicareNumber = 123456</PRE>
<P>Once again, the second query requires no table join. </P>
<P>Likewise, the special property <TT class=literal>class</TT> accesses the 
discriminator value of an instance in the case of polymorphic persistence. A 
Java class name embedded in the where clause will be translated to its 
discriminator value. </P><PRE class=programlisting>from eg.Cat cat where cat.class = eg.DomesticCat</PRE>
<P>You may also specify properties of components or composite user types (and of 
components of components, etc). Never try to use a path-expression that ends in 
a property of component type (as opposed to a property of a component). For 
example, if <TT class=literal>store.owner</TT> is an entity with a component <TT 
class=literal>address</TT> </P><PRE class=programlisting>store.owner.address.city    // okay
store.owner.address         // error!</PRE>
<P>An "any" type has the special properties <TT class=literal>id</TT> and <TT 
class=literal>class</TT>, allowing us to express a join in the following way 
(where <TT class=literal>AuditLog.item</TT> is a property mapped with <TT 
class=literal>&lt;any&gt;</TT>). </P><PRE class=programlisting>from eg.AuditLog log, eg.Payment payment 
where log.item.class = 'eg.Payment' and log.item.id = payment.id</PRE>
<P>Notice that <TT class=literal>log.item.class</TT> and <TT 
class=literal>payment.class</TT> would refer to the values of completely 
different database columns in the above query. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=queryhql-expressions></A>11.8.&nbsp;Expressions</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Expressions allowed in the <TT class=literal>where</TT> clause include most 
of the kind of things you could write in SQL: </P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P>mathematical operators <TT class=literal>+, -, *, /</TT> </P>
  <LI>
  <P>binary comparison operators <TT class=literal>=, &gt;=, &lt;=, &lt;&gt;, 
  !=, like</TT> </P>
  <LI>
  <P>logical operations <TT class=literal>and, or, not</TT> </P>
  <LI>
  <P>string concatenation || </P>
  <LI>
  <P>SQL scalar functions like <TT class=literal>upper()</TT> and <TT 
  class=literal>lower()</TT> </P>
  <LI>
  <P>Parentheses <TT class=literal>( )</TT> indicate grouping </P>
  <LI>
  <P><TT class=literal>in</TT>, <TT class=literal>between</TT>, <TT 
  class=literal>is null</TT> </P>
  <LI>
  <P>JDBC IN parameters <TT class=literal>?</TT> </P>
  <LI>
  <P>named parameters <TT class=literal>:name</TT>, <TT 
  class=literal>:start_date</TT>, <TT class=literal>:x1</TT> </P>
  <LI>
  <P>SQL literals <TT class=literal>'foo'</TT>, <TT class=literal>69</TT>, <TT 
  class=literal>'1970-01-01 10:00:01.0'</TT> </P>
  <LI>
  <P>Java <TT class=literal>public static final</TT> constants <TT 
  class=literal>eg.Color.TABBY</TT> </P></LI></UL></DIV>
<P><TT class=literal>in</TT> and <TT class=literal>between</TT> may be used as 
follows: </P><PRE class=programlisting>from eg.DomesticCat cat where cat.name between 'A' and 'B'

from eg.DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )</PRE>
<P>and the negated forms may be written </P><PRE class=programlisting>from eg.DomesticCat cat where cat.name not between 'A' and 'B'

from eg.DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )</PRE>
<P>Likewise, <TT class=literal>is null</TT> and <TT class=literal>is not 
null</TT> may be used to test for null values. </P>
<P>Booleans may be easily used in expressions by declaring HQL query 
substitutions in Hibernate configuration: </P><PRE class=programlisting>&lt;property name="hibernate.query.substitutions"&gt;true 1, false 0&lt;/property&gt;</PRE>
<P>This will replace the keywords <TT class=literal>true</TT> and <TT 
class=literal>false</TT> with the literals <TT class=literal>1</TT> and <TT 
class=literal>0</TT> in the translated SQL from this HQL: </P><PRE class=programlisting>from eg.Cat cat where cat.alive = true</PRE>
<P>You may test the size of a collection with the special property <TT 
class=literal>size</TT>, or the special <TT class=literal>size()</TT> function. 
</P><PRE class=programlisting>from eg.Cat cat where cat.kittens.size &gt; 0

from eg.Cat cat where size(cat.kittens) &gt; 0</PRE>
<P>For indexed collections, you may refer to the minimum and maximum indices 
using <TT class=literal>minIndex</TT> and <TT class=literal>maxIndex</TT>. 
Similarly, you may refer to the minimum and maximum elements of a collection of 
basic type using <TT class=literal>minElement</TT> and <TT 
class=literal>maxElement</TT>. </P><PRE class=programlisting>from Calendar cal where cal.holidays.maxElement &gt; current date</PRE>
<P>There are also functional forms (which, unlike the constructs above, are not 
case sensitive): </P><PRE class=programlisting>from Order order where maxindex(order.items) &gt; 100

from Order order where minelement(order.items) &gt; 10000</PRE>
<P>The SQL functions <TT class=literal>any, some, all, exists, in</TT> are 
supported when passed the element or index set of a collection (<TT 
class=literal>elements</TT> and <TT class=literal>indices</TT> functions) or the 
result of a subquery (see below). </P><PRE class=programlisting>select mother from eg.Cat as mother, eg.Cat as kit
where kit in elements(foo.kittens)

select p from eg.NameList list, eg.Person p
where p.name = some elements(list.names)

from eg.Cat cat where exists elements(cat.kittens)

from eg.Player p where 3 &gt; all elements(p.scores)

from eg.Show show where 'fizard' in indices(show.acts)</PRE>
<P>Note that these constructs - <TT class=literal>size</TT>, <TT 
class=literal>elements</TT>, <TT class=literal>indices</TT>, <TT 
class=literal>minIndex</TT>, <TT class=literal>maxIndex</TT>, <TT 
class=literal>minElement</TT>, <TT class=literal>maxElement</TT> - have certain 
usage restrictions: </P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P>in a <TT class=literal>where</TT> clause: only for databases with 
  subselects </P>
  <LI>
  <P>in a <TT class=literal>select</TT> clause: only <TT 
  class=literal>elements</TT> and <TT class=literal>indices</TT> make sense 
  </P></LI></UL></DIV>
<P>Elements of indexed collections (arrays, lists, maps) may be referred to by 
index (in a where clause only): </P><PRE class=programlisting>from Order order where order.items[0].id = 1234

select person from Person person, Calendar calendar
where calendar.holidays['national day'] = person.birthDay
    and person.nationality.calendar = calendar

select item from Item item, Order order
where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11

select item from Item item, Order order
where order.items[ maxindex(order.items) ] = item and order.id = 11</PRE>
<P>The expression inside <TT class=literal>[]</TT> may even be an arithmetic 
expression. </P><PRE class=programlisting>select item from Item item, Order order
where order.items[ size(order.items) - 1 ] = item</PRE>
<P>HQL also provides the built-in <TT class=literal>index()</TT> function, for 
elements of a one-to-many association or collection of values. </P><PRE class=programlisting>select item, index(item) from Order order 
    join order.items item
where index(item) &lt; 5</PRE>
<P>Scalar SQL functions supported by the underlying database may be used </P><PRE class=programlisting>from eg.DomesticCat cat where upper(cat.name) like 'FRI%'</PRE>
<P>If you are not yet convinced by all this, think how much longer and less 
readable the following query would be in SQL: </P><PRE class=programlisting>select cust
from Product prod,
    Store store
    inner join store.customers cust
where prod.name = 'widget'
    and store.location.name in ( 'Melbourne', 'Sydney' )
    and prod = all elements(cust.currentOrder.lineItems)</PRE>
<P><SPAN class=emphasis><EM>Hint:</EM></SPAN> something like </P><PRE class=programlisting>SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order
FROM customers cust,
    stores store,
    locations loc,
    store_customers sc,
    product prod
WHERE prod.name = 'widget'
    AND store.loc_id = loc.id
    AND loc.name IN ( 'Melbourne', 'Sydney' )
    AND sc.store_id = store.id
    AND sc.cust_id = cust.id
    AND prod.id = ALL(
        SELECT item.prod_id
        FROM line_items item, orders o
        WHERE item.order_id = o.id
            AND cust.current_order = o.id
    )</PRE></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=queryhql-ordering></A>11.9.&nbsp;The 
order by clause</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>The list returned by a query may be ordered by any property of a returned 
class or components: </P><PRE class=programlisting>from eg.DomesticCat cat
order by cat.name asc, cat.weight desc, cat.birthdate</PRE>
<P>The optional <TT class=literal>asc</TT> or <TT class=literal>desc</TT> 
indicate ascending or descending order respectively. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=queryhql-grouping></A>11.10.&nbsp;The group by clause</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>A query that returns aggregate values may be grouped by any property of a 
returned class or components: </P><PRE class=programlisting>select cat.color, sum(cat.weight), count(cat) 
from eg.Cat cat
group by cat.color

select foo.id, avg( elements(foo.names) ), max( indices(foo.names) ) 
from eg.Foo foo
group by foo.id</PRE>
<P>Note: You may use the <TT class=literal>elements</TT> and <TT 
class=literal>indices</TT> constructs inside a select clause, even on databases 
with no subselects. </P>
<P>A <TT class=literal>having</TT> clause is also allowed. </P><PRE class=programlisting>select cat.color, sum(cat.weight), count(cat) 
from eg.Cat cat
group by cat.color 
having cat.color in (eg.Color.TABBY, eg.Color.BLACK)</PRE>
<P>SQL functions and aggregate functions are allowed in the <TT 
class=literal>having</TT> and <TT class=literal>order by</TT> clauses, if 
supported by the underlying database (ie. not in MySQL). </P><PRE class=programlisting>select cat
from eg.Cat cat
    join cat.kittens kitten
group by cat
having avg(kitten.weight) &gt; 100
order by count(kitten) asc, sum(kitten.weight) desc</PRE>
<P>Note that neither the <TT class=literal>group by</TT> clause nor the <TT 
class=literal>order by</TT> clause may contain arithmetic expressions. 
</P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=queryhql-subqueries></A>11.11.&nbsp;Subqueries</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>For databases that support subselects, Hibernate supports subqueries within 
queries. A subquery must be surrounded by parentheses (often by an SQL aggregate 
function call). Even correlated subqueries (subqueries that refer to an alias in 
the outer query) are allowed. </P><PRE class=programlisting>from eg.Cat as fatcat 
where fatcat.weight &gt; ( 
    select avg(cat.weight) from eg.DomesticCat cat 
)

from eg.DomesticCat as cat 
where cat.name = some ( 
    select name.nickName from eg.Name as name 
)
    
from eg.Cat as cat 
where not exists ( 
    from eg.Cat as mate where mate.mate = cat 
)

from eg.DomesticCat as cat 
where cat.name not in ( 
    select name.nickName from eg.Name as name 
)</PRE></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=queryhql-examples></A>11.12.&nbsp;HQL examples</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Hibernate queries can be quite powerful and complex. In fact, the power of 
the query language is one of Hibernate's main selling points. Here are some 
example queries very similar to queries that I used on a recent project. Note 
that most queries you will write are much simpler than these! </P>
<P>The following query returns the order id, number of items and total value of 
the order for all unpaid orders for a particular customer and given minimum 
total value, ordering the results by total value. In determining the prices, it 
uses the current catalog. The resulting SQL query, against the <TT 
class=literal>ORDER</TT>, <TT class=literal>ORDER_LINE</TT>, <TT 
class=literal>PRODUCT</TT>, <TT class=literal>CATALOG</TT> and <TT 
class=literal>PRICE</TT> tables has four inner joins and an (uncorrelated) 
subselect. </P><PRE class=programlisting>select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog.effectiveDate &lt; sysdate
    and catalog.effectiveDate &gt;= all (
        select cat.effectiveDate 
        from Catalog as cat
        where cat.effectiveDate &lt; sysdate
    )
group by order
having sum(price.amount) &gt; :minAmount
order by sum(price.amount) desc</PRE>
<P>What a monster! Actually, in real life, I'm not very keen on subqueries, so 
my query was really more like this: </P><PRE class=programlisting>select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog = :currentCatalog
group by order
having sum(price.amount) &gt; :minAmount
order by sum(price.amount) desc</PRE>
<P>The next query counts the number of payments in each status, excluding all 
payments in the <TT class=literal>AWAITING_APPROVAL</TT> status where the most 
recent status change was made by the current user. It translates to an SQL query 
with two inner joins and a correlated subselect against the <TT 
class=literal>PAYMENT</TT>, <TT class=literal>PAYMENT_STATUS</TT> and <TT 
class=literal>PAYMENT_STATUS_CHANGE</TT> tables. </P><PRE class=programlisting>select count(payment), status.name 
from Payment as payment 
    join payment.currentStatus as status
    join payment.statusChanges as statusChange
where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL
    or (
        statusChange.timeStamp = ( 
            select max(change.timeStamp) 
            from PaymentStatusChange change 
            where change.payment = payment
        )
        and statusChange.user &lt;&gt; :currentUser
    )
group by status.name, status.sortOrder
order by status.sortOrder</PRE>
<P>If I would have mapped the <TT class=literal>statusChanges</TT> collection as 
a list, instead of a set, the query would have been much simpler to write. </P><PRE class=programlisting>select count(payment), status.name 
from Payment as payment
    join payment.currentStatus as status
where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL
    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user &lt;&gt; :currentUser
group by status.name, status.sortOrder
order by status.sortOrder</PRE>
<P>The next query uses the MS SQL Server <TT class=literal>isNull()</TT> 
function to return all the accounts and unpaid payments for the organization to 
which the current user belongs. It translates to an SQL query with three inner 
joins, an outer join and a subselect against the <TT class=literal>ACCOUNT</TT>, 
<TT class=literal>PAYMENT</TT>, <TT class=literal>PAYMENT_STATUS</TT>, <TT 
class=literal>ACCOUNT_TYPE</TT>, <TT class=literal>ORGANIZATION</TT> and <TT 
class=literal>ORG_USER</TT> tables. </P><PRE class=programlisting>select account, payment
from Account as account
    left outer join account.payments as payment
where :currentUser in elements(account.holder.users)
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</PRE>
<P>For some databases, we would need to do away with the (correlated) subselect. 
</P><PRE class=programlisting>select account, payment
from Account as account
    join account.holder.users as user
    left outer join account.payments as payment
where :currentUser = user
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</PRE></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=queryhql-tipstricks></A>11.13.&nbsp;Tips &amp; Tricks</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>You can count the number of query results without actually returning them: 
</P><PRE class=programlisting>( (Integer) session.iterate("select count(*) from ....").next() ).intValue()</PRE>
<P>To order a result by the size of a collection, use the following query: </P><PRE class=programlisting>select usr.id, usr.name
from User as usr 
    left join usr.messages as msg
group by usr.id, usr.name
order by count(msg)</PRE>
<P>If your database supports subselects, you can place a condition upon 
selection size in the where clause of your query: </P><PRE class=programlisting>from User usr where size(usr.messages) &gt;= 1</PRE>
<P>If your database doesn't support subselects, use the following query: </P><PRE class=programlisting>select usr.id, usr.name
from User usr.name
    join usr.messages msg
group by usr.id, usr.name
having count(msg) &gt;= 1</PRE>
<P>As this solution can't return a <TT class=literal>User</TT> with zero 
messages because of the inner join, the following form is also useful: </P><PRE class=programlisting>select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
having count(msg) = 0</PRE>
<P>Properties of a JavaBean can be bound to named query parameters: </P><PRE class=programlisting>Query q = s.createQuery("from foo in class Foo where foo.name=:name and foo.size=:size");
q.setProperties(fooBean); // fooBean has getName() and getSize()
List foos = q.list();</PRE>
<P>Collections are pageable by using the <TT class=literal>Query</TT> interface 
with a filter: </P><PRE class=programlisting>Query q = s.createFilter( collection, "" ); // the trivial filter
q.setMaxResults(PAGE_SIZE);
q.setFirstResult(PAGE_SIZE * pageNumber);
List page = q.list();</PRE>
<P>Collection elements may be ordered or grouped using a query filter: </P><PRE class=programlisting>Collection orderedCollection = s.filter( collection, "order by this.amount" );
Collection counts = s.filter( collection, "select this.type, count(this) group by this.type" );</PRE>
<P>You can find the size of a collection without initializing it: </P><PRE class=programlisting>( (Integer) session.iterate("select count(*) from ....").next() ).intValue();</PRE></DIV></DIV>
<DIV class=chapter lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A name=querycriteria></A>Chapter&nbsp;12.&nbsp;Criteria 
Queries</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Hibernate now features an intuitive, extensible criteria query API. For now, 
this API is less powerful and than the more mature HQL query facilities. In 
particular, criteria queries do not support projection or aggregation. </P>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=querycriteria-creating></A>12.1.&nbsp;Creating a <TT 
class=literal>Criteria</TT> instance</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>The interface <TT class=literal>net.sf.hibernate.Criteria</TT> represents a 
query against a particular persistent class. The <TT class=literal>Session</TT> 
is a factory for <TT class=literal>Criteria</TT> instances. </P><PRE class=programlisting>Criteria crit = sess.createCriteria(Cat.class);
crit.setMaxResults(50);
List cats = crit.list();</PRE></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=querycriteria-narrowing></A>12.2.&nbsp;Narrowing the result 
set</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>An individual query criterion is an instance of the interface <TT 
class=literal>net.sf.hibernate.expression.Criterion</TT>. The class <TT 
class=literal>net.sf.hibernate.expression.Expression</TT> defines factory 
methods for obtaining certain built-in <TT class=literal>Criterion</TT> types. 
</P><PRE class=programlisting>List cats = sess.createCriteria(Cat.class)
    .add( Expression.like("name", "Fritz%") )
    .add( Expression.between("weight", minWeight, maxWeight) )
    .list();</PRE>
<P>Expressions may be grouped logically. </P><PRE class=programlisting>List cats = sess.createCriteria(Cat.class)
    .add( Expression.like("name", "Fritz%") )
    .add( Expression.or(
        Expression.eq( "age", new Integer(0) ),
        Expression.isNull("age")
    ) )
    .list();</PRE><PRE class=programlisting>List cats = sess.createCriteria(Cat.class)
    .add( Expression.in( "name", new String[] { "Fritz", "Izi", "Pk" } ) )
    .add( Expression.disjunction()
        .add( Expression.isNull("age") )
    	.add( Expression.eq("age", new Integer(0) ) )
    	.add( Expression.eq("age", new Integer(1) ) )
    	.add( Expression.eq("age", new Integer(2) ) )
    ) )
    .list();</PRE>
<P>There are quite a range of built-in criterion types (<TT 
class=literal>Expression</TT> subclasses), but one that is especially useful 
lets you specify SQL directly. </P><PRE class=programlisting>List cats = sess.createCriteria(Cat.class)
    .add( Expression.sql("lower({alias}.name) like lower(?)", "Fritz%", Hibernate.STRING) )
    .list();</PRE>
<P>The <TT class=literal>{alias}</TT> placeholder with be replaced by the row 
alias of the queried entity. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=querycriteria-ordering></A>12.3.&nbsp;Ordering the results</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>You may order the results using <TT 
class=literal>net.sf.hibernate.expression.Order</TT>. </P><PRE class=programlisting>List cats = sess.createCriteria(Cat.class)
    .add( Expression.like("name", "F%")
    .addOrder( Order.asc("name") )
    .addOrder( Order.desc("age") )
    .setMaxResults(50)
    .list();</PRE></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=querycriteria-associations></A>12.4.&nbsp;Associations</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>You may easily specify constraints upon related entities by navigating 
associations using <TT class=literal>createCriteria()</TT>. </P><PRE class=programlisting>List cats = sess.createCriteria(Cat.class)
    .add( Expression.like("name", "F%")
    .createCriteria("kittens")
        .add( Expression.like("name", "F%")
    .list();</PRE>
<P>note that the second <TT class=literal>createCriteria()</TT> returns a new 
instance of <TT class=literal>Criteria</TT>, which refers to the elements of the 
<TT class=literal>kittens</TT> collection. </P>
<P>The following, alternate form is useful in certain circumstances. </P><PRE class=programlisting>List cats = sess.createCriteria(Cat.class)
    .createAlias("kittens", "kt")
    .createAlias("mate", "mt")
    .add( Expression.eqProperty("kt.name", "mt.name") )
    .list();</PRE>
<P>(<TT class=literal>createAlias()</TT> does not create a new instance of <TT 
class=literal>Criteria</TT>.) </P>
<P>Note that the kittens collections held by the <TT class=literal>Cat</TT> 
instances returned by the previous two queries are <SPAN 
class=emphasis><EM>not</EM></SPAN> pre-filtered by the criteria! If you wish to 
retrieve just the kittens that match the criteria, you must use <TT 
class=literal>returnMaps()</TT>. </P><PRE class=programlisting>List cats = sess.createCriteria(Cat.class)
    .createCriteria("kittens", "kt")
        .add( Expression.eq("name", "F%") )
    .returnMaps()
    .list();
Iterator iter = cats.iterator();
while ( iter.hasNext() ) {
    Map map = (Map) iter.next();
    Cat cat = (Cat) map.get(Criteria.ROOT_ALIAS);
    Cat kitten = (Cat) map.get("kt");
}</PRE></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=querycriteria-dynamicfetching></A>12.5.&nbsp;Dynamic association 
fetching</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>You may specify association fetching semantics at runtime using <TT 
class=literal>setFetchMode()</TT>. </P><PRE class=programlisting>List cats = sess.createCriteria(Cat.class)
    .add( Expression.like("name", "Fritz%") )
    .setFetchMode("mate", FetchMode.EAGER)
    .setFetchMode("kittens", FetchMode.EAGER)
    .list();</PRE>
<P>This query will fetch both <TT class=literal>mate</TT> and <TT 
class=literal>kittens</TT> by outer join. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=querycriteria-examples></A>12.6.&nbsp;Example queries</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>The class <TT class=literal>net.sf.hibernate.expression.Example</TT> allows 
you to construct a query criterion from a given instance. </P><PRE class=programlisting>Cat cat = new Cat();
cat.setSex('F');
cat.setColor(Color.BLACK);
List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .list();</PRE>
<P>Version properties, identifiers and associations are ignored. By default, 
null valued properties are excluded. </P>
<P>You can adjust how the <TT class=literal>Example</TT> is applied. </P><PRE class=programlisting>Example example = Example.create(cat)
    .excludeZeroes()           //exclude zero valued properties
    .excludeProperty("color")  //exclude the property named "color"
    .ignoreCase()              //perform case insensitive string comparisons
    .enableLike();             //use like for string comparisons
List results = session.createCriteria(Cat.class)
    .add(example)
    .list();</PRE>
<P>You can even use examples to place criteria upon associated objects. </P><PRE class=programlisting>List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .createCriteria("mate")
        .add( Example.create( cat.getMate() ) )
    .list();</PRE></DIV></DIV>
<DIV class=chapter lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A name=querysql></A>Chapter&nbsp;13.&nbsp;Native SQL 
Queries</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>You may also express queries in the native SQL dialect of your database. This 
is useful if you want to utilize database specific features such as the CONNECT 
keyword in Oracle. This also allows for a cleaner migration path from a direct 
SQL/JDBC based application to Hibernate. </P>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=querysql-creating></A>13.1.&nbsp;Creating a SQL based <TT 
class=literal>Query</TT></H2></DIV></DIV>
<DIV></DIV></DIV>
<P>SQL queries are exposed through the same <TT class=literal>Query</TT> 
interface, just like ordinary HQL queries. The only difference is the use of <TT 
class=literal>Session.createSQLQuery()</TT>. </P><PRE class=programlisting>Query sqlQuery = sess.createSQLQuery("select {cat.*} from cats {cat}", "cat", Cat.class);
sqlQuery.setMaxResults(50);
List cats = sqlQuery.list();</PRE>
<P>The three parameters provided to <TT class=literal>createSQLQuery()</TT> are: 
</P>
<DIV class=itemizedlist>
<UL type=disc>
  <LI>
  <P>the SQL query string </P>
  <LI>
  <P>a table alias name </P>
  <LI>
  <P>the persistent class returned by the query </P></LI></UL></DIV>
<P>The alias name is used inside the sql string to refer to the properties of 
the mapped class (in this case <TT class=literal>Cat</TT>). You may retrieve 
multiple objects per row by supplying a <TT class=literal>String</TT> array of 
alias names and a <TT class=literal>Class</TT> array of corresponding classes. 
</P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=querysql-aliasreferences></A>13.2.&nbsp;Alias and property 
references</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>The <TT class=literal>{cat.*}</TT> notation used above is a shorthand for 
"all properties". You may even list the properties explicity, but you must let 
Hibernate provide SQL column aliases for each property. The placeholders for 
these column aliases are the property name qualified by the table alias. In the 
following example, we retrieve <TT class=literal>Cat</TT>s from a different 
table (<TT class=literal>cat_log</TT>) to the one declared in the mapping 
metadata. Notice that we may even use the property aliases in the where clause. 
</P><PRE class=programlisting>String sql = "select cat.originalId as {cat.id}, "
    + "  cat.mateid as {cat.mate}, cat.sex as {cat.sex}, "
    + "  cat.weight*10 as {cat.weight}, cat.name as {cat.name}"
    + "     from cat_log cat where {cat.mate} = :catId"
List loggedCats = sess.createSQLQuery(sql, "cat", Cat.class)
    .setLong("catId", catId)
    .list();
</PRE>
<P><SPAN class=emphasis><EM>Note:</EM></SPAN> if you list each property 
explicitly, you must include all properties of the class <SPAN 
class=emphasis><EM>and its subclasses</EM></SPAN>! </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=querysql-namedqueries></A>13.3.&nbsp;Named SQL queries</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Named SQL queries may be defined in the mapping document and called in 
exactly the same way as a named HQL query. </P><PRE class=programlisting>List people = sess.getNamedQuery("mySqlQuery")
    .setMaxResults(50)
    .list();</PRE><PRE class=programlisting>&lt;sql-query name="mySqlQuery"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    SELECT {person}.NAME AS {person.name},
           {person}.AGE AS {person.age},
           {person}.SEX AS {person.sex}
    FROM PERSON {person} WHERE {person}.NAME LIKE 'Hiber%'
&lt;/sql-query&gt;</PRE></DIV></DIV>
<DIV class=chapter lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A name=performance></A>Chapter&nbsp;14.&nbsp;Improving 
performance</H2></DIV></DIV>
<DIV></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=performance-collections></A>14.1.&nbsp;Understanding Collection 
performance</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>We've already spent quite some time talking about collections. In this 
section we will highlight a couple more issues about how collections behave at 
runtime. </P>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=performance-collections-taxonomy></A>14.1.1.&nbsp;Taxonomy</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>Hibernate defines three basic kinds of collections:</P>
<DIV class=itemizedlist>
<UL type=disc>
  <LI>
  <P>collections of values</P>
  <LI>
  <P>one to many associations</P>
  <LI>
  <P>many to many associations</P></LI></UL></DIV>
<P>This classification distinguishes the various table and foreign key 
relationships but does not tell us quite everything we need to know about the 
relational model. To fully understand the relational structure and performance 
characteristics, we must also consider the structure of the primary key that is 
used by Hibernate to update or delete collection rows. This suggests the 
following classification: </P>
<DIV class=itemizedlist>
<UL type=disc>
  <LI>
  <P>indexed collections</P>
  <LI>
  <P>sets</P>
  <LI>
  <P>bags</P></LI></UL></DIV>
<P>All indexed collections (maps, lists, arrays) have a primary key consisting 
of the <TT class=literal>&lt;key&gt;</TT> and <TT 
class=literal>&lt;index&gt;</TT> columns. In this case collection updates are 
usually extremely efficient - the primary key may be efficiently indexed and a 
particular row may be efficiently located when Hibernate tries to update or 
delete it. </P>
<P>Sets have a primary key consisting of <TT class=literal>&lt;key&gt;</TT> and 
element columns. This may be less efficient for some types of collection 
element, particularly composite elements or large text or binary fields; the 
database may not be able to index a complex primary key as efficently. On the 
other hand, for one to many or many to many associations, particularly in the 
case of synthetic identifiers, it is likely to be just as efficient. (Side-note: 
if you want <TT class=literal>SchemaExport</TT> to actually create the primary 
key of a <TT class=literal>&lt;set&gt;</TT> for you, you must declare all 
columns as <TT class=literal>not-null="true"</TT>.) </P>
<P>Bags are the worst case. Since a bag permits duplicate element values and has 
no index column, no primary key may be defined. Hibernate has no way of 
distinguishing between duplicate rows. Hibernate resolves this problem by 
completely removing (in a single <TT class=literal>DELETE</TT>) and recreating 
the collection whenever it changes. This might be very inefficient. </P>
<P>Note that for a one-to-many association, the "primary key" may not be the 
physical primary key of the database table - but even in this case, the above 
classification is still useful. (It still reflects how Hibernate "locates" 
individual rows of the collection.) </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=performance-collections-mostefficientupdate></A>14.1.2.&nbsp;Lists, maps 
and sets are the most efficient collections to update</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>From the discussion above, it should be clear that indexed collections and 
(usually) sets allow the most efficient operation in terms of adding, removing 
and updating elements. </P>
<P>There is, arguably, one more advantage that indexed collections have over 
sets for many to many associations or collections of values. Because of the 
structure of a <TT class=literal>Set</TT>, Hibernate doesn't ever <TT 
class=literal>UPDATE</TT> a row when an element is "changed". Changes to a <TT 
class=literal>Set</TT> always work via <TT class=literal>INSERT</TT> and <TT 
class=literal>DELETE</TT> (of individual rows). Once again, this consideration 
does not apply to one to many associations. </P>
<P>After observing that arrays cannot be lazy, we would conclude that lists, 
maps and sets are the most performant collection types. (With the caveat that a 
set might be less efficient for some collections of values.) </P>
<P>Sets are expected to be the most common kind of collection in Hibernate 
applications. </P>
<P><SPAN class=emphasis><EM>There is an undocumented feature in this release of 
Hibernate. The <TT class=literal>&lt;idbag&gt;</TT> mapping implements bag 
semantics for a collection of values or a many to many association and is more 
efficient that any other style of collection in this case!</EM></SPAN> 
</P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=performance-collections-mostefficentinverse></A>14.1.3.&nbsp;Bags and lists 
are the most efficient inverse collections</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>Just before you ditch bags forever, there is a particular case in which bags 
(and also lists) are much more performant than sets. For a collection with <TT 
class=literal>inverse="true"</TT> (the standard bidirectional one-to-many 
relationship idiom, for example) we can add elements to a bag or list without 
needing to initialize (fetch) the bag elements! This is because <TT 
class=literal>Collection.add()</TT> or <TT 
class=literal>Collection.addAll()</TT> must always return true for a bag or <TT 
class=literal>List</TT> (unlike a <TT class=literal>Set</TT>). This can make the 
following common code much faster. </P><PRE class=programlisting>Parent p = (Parent) sess.load(Parent.class, id);
    Child c = new Child();
    c.setParent(p);
    p.getChildren().add(c);  //no need to fetch the collection!
    sess.flush();</PRE></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=performance-collections-oneshotdelete></A>14.1.4.&nbsp;One shot 
delete</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>Occasionally, deleting collection elements one by one can be extremely 
inefficient. Hibernate isn't completly stupid, so it knows not to do that in the 
case of an newly-empty collection (if you called <TT 
class=literal>list.clear()</TT>, for example). In this case, Hibernate will 
issue a single <TT class=literal>DELETE</TT> and we are done! </P>
<P>Suppose we add a single element to a collection of size twenty and then 
remove two elements. Hibernate will issue one <TT class=literal>INSERT</TT> 
statement and two <TT class=literal>DELETE</TT> statements (unless the 
collection is a bag). This is certainly desirable. </P>
<P>However, suppose that we remove eighteen elements, leaving two and then add 
thee new elements. There are two possible ways to proceed </P>
<DIV class=itemizedlist>
<UL type=disc>
  <LI>
  <P>delete eighteen rows one by one and then insert three rows</P>
  <LI>
  <P>remove the whole collection (in one SQL <TT class=literal>DELETE</TT>) and 
  insert all five current elements (one by one)</P></LI></UL></DIV>
<P>Hibernate isn't smart enough to know that the second option is probably 
quicker in this case. (And it would probably be undesirable for Hibernate to be 
that smart; such behaviour might confuse database triggers, etc.) </P>
<P>Fortunately, you can force this behaviour (ie. the second strategy) at any 
time by discarding (ie. dereferencing) the original collection and returning a 
newly instantiated collection with all the current elements. This can be very 
useful and powerful from time to time. </P></DIV></DIV>
<P>We have already shown how you can use lazy initialization for persistent 
collections in the chapter about collection mappings. A similar effect is 
achievable for ordinary object references, using CGLIB proxies. We have also 
mentioned how Hibernate caches persistent objects at the level of a <TT 
class=literal>Session</TT>. More aggressive caching strategies may be configured 
upon a class-by-class basis. </P>
<P>In the next section, we show you how to use these features, which may be used 
to achieve much higher performance, where necessary. </P>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=performance-proxies></A>14.2.&nbsp;Proxies for Lazy 
Initialization</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Hibernate implements lazy initializing proxies for persistent objects using 
runtime bytecode enhancement (via the excellent CGLIB library). </P>
<P>The mapping file declares a class or interface to use as the proxy interface 
for that class. The recommended approach is to specify the class itself: </P><PRE class=programlisting>&lt;class name="eg.Order" proxy="eg.Order"&gt;</PRE>
<P>The runtime type of the proxies will be a subclass of <TT 
class=literal>Order</TT>. Note that the proxied class must implement a default 
constructor with at least package visibility. </P>
<P>There are some gotchas to be aware of when extending this approach to 
polymorphic classes, eg. </P><PRE class=programlisting>&lt;class name="eg.Cat" proxy="eg.Cat"&gt;
    ......
    &lt;subclass name="eg.DomesticCat" proxy="eg.DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</PRE>
<P>Firstly, instances of <TT class=literal>Cat</TT> will never be castable to 
<TT class=literal>DomesticCat</TT>, even if the underlying instance is an 
instance of <TT class=literal>DomesticCat</TT>. </P><PRE class=programlisting>Cat cat = (Cat) session.load(Cat.class, id);  // instantiate a proxy (does not hit the db)
if ( cat.isDomesticCat() ) {                  // hit the db to initialize the proxy
    DomesticCat dc = (DomesticCat) cat;       // Error!
    ....
}</PRE>
<P>Secondly, it is possible to break proxy <TT class=literal>==</TT>. </P><PRE class=programlisting>Cat cat = (Cat) session.load(Cat.class, id);            // instantiate a Cat proxy
DomesticCat dc = 
    (DomesticCat) session.load(DomesticCat.class, id);  // required new DomesticCat proxy!
System.out.println(cat==dc);                            // false</PRE>
<P>However, the situation is not quite as bad as it looks. Even though we now 
have two references to different proxy objects, the underlying instance will 
still be the same object: </P><PRE class=programlisting>cat.setWeight(11.0);  // hit the db to initialize the proxy
System.out.println( dc.getWeight() );  // 11.0</PRE>
<P>Third, you may not use a CGLIB proxy for a <TT class=literal>final</TT> class 
or a class with any <TT class=literal>final</TT> methods. </P>
<P>Finally, if your persistent object acquires any resources upon instantiation 
(eg. in initializers or default constructor), then those resources will also be 
acquired by the proxy. The proxy class is an actual subclass of the persistent 
class. </P>
<P>These problems are all due to fundamental limitations in Java's single 
inheritence model. If you wish to avoid these problems your persistent classes 
must each implement an interface that declares its business methods. You should 
specify these interfaces in the mapping file. eg. </P><PRE class=programlisting>&lt;class name="eg.Cat" proxy="eg.ICat"&gt;
    ......
    &lt;subclass name="eg.DomesticCat" proxy="eg.IDomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</PRE>
<P>where <TT class=literal>Cat</TT> implements the interface <TT 
class=literal>ICat</TT> and <TT class=literal>DomesticCat</TT> implements the 
interface <TT class=literal>IDomesticCat</TT>. Then proxies for instances of <TT 
class=literal>Cat</TT> and <TT class=literal>DomesticCat</TT> may be returned by 
<TT class=literal>load()</TT> or <TT class=literal>iterate()</TT>. (Note that 
<TT class=literal>find()</TT> does not return proxies.) </P><PRE class=programlisting>ICat cat = (ICat) session.load(Cat.class, catid);
Iterator iter = session.iterate("from cat in class eg.Cat where cat.name='fritz'");
ICat fritz = (ICat) iter.next();</PRE>
<P>Relationships are also lazily initialized. This means you must declare any 
properties to be of type <TT class=literal>ICat</TT>, not <TT 
class=literal>Cat</TT>. </P>
<P>Certain operations do <SPAN class=emphasis><EM>not</EM></SPAN> require proxy 
initialization </P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P><TT class=literal>equals()</TT>, if the persistent class does not override 
  <TT class=literal>equals()</TT> </P>
  <LI>
  <P><TT class=literal>hashCode()</TT>, if the persistent class does not 
  override <TT class=literal>hashCode()</TT> </P>
  <LI>
  <P>The identifier getter method </P></LI></UL></DIV>
<P>Hibernate will detect persistent classes that override <TT 
class=literal>equals()</TT> or <TT class=literal>hashCode()</TT>. </P>
<P>Exceptions that occur while initializing a proxy are wrapped in a <TT 
class=literal>LazyInitializationException</TT>. </P>
<P>Sometimes we need to ensure that a proxy or collection is initialized before 
closing the <TT class=literal>Session</TT>. Of course, we can alway force 
initialization by calling <TT class=literal>cat.getSex()</TT> or <TT 
class=literal>cat.getKittens().size()</TT>, for example. But that is confusing 
to readers of the code and is not convenient for generic code. The static 
methods <TT class=literal>Hibernate.initialize()</TT> and <TT 
class=literal>Hibernate.isInitialized()</TT> provide the application with a 
convenient way of working with lazyily initialized collections or proxies. <TT 
class=literal>Hibernate.initialize(cat)</TT> will force the initialization of a 
proxy, <TT class=literal>cat</TT>, as long as its <TT class=literal>Session</TT> 
is still open. <TT class=literal>Hibernate.initialize( cat.getKittens() )</TT> 
has a similar effect for the collection of kittens. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=performance-cache></A>14.3.&nbsp;The 
Second Level Cache</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>A Hibernate <TT class=literal>Session</TT> is a transaction-level cache of 
persistent data. It is possible to configure a cluster or JVM-level (<TT 
class=literal>SessionFactory</TT>-level) cache on a class-by-class and 
collection-by-collection basis. You may even plug in a clustered cache. Be 
careful. Caches are never aware of changes made to the persistent store by 
another application (though they may be configured to regularly expire cached 
data). </P>
<P>By default, Hibernate uses EHCache for JVM-level caching. (JCS support is now 
deprecated and will be removed in a future version of Hibernate.) You may choose 
a different implementation by specifying the name of a class that implements <TT 
class=literal>net.sf.hibernate.cache.CacheProvider</TT> using the property <TT 
class=literal>hibernate.cache.provider_class</TT>. </P>
<DIV class=table><A name=d0e8645></A>
<P class=title><B>Table&nbsp;14.1.&nbsp;Cache Providers</B></P>
<TABLE summary="Cache Providers" border=1>
  <COLGROUP>
  <COL align=left>
  <COL align=left>
  <COL align=left>
  <COL align=left>
  <COL align=left></COLGROUP>
  <THEAD>
  <TR>
    <TH align=left>Cache</TH>
    <TH align=left>Provider class</TH>
    <TH align=left>Type</TH>
    <TH align=left>Cluster Safe</TH>
    <TH align=left>Query Cache Supported</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD align=left>Hashtable (not intended for production use)</TD>
    <TD align=left><TT 
      class=literal>net.sf.hibernate.cache.HashtableCacheProvider</TT></TD>
    <TD align=left>memory</TD>
    <TD align=left>&nbsp;</TD>
    <TD align=left>yes</TD></TR>
  <TR>
    <TD align=left>EHCache</TD>
    <TD align=left><TT class=literal>net.sf.ehcache.hibernate.Provider</TT></TD>
    <TD align=left>memory, disk</TD>
    <TD align=left>&nbsp;</TD>
    <TD align=left>yes</TD></TR>
  <TR>
    <TD align=left>OSCache</TD>
    <TD align=left><TT 
      class=literal>net.sf.hibernate.cache.OSCacheProvider</TT></TD>
    <TD align=left>memory, disk</TD>
    <TD align=left>&nbsp;</TD>
    <TD align=left>yes</TD></TR>
  <TR>
    <TD align=left>SwarmCache</TD>
    <TD align=left><TT 
      class=literal>net.sf.hibernate.cache.SwarmCacheProvider</TT></TD>
    <TD align=left>clustered (ip multicast)</TD>
    <TD align=left>yes (clustered invalidation)</TD>
    <TD align=left>&nbsp;</TD></TR>
  <TR>
    <TD align=left>JBoss TreeCache</TD>
    <TD align=left><TT 
      class=literal>net.sf.hibernate.cache.TreeCacheProvider</TT></TD>
    <TD align=left>clustered (ip multicast), transactional</TD>
    <TD align=left>yes (replication)</TD>
    <TD align=left>&nbsp;</TD></TR></TBODY></TABLE></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=performance-cache-mapping></A>14.3.1.&nbsp;Cache 
mappings</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>The <TT class=literal>&lt;cache&gt;</TT> element of a class or collection 
mapping has the following form: </P>
<DIV class=programlistingco><PRE class=programlisting>&lt;cache 
    usage="transactional|read-write|nonstrict-read-write|read-only"  <SPAN class=co>(1)</SPAN>
/&gt;</PRE>
<DIV class=calloutlist>
<TABLE summary="Callout list" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="5%">(1)</TD>
    <TD vAlign=top align=left>
      <P><TT class=literal>usage</TT> specifies the caching strategy: <TT 
      class=literal>transactional</TT>, <TT class=literal>read-write</TT>, <TT 
      class=literal>nonstrict-read-write</TT> or <TT 
      class=literal>read-only</TT> </P></TD></TR></TBODY></TABLE></DIV></DIV>
<P>Alternatively (preferrably?), you may specify <TT 
class=literal>&lt;class-cache&gt;</TT> and <TT 
class=literal>&lt;collection-cache&gt;</TT> elements in <TT 
class=literal>hibernate.cfg.xml</TT>. </P>
<P>The <TT class=literal>usage</TT> attribute specifies a <SPAN 
class=emphasis><EM>cache concurrency strategy</EM></SPAN>. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=performance-cache-readonly></A>14.3.2.&nbsp;Strategy: 
read only</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>If your application needs to read but never modify instances of a persistent 
class, a <TT class=literal>read-only</TT> cache may be used. This is the 
simplest and best performing strategy. Its even perfectly safe for use in a 
cluster. </P><PRE class=programlisting>&lt;class name="eg.Immutable" mutable="false"&gt;
    &lt;cache usage="read-only"/&gt;
    ....
&lt;/class&gt;</PRE></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=performance-cache-readwrite></A>14.3.3.&nbsp;Strategy: 
read/write</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>If the application needs to update data, a <TT class=literal>read-write</TT> 
cache might be appropriate. This cache strategy should never be used if 
serializable transaction isolation level is required. If the cache is used in a 
JTA environment, you must specify the property <TT 
class=literal>hibernate.transaction.manager_lookup_class</TT>, naming a strategy 
for obtaining the JTA <TT class=literal>TransactionManager</TT>. In other 
environments, you should ensure that the transaction is completed when <TT 
class=literal>Session.close()</TT> or <TT 
class=literal>Session.disconnect()</TT> is called. If you wish to use this 
strategy in a cluster, you should ensure that the underlying cache 
implementation supports locking. The built-in cache providers do <SPAN 
class=emphasis><EM>not</EM></SPAN>. </P><PRE class=programlisting>&lt;class name="eg.Cat" .... &gt;
    &lt;cache usage="read-write"/&gt;
    ....
    &lt;set name="kittens" ... &gt;
        &lt;cache usage="read-write"/&gt;
        ....
    &lt;/set&gt;
&lt;/class&gt;</PRE></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=performance-cache-nonstrict></A>14.3.4.&nbsp;Strategy: 
nonstrict read/write</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>If the application only occasionally needs to update data (ie. if it is 
extremely unlikely that two transactions would try to update the same item 
simultaneously) and strict transaction isolation is not required, a <TT 
class=literal>nonstrict-read-write</TT> cache might be appropriate. If the cache 
is used in a JTA environment, you must specify <TT 
class=literal>hibernate.transaction.manager_lookup_class</TT>. In other 
environments, you should ensure that the transaction is completed when <TT 
class=literal>Session.close()</TT> or <TT 
class=literal>Session.disconnect()</TT> is called. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=performance-cache-transactional></A>14.3.5.&nbsp;Strategy: 
transactional</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>The <TT class=literal>transactional</TT> cache strategy provides support for 
fully transactional cache providers such as JBoss TreeCache. Such a cache may 
only be used in a JTA environment and you must specify <TT 
class=literal>hibernate.transaction.manager_lookup_class</TT>. </P></DIV>
<P>None of the cache providers support all of the cache concurrency strategies. 
The following table shows which providers are compatible with which concurrency 
strategies. </P>
<DIV class=table><A name=d0e8838></A>
<P class=title><B>Table&nbsp;14.2.&nbsp;Cache Concurrency Strategy 
Support</B></P>
<TABLE summary="Cache Concurrency Strategy Support" border=1>
  <COLGROUP>
  <COL align=left>
  <COL align=left>
  <COL align=left>
  <COL align=left>
  <COL align=left></COLGROUP>
  <THEAD>
  <TR>
    <TH align=left>Cache</TH>
    <TH align=left>read-only</TH>
    <TH align=left>nonstrict-read-write</TH>
    <TH align=left>read-write</TH>
    <TH align=left>transactional</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD align=left>Hashtable (not intended for production use)</TD>
    <TD align=left>yes</TD>
    <TD align=left>yes</TD>
    <TD align=left>yes</TD>
    <TD align=left>&nbsp;</TD></TR>
  <TR>
    <TD align=left>EHCache</TD>
    <TD align=left>yes</TD>
    <TD align=left>yes</TD>
    <TD align=left>yes</TD>
    <TD align=left>&nbsp;</TD></TR>
  <TR>
    <TD align=left>OSCache</TD>
    <TD align=left>yes</TD>
    <TD align=left>yes</TD>
    <TD align=left>yes</TD>
    <TD align=left>&nbsp;</TD></TR>
  <TR>
    <TD align=left>SwarmCache</TD>
    <TD align=left>yes</TD>
    <TD align=left>yes</TD>
    <TD align=left>&nbsp;</TD>
    <TD align=left>&nbsp;</TD></TR>
  <TR>
    <TD align=left>JBoss TreeCache</TD>
    <TD align=left>yes</TD>
    <TD align=left>&nbsp;</TD>
    <TD align=left>&nbsp;</TD>
    <TD align=left>yes</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=performance-sessioncache></A>14.4.&nbsp;Managing the <TT 
class=literal>Session</TT> Cache</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Whenever you pass an object to <TT class=literal>save()</TT>, <TT 
class=literal>update()</TT> or <TT class=literal>saveOrUpdate()</TT> and 
whenever you retrieve an object using <TT class=literal>load()</TT>, <TT 
class=literal>find()</TT>, <TT class=literal>iterate()</TT>, or <TT 
class=literal>filter()</TT>, that object is added to the internal cache of the 
<TT class=literal>Session</TT>. When <TT class=literal>flush()</TT> is 
subsequently called, the state of that object will be synchronized with the 
database. If you do not want this synchronization to occur or if you are 
processing a huge number of objects and need to manage memory efficiently, the 
<TT class=literal>evict()</TT> method may be used to remove the object and its 
collections from the cache. </P><PRE class=programlisting>Iterator cats = sess.iterate("from eg.Cat as cat"); //a huge result set
while ( cats.hasNext() ) {
    Cat cat = (Cat) iter.next();
    doSomethingWithACat(cat);
    sess.evict(cat);
}</PRE>
<P>The <TT class=literal>Session</TT> also provides a <TT 
class=literal>contains()</TT> method to determine if an instance belongs to the 
session cache. </P>
<P>To completely evict all objects from the session cache, call <TT 
class=literal>Session.clear()</TT> </P>
<P>For the second-level cache, there are methods defined on <TT 
class=literal>SessionFactory</TT> for evicting the cached state of an instance, 
entire class, collection instance or entire collection role. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=performance-querycache></A>14.5.&nbsp;The Query Cache</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Query result sets may also be cached. This is only useful for queries that 
are run frequently with the same parameters. To use the query cache you must 
first enable it by setting the property <TT 
class=literal>hibernate.cache.use_query_cache=true</TT>. This causes the 
creation of two cache regions - one holding cached query result sets (<TT 
class=literal>net.sf.hibernate.cache.QueryCache</TT>), the other holding 
timestamps of most recent updates to queried tables (<TT 
class=literal>net.sf.hibernate.cache.UpdateTimestampsCache</TT>). Note that the 
query cache does not cache the state of any entities in the result set; it 
caches only identifier values and results of value type. So the query cache is 
usually used in conjunction with the second-level cache. </P>
<P>Most queries do not benefit from caching, so by default queries are not 
cached. To enable caching, call <TT class=literal>Query.setCacheable(true)</TT>. 
This call allows the query to look for existing cache results or add its results 
to the cache when it is executed. </P>
<P>If you require fine-grained control over query cache expiration policies, you 
may specify a named cache region for a particular query by calling <TT 
class=literal>Query.setCacheRegion()</TT>. </P><PRE class=programlisting>List blogs = sess.createQuery("from Blog blog where blog.blogger = :blogger")
    .setEntity("blogger", blogger)
    .setMaxResults(15)
    .setCacheable(true)
    .setCacheRegion("frontpages")
    .list();</PRE></DIV></DIV>
<DIV class=chapter lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A name=toolsetguide></A>Chapter&nbsp;15.&nbsp;Toolset 
Guide</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Roundtrip engineering with Hibernate is possible using a set of commandline 
tools maintained as part of the Hibernate project, along with Hibernate support 
built into XDoclet, Middlegen and AndroMDA. </P>
<P>The Hibernate main package comes bundled with the most important tool (it can 
even be used from "inside" Hibernate on-the-fly): </P>
<DIV class=itemizedlist>
<UL type=disc>
  <LI>
  <P>DDL schema generation from a mapping file (aka <TT 
  class=literal>SchemaExport</TT>, <TT class=literal>hbm2ddl</TT>) 
</P></LI></UL></DIV>
<P>Other tools directly provided by the Hibernate project are delivered with a 
separate package, <SPAN class=emphasis><EM>Hibernate Extensions</EM></SPAN>. 
This package includes tools for the following tasks: </P>
<DIV class=itemizedlist>
<UL type=disc>
  <LI>
  <P>Java source generation from a mapping file (aka <TT 
  class=literal>CodeGenerator</TT>, <TT class=literal>hbm2java</TT>) </P>
  <LI>
  <P>mapping file generation from compiled Java classes or from Java source with 
  XDoclet markup (aka <TT class=literal>MapGenerator</TT>, <TT 
  class=literal>class2hbm</TT>) </P></LI></UL></DIV>
<P>There's actually another utitily living in Hibernate Extensions: <TT 
class=literal>ddl2hbm</TT>. It is considered deprecated and will no longer be 
maintained, Middlegen does a better job for the same task. </P>
<P>Third party tools with Hibernate support are: </P>
<DIV class=itemizedlist>
<UL type=disc>
  <LI>
  <P>Middlegen (mapping file generation from an existing database schema) </P>
  <LI>
  <P>AndroMDA (MDA (Model-Driven Architecture) approach generating code for 
  persistent classes from UML diagrams and their XML/XMI representation) 
  </P></LI></UL></DIV>
<P>These 3rd party tools are not documented in this reference. Please refer to 
the Hibernate website for up-to-date information (a snapshot of the site is 
included in the Hibernate main package). </P>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=toolsetguide-s1></A>15.1.&nbsp;Schema Generation</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>DDL may be generated from your mapping files by a command line utility. A 
batch file is located in the <TT class=literal>hibernate-x.x.x/bin</TT> 
directory of the core Hibernate package. </P>
<P>The generated schema include referential integrity constraints (primary and 
foreign keys) for entity and collection tables. Tables and sequences are also 
created for mapped identifier generators. </P>
<P>You <SPAN class=emphasis><EM>must</EM></SPAN> specify a SQL <TT 
class=literal>Dialect</TT> via the <TT class=literal>hibernate.dialect</TT> 
property when using this tool. </P>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=toolsetguide-s1-2></A>15.1.1.&nbsp;Customizing the 
schema</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>Many Hibernate mapping elements define an optional attribute named <TT 
class=literal>length</TT>. You may set the length of a column with this 
attribute. </P>
<P>Some tags also accept a <TT class=literal>not-null</TT> attribute (for 
generating a <TT class=literal>NOT NULL</TT> constraint on table columns) and a 
<TT class=literal>unique</TT> attribute (for generating <TT 
class=literal>UNIQUE</TT> constraint on table columns). </P>
<P>Some tags accept an <TT class=literal>index</TT> attribute for specifying the 
name of an index for that column. A <TT class=literal>unique-key</TT> attribute 
can be used to group columns in a single unit key constraint. Currently, the 
specified value of the <TT class=literal>unique-key</TT> attribute is <SPAN 
class=emphasis><EM>not</EM></SPAN> used to name the constraint, only to group 
the columns in the mapping file. </P>
<P>Examples: </P><PRE class=programlisting>&lt;property name="foo" type="string" length="64" not-null="true"/&gt;

&lt;many-to-one name="bar" foreign-key="fk_foo_bar" not-null="true"/&gt;

&lt;element column="serial_number" type="long" not-null="true" unique="true"/&gt;</PRE>
<P>Alternatively, these elements also accept a child <TT 
class=literal>&lt;column&gt;</TT> element. This is particularly useful for 
multi-column types: </P><PRE class=programlisting>&lt;property name="foo" type="string"&gt;
    &lt;column name="foo" length="64" not-null="true" sql-type="text"/&gt;
&lt;/property&gt;

&lt;property name="bar" type="my.customtypes.MultiColumnType"/&gt;
    &lt;column name="fee" not-null="true" index="bar_idx"/&gt;
    &lt;column name="fi" not-null="true" index="bar_idx"/&gt;
    &lt;column name="fo" not-null="true" index="bar_idx"/&gt;
&lt;/property&gt;</PRE>
<P>The <TT class=literal>sql-type</TT> attribute allows the user to override the 
default mapping of Hibernate type to SQL datatype. </P>
<P>The <TT class=literal>check</TT> attribute allows you to specify a check 
constraint. </P><PRE class=programlisting>&lt;property name="foo" type="integer"&gt;
    &lt;column name="foo" check="foo &gt; 10"/&gt;
&lt;/property&gt;

&lt;class name="Foo" table="foos" check="bar &lt; 100.0"&gt;
    ...
    &lt;property name="bar" type="float"/&gt;
&lt;/class&gt;</PRE>
<DIV class=table><A name=d0e9129></A>
<P class=title><B>Table&nbsp;15.1.&nbsp;Summary</B></P>
<TABLE summary=Summary border=1>
  <COLGROUP>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Attribute</TH>
    <TH>Values</TH>
    <TH>Interpretation</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><TT class=literal>length</TT></TD>
    <TD><TT class=literal>true|false</TT></TD>
    <TD>column length</TD></TR>
  <TR>
    <TD><TT class=literal>not-null</TT></TD>
    <TD><TT class=literal>true|false</TT></TD>
    <TD>specfies that the column should be non-nullable</TD></TR>
  <TR>
    <TD><TT class=literal>unique</TT></TD>
    <TD><TT class=literal>true|false</TT></TD>
    <TD>specifies that the column should have a unique constraint</TD></TR>
  <TR>
    <TD><TT class=literal>index</TT></TD>
    <TD><TT class=literal>index_name</TT></TD>
    <TD>specifies the name of a (multi-column) index</TD></TR>
  <TR>
    <TD><TT class=literal>unique-key</TT></TD>
    <TD><TT class=literal>unique_key_name</TT></TD>
    <TD>specifies the name of a multi-column unique constraint</TD></TR>
  <TR>
    <TD><TT class=literal>foreign-key</TT></TD>
    <TD><TT class=literal>foreign_key_name</TT></TD>
    <TD>specifies the name of the foreign key constraint generated for an 
      association </TD></TR>
  <TR>
    <TD><TT class=literal>sql-type</TT></TD>
    <TD><TT class=literal>column_type</TT></TD>
    <TD>overrides the default column type (attribute of <TT 
      class=literal>&lt;column&gt;</TT> element only) </TD></TR>
  <TR>
    <TD><TT class=literal>check</TT></TD>
    <TD>SQL expression</TD>
    <TD>create an SQL check constraint on either column or table 
</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=toolsetguide-s1-3></A>15.1.2.&nbsp;Running the 
tool</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>The <TT class=literal>SchemaExport</TT> tool writes a DDL script to standard 
out and/or executes the DDL statements. </P>
<P><TT class=literal>java -cp </TT><SPAN 
class=emphasis><EM>hibernate_classpaths</EM></SPAN> <TT 
class=literal>net.sf.hibernate.tool.hbm2ddl.SchemaExport</TT> <SPAN 
class=emphasis><EM>options mapping_files</EM></SPAN> </P>
<DIV class=table><A name=d0e9239></A>
<P class=title><B>Table&nbsp;15.2.&nbsp;<TT class=literal>SchemaExport</TT> 
Command Line Options</B></P>
<TABLE summary="SchemaExport Command Line Options" border=1>
  <COLGROUP>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Option</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><TT class=literal>--quiet</TT></TD>
    <TD>don't output the script to stdout</TD></TR>
  <TR>
    <TD><TT class=literal>--drop</TT></TD>
    <TD>only drop the tables</TD></TR>
  <TR>
    <TD><TT class=literal>--text</TT></TD>
    <TD>don't export to the database</TD></TR>
  <TR>
    <TD><TT class=literal>--output=my_schema.ddl</TT></TD>
    <TD>output the ddl script to a file</TD></TR>
  <TR>
    <TD><TT class=literal>--config=hibernate.cfg.xml</TT></TD>
    <TD>read Hibernate configuration from an XML file</TD></TR>
  <TR>
    <TD><TT class=literal>--properties=hibernate.properties</TT></TD>
    <TD>read database properties from a file</TD></TR>
  <TR>
    <TD><TT class=literal>--format</TT></TD>
    <TD>format the generated SQL nicely in the script</TD></TR>
  <TR>
    <TD><TT class=literal>--delimiter=x</TT></TD>
    <TD>set an end of line delimiter for the script</TD></TR></TBODY></TABLE></DIV>
<P>You may even embed <TT class=literal>SchemaExport</TT> in your application: 
</P><PRE class=programlisting>Configuration cfg = ....;
new SchemaExport(cfg).create(false, true);</PRE></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=toolsetguide-s1-4></A>15.1.3.&nbsp;Properties</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>Database properties may be specified </P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P>as system properties with <TT class=literal>-D</TT><SPAN 
  class=emphasis><EM>&lt;property&gt;</EM></SPAN></P>
  <LI>
  <P>in <TT class=literal>hibernate.properties</TT></P>
  <LI>
  <P>in a named properties file with <TT 
class=literal>--properties</TT></P></LI></UL></DIV>
<P>The needed properties are: </P>
<DIV class=table><A name=d0e9334></A>
<P class=title><B>Table&nbsp;15.3.&nbsp;SchemaExport Connection 
Properties</B></P>
<TABLE summary="SchemaExport Connection Properties" border=1>
  <COLGROUP>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Property Name</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><TT class=literal>hibernate.connection.driver_class</TT></TD>
    <TD>jdbc driver class</TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.connection.url</TT></TD>
    <TD>jdbc url</TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.connection.username</TT></TD>
    <TD>database user</TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.connection.password</TT></TD>
    <TD>user password</TD></TR>
  <TR>
    <TD><TT class=literal>hibernate.dialect</TT></TD>
    <TD>dialect</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=toolsetguide-s1-5></A>15.1.4.&nbsp;Using 
Ant</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>You can call <TT class=literal>SchemaExport</TT> from your Ant build script: 
</P><PRE class=programlisting>&lt;target name="schemaexport"&gt;
    &lt;taskdef name="schemaexport"
        classname="net.sf.hibernate.tool.hbm2ddl.SchemaExportTask"
        classpathref="class.path"/&gt;
    
    &lt;schemaexport
        properties="hibernate.properties"
        quiet="no"
        text="no"
        drop="no"
        delimiter=";"
        output="schema-export.sql"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaexport&gt;
&lt;/target&gt;</PRE></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=toolsetguide-s1-6></A>15.1.5.&nbsp;Incremental schema 
updates</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>The <TT class=literal>SchemaUpdate</TT> tool will update an existing schema 
with "incremental" changes. Note that <TT class=literal>SchemaUpdate</TT> 
depends heavily upon the JDBC metadata API, so it will not work with all JDBC 
drivers. </P>
<P><TT class=literal>java -cp </TT><SPAN 
class=emphasis><EM>hibernate_classpaths</EM></SPAN> <TT 
class=literal>net.sf.hibernate.tool.hbm2ddl.SchemaUpdate</TT> <SPAN 
class=emphasis><EM>options mapping_files</EM></SPAN> </P>
<DIV class=table><A name=d0e9411></A>
<P class=title><B>Table&nbsp;15.4.&nbsp;<TT class=literal>SchemaUpdate</TT> 
Command Line Options</B></P>
<TABLE summary="SchemaUpdate Command Line Options" border=1>
  <COLGROUP>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Option</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><TT class=literal>--quiet</TT></TD>
    <TD>don't output the script to stdout</TD></TR>
  <TR>
    <TD><TT class=literal>--properties=hibernate.properties</TT></TD>
    <TD>read database properties from a file</TD></TR></TBODY></TABLE></DIV>
<P>You may embed <TT class=literal>SchemaUpdate</TT> in your application: </P><PRE class=programlisting>Configuration cfg = ....;
new SchemaUpdate(cfg).execute(false);</PRE></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=toolsetguide-s1-7></A>15.1.6.&nbsp;Using Ant for 
incremental schema updates</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>You can call <TT class=literal>SchemaUpdate</TT> from the Ant script: </P><PRE class=programlisting>&lt;target name="schemaupdate"&gt;
    &lt;taskdef name="schemaupdate"
        classname="net.sf.hibernate.tool.hbm2ddl.SchemaUpdateTask"
        classpathref="class.path"/&gt;
    
    &lt;schemaupdate
        properties="hibernate.properties"
        quiet="no"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaupdate&gt;
&lt;/target&gt;</PRE></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=toolsetguide-s2></A>15.2.&nbsp;Code 
Generation</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>The Hibernate code generator may be used to generate skeletal Java 
implementation classes from a Hibernate mapping file. This tool is included in 
the Hibernate Extensions package (a seperate download). </P>
<P><TT class=literal>hbm2java</TT> parses the mapping files and generates fully 
working Java source files from these. Thus with <TT class=literal>hbm2java</TT> 
one could "just" provide the <TT class=literal>.hbm</TT> files, and then don't 
worry about hand-writing/coding the Java files. </P>
<P><TT class=literal>java -cp</TT> <SPAN 
class=emphasis><EM>hibernate_classpaths</EM></SPAN> <TT 
class=literal>net.sf.hibernate.tool.hbm2java.CodeGenerator</TT> <SPAN 
class=emphasis><EM>options mapping_files</EM></SPAN> </P>
<DIV class=table><A name=d0e9485></A>
<P class=title><B>Table&nbsp;15.5.&nbsp;Code Generator Command Line 
Options</B></P>
<TABLE summary="Code Generator Command Line Options" border=1>
  <COLGROUP>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Option</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><TT class=literal>--output=</TT><SPAN 
      class=emphasis><EM>output_dir</EM></SPAN></TD>
    <TD>root directory for generated code</TD></TR>
  <TR>
    <TD><TT class=literal>--config=</TT><SPAN 
      class=emphasis><EM>config_file</EM></SPAN></TD>
    <TD>optional file for configuring hbm2java</TD></TR></TBODY></TABLE></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=toolsetguide-s2-1></A>15.2.1.&nbsp;The config file 
(optional)</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>The config file provides for a way to specify multiple "renderers" for the 
source code and to declare <TT class=literal>&lt;meta&gt;</TT> attributes that 
is "global" in scope. See more about this in the <TT 
class=literal>&lt;meta&gt;</TT> attribute section. </P><PRE class=programlisting>&lt;codegen&gt;
    &lt;meta attribute="implements"&gt;codegen.test.IAuditable&lt;/meta&gt;
    &lt;generate renderer="net.sf.hibernate.tool.hbm2java.BasicRenderer"/&gt;
    &lt;generate
        package="autofinders.only"
        suffix="Finder"
        renderer="net.sf.hibernate.tool.hbm2java.FinderRenderer"/&gt;
&lt;/codegen&gt;</PRE>
<P>This config file declares a global meta attribute "implements" and specify 
two renderers, the default one (BasicRenderer) and a renderer that generates 
Finder's (See more in "Basic Finder generation" below). </P>
<P>The second renderer is provided with a package and suffix attribute. </P>
<P>The package attribute specifies that the generated source files from this 
renderer should be placed here instead of the package scope specified in the <TT 
class=literal>.hbm</TT> files. </P>
<P>The suffix attribute specifies the suffix for generated files. E.g. here a 
file named <TT class=literal>Foo.java</TT> would be <TT 
class=literal>FooFinder.java</TT> instead. </P>
<P>It is also possible to send down arbitrary parameters to the renders by 
adding <TT class=literal>&lt;param&gt;</TT> attributes to the <TT 
class=literal>&lt;generate&gt;</TT> elements. </P>
<P>hbm2java currently has support for one such parameter, namely <TT 
class=literal>generate-empty-concrete-classes</TT> which informs the 
BasicRenderer to only generate empty concrete classes that extends a base class 
for all your classes. The following config.xml example illustrate this feature 
</P><PRE class=programlisting>            &lt;codegen&gt;
              &lt;generate prefix="Base" renderer="net.sf.hibernate.tool.hbm2java.BasicRenderer"/&gt; 
              &lt;generate renderer="net.sf.hibernate.tool.hbm2java.BasicRenderer"&gt;
                &lt;param name="generate-empty-concrete-classes"&gt;true&lt;/param&gt;
                &lt;param name="baseclass-prefix"&gt;Base&lt;/param&gt;
              &lt;/generate&gt;
            &lt;/codegen&gt;</PRE>
<P>Notice that this config.xml configure 2 (two) renderers. One that generates 
the Base classes, and a second one that just generates empty concrete classes. 
</P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=toolsetguide-s2-2></A>15.2.2.&nbsp;The <TT 
class=literal>meta</TT> attribute</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>The <TT class=literal>&lt;meta&gt;</TT> tag is a simple way of annotating the 
<TT class=literal>hbm.xml</TT> with information, so tools have a natural place 
to store/read information that is not directly related to the Hibernate core. 
</P>
<P>You can use the <TT class=literal>&lt;meta&gt;</TT> tag to tell <TT 
class=literal>hbm2java</TT> to only generate "protected" setters, have classes 
always implement a certain set of interfaces or even have them extend a certain 
base class and even more. </P>
<P>The following example: </P><PRE class=programlisting>&lt;class name="Person"&gt;
    &lt;meta attribute="class-description"&gt;
        Javadoc for the Person class
        @author Frodo
    &lt;/meta&gt;
    &lt;meta attribute="implements"&gt;IAuditable&lt;/meta&gt;
    &lt;id name="id" type="long"&gt;
        &lt;meta attribute="scope-set"&gt;protected&lt;/meta&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" type="string"&gt;
        &lt;meta attribute="field-description"&gt;The name of the person&lt;/meta&gt;
    &lt;/property&gt;
&lt;/class&gt;</PRE>
<P>will produce something like the following (code shortened for better 
understanding). Notice the Javadoc comment and the protected set methods: </P><PRE class=programlisting>// default package

import java.io.Serializable;
import org.apache.commons.lang.builder.EqualsBuilder;
import org.apache.commons.lang.builder.HashCodeBuilder;
import org.apache.commons.lang.builder.ToStringBuilder;

/** 
 *         Javadoc for the Person class
 *         @author Frodo
 *     
 */
public class Person implements Serializable, IAuditable {

    /** identifier field */
    public Long id;

    /** nullable persistent field */
    public String name;

    /** full constructor */
    public Person(java.lang.String name) {
        this.name = name;
    }

    /** default constructor */
    public Person() {
    }

    public java.lang.Long getId() {
        return this.id;
    }

    protected void setId(java.lang.Long id) {
        this.id = id;
    }

    /** 
     * The name of the person
     */
    public java.lang.String getName() {
        return this.name;
    }

    public void setName(java.lang.String name) {
        this.name = name;
    }

}</PRE>
<DIV class=table><A name=d0e9591></A>
<P class=title><B>Table&nbsp;15.6.&nbsp;Supported meta tags</B></P>
<TABLE summary="Supported meta tags" border=1>
  <COLGROUP>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Attribute</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><TT class=literal>class-description</TT></TD>
    <TD>inserted into the javadoc for classes</TD></TR>
  <TR>
    <TD><TT class=literal>field-description</TT></TD>
    <TD>inserted into the javadoc for fields/properties</TD></TR>
  <TR>
    <TD><TT class=literal>interface</TT></TD>
    <TD>If true an interface is generated instead of an class.</TD></TR>
  <TR>
    <TD><TT class=literal>implements</TT></TD>
    <TD>interface the class should implement</TD></TR>
  <TR>
    <TD><TT class=literal>extends</TT></TD>
    <TD>class the class should extend (ignored for subclasses)</TD></TR>
  <TR>
    <TD><TT class=literal>generated-class</TT></TD>
    <TD>overrule the name of the actual class generated</TD></TR>
  <TR>
    <TD><TT class=literal>scope-class</TT></TD>
    <TD>scope for class </TD></TR>
  <TR>
    <TD><TT class=literal>scope-set</TT></TD>
    <TD>scope for setter method</TD></TR>
  <TR>
    <TD><TT class=literal>scope-get</TT></TD>
    <TD>scope for getter method</TD></TR>
  <TR>
    <TD><TT class=literal>scope-field</TT></TD>
    <TD>scope for actual field</TD></TR>
  <TR>
    <TD><TT class=literal>use-in-tostring</TT></TD>
    <TD>include this property in the <TT class=literal>toString()</TT></TD></TR>
  <TR>
    <TD><TT class=literal>implement-equals</TT></TD>
    <TD>include a <TT class=literal>equals()</TT> and <TT 
      class=literal>hashCode()</TT> method in this class.</TD></TR>
  <TR>
    <TD><TT class=literal>use-in-equals</TT></TD>
    <TD>include this property in the <TT class=literal>equals()</TT> and <TT 
      class=literal>hashCode()</TT> method.</TD></TR>
  <TR>
    <TD><TT class=literal>bound</TT></TD>
    <TD>add propertyChangeListener support for a property</TD></TR>
  <TR>
    <TD><TT class=literal>constrained</TT></TD>
    <TD>bound + vetoChangeListener support for a property</TD></TR>
  <TR>
    <TD><TT class=literal>gen-property</TT></TD>
    <TD>property will not be generated if false (use with care)</TD></TR>
  <TR>
    <TD><TT class=literal>property-type</TT></TD>
    <TD>Overrides the default type of property. Use this with any tag's to 
      specify the concrete type instead of just Object.</TD></TR>
  <TR>
    <TD><TT class=literal>class-code</TT></TD>
    <TD>Extra code that will inserted at the end of the class</TD></TR>
  <TR>
    <TD><TT class=literal>extra-import</TT></TD>
    <TD>Extra import that will inserted at the end of all other imports</TD></TR>
  <TR>
    <TD><TT class=literal>finder-method</TT></TD>
    <TD>see "Basic finder generator" below</TD></TR>
  <TR>
    <TD><TT class=literal>session-method</TT></TD>
    <TD>see "Basic finder generator" below</TD></TR></TBODY></TABLE></DIV>
<P>Attributes declared via the <TT class=literal>&lt;meta&gt;</TT> tag are per 
default "inherited" inside an <TT class=literal>hbm.xml</TT> file. </P>
<P>What does that mean? It means that if you e.g want to have all your classes 
implement <TT class=literal>IAuditable</TT> then you just add an <TT 
class=literal>&lt;meta attribute="implements"&gt;IAuditable&lt;/meta&gt;</TT> in 
the top of the <TT class=literal>hbm.xml</TT> file, just after <TT 
class=literal>&lt;hibernate-mapping&gt;</TT>. Now all classes defined in that 
<TT class=literal>hbm.xml</TT> file will implement <TT 
class=literal>IAuditable</TT>! (Except if a class also has an "implements" meta 
attribute, because local specified meta tags always overrules/replaces any 
inherited meta tags). </P>
<P>Note: This applies to <SPAN class=emphasis><EM>all</EM></SPAN> <TT 
class=literal>&lt;meta&gt;</TT>-tags. Thus it can also e.g. be used to specify 
that all fields should be declare protected, instead of the default private. 
This is done by adding <TT class=literal>&lt;meta 
attribute="scope-field"&gt;protected&lt;/meta&gt;</TT> at e.g. just under the 
<TT class=literal>&lt;class&gt;</TT> tag and all fields of that class will be 
protected. </P>
<P>To avoid having a <TT class=literal>&lt;meta&gt;</TT>-tag inherited then you 
can simply specify <TT class=literal>inherit="false"</TT> for the attribute, 
e.g. <TT class=literal>&lt;meta attribute="scope-class" 
inherit="false"&gt;public abstract&lt;/meta&gt;</TT> will restrict the 
"class-scope" to the current class, not the subclasses. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=toolsetguide-s2-3></A>15.2.3.&nbsp;Basic finder 
generator</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>It is now possible to have <TT class=literal>hbm2java</TT> generate basic 
finders for Hibernate properties. This requires two things in the <TT 
class=literal>hbm.xml</TT> files. </P>
<P>The first is an indication of which fields you want to generate finders for. 
You indicate that with a meta block inside a property tag such as: </P><PRE class=programlisting>&lt;property name="name" column="name" type="string"&gt;
     &lt;meta attribute="finder-method"&gt;findByName&lt;/meta&gt;
&lt;/property&gt;</PRE>
<P>The finder method name will be the text enclosed in the meta tags. </P>
<P>The second is to create a config file for hbm2java of the format: </P><PRE class=programlisting>&lt;codegen&gt;
    &lt;generate renderer="net.sf.hibernate.tool.hbm2java.BasicRenderer"/&gt;
    &lt;generate suffix="Finder" renderer="net.sf.hibernate.tool.hbm2java.FinderRenderer"/&gt;
&lt;/codegen&gt;</PRE>
<P>And then use the param to <TT class=literal>hbm2java --config=xxx.xml</TT> 
where <TT class=literal>xxx.xml</TT> is the config file you just created. </P>
<P>An optional parameter is meta tag at the class level of the format: </P><PRE class=programlisting>&lt;meta attribute="session-method"&gt;
    com.whatever.SessionTable.getSessionTable().getSession();
&lt;/meta&gt;</PRE>
<P>Which would be the way in which you get sessions if you use the <SPAN 
class=emphasis><EM>Thread Local Session</EM></SPAN> pattern (documented in the 
Design Patterns area of the Hibernate website). </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=toolsetguide-s2-4></A>15.2.4.&nbsp;Velocity based 
renderer/generator</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>It is now possible to use velocity as an alternative rendering mechanism. The 
follwing config.xml shows how to configure hbm2java to use its velocity 
renderer. </P><PRE class=programlisting>    &lt;codegen&gt;
     &lt;generate renderer="net.sf.hibernate.tool.hbm2java.VelocityRenderer"&gt;
      &lt;param name="template"&gt;pojo.vm&lt;/param&gt;
     &lt;/generate&gt;
    &lt;/codegen&gt;</PRE>
<P>The parameter named <TT class=literal>template</TT> is a resource path to the 
velocity macro file you want to use. This file must be available via the 
classpath for hbm2java. Thus remember to add the directory where pojo.vm is 
located to your ant task or shell script. (The default location is <TT 
class=literal>./tools/src/velocity</TT>) </P>
<P>Be aware that the current <TT class=literal>pojo.vm</TT> generates only the 
most basic parts of the java beans. It is not as complete and feature rich as 
the default renderer - primarily a lot of the <TT class=literal>meta</TT> tags 
are not supported. </P></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=toolsetguide-s3></A>15.3.&nbsp;Mapping File Generation</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>A skeletal mapping file may be generated from compiled persistent classes 
using a command line utility called <TT class=literal>MapGenerator</TT>. This 
utility is part of the Hibernate Extensions package. </P>
<P>The Hibernate mapping generator provides a mechanism to produce mappings from 
compiled classes. It uses Java reflection to find <SPAN 
class=emphasis><EM>properties</EM></SPAN> and uses heuristics to guess an 
appropriate mapping from the property type. The generated mapping is intended to 
be a starting point only. There is no way to produce a full Hibernate mapping 
without extra input from the user. However, the tool does take away some of the 
repetitive "grunt" work involved in producing a mapping. </P>
<P>Classes are added to the mapping one at a time. The tool will reject classes 
that it judges are are not <SPAN class=emphasis><EM>Hibernate 
persistable</EM></SPAN>. </P>
<P>To be <SPAN class=emphasis><EM>Hibernate persistable</EM></SPAN> a class </P>
<DIV class=itemizedlist>
<UL type=disc compact>
  <LI>
  <P>must not be a primitive type</P>
  <LI>
  <P>must not be an array</P>
  <LI>
  <P>must not be an interface</P>
  <LI>
  <P>must not be a nested class</P>
  <LI>
  <P>must have a default (zero argument) constructor.</P></LI></UL></DIV>
<P>Note that interfaces and nested classes actually are persistable by 
Hibernate, but this would not usually be intended by the user. </P>
<P><TT class=literal>MapGenerator</TT> will climb the superclass chain of all 
added classes attempting to add as many Hibernate persistable superclasses as 
possible to the same database table. The search stops as soon as a property is 
found that has a name appearing on a list of <SPAN class=emphasis><EM>candidate 
UID names</EM></SPAN>. </P>
<P>The default list of candidate UID property names is: <TT 
class=literal>uid</TT>, <TT class=literal>UID</TT>, <TT class=literal>id</TT>, 
<TT class=literal>ID</TT>, <TT class=literal>key</TT>, <TT 
class=literal>KEY</TT>, <TT class=literal>pk</TT>, <TT class=literal>PK</TT>. 
</P>
<P>Properties are discovered when there are two methods in the class, a setter 
and a getter, where the type of the setter's single argument is the same as the 
return type of the zero argument getter, and the setter returns <TT 
class=literal>void</TT>. Furthermore, the setter's name must start with the 
string <TT class=literal>set</TT> and either the getter's name starts with <TT 
class=literal>get</TT> or the getter's name starts with <TT 
class=literal>is</TT> and the type of the property is boolean. In either case, 
the remainder of their names must match. This matching portion is the name of 
the property, except that the initial character of the property name is made 
lower case if the second letter is lower case. </P>
<P>The rules for determining the database type of each property are as follows: 
</P>
<DIV class=orderedlist>
<OL type=1 compact>
  <LI>
  <P>If the Java type is <TT class=literal>Hibernate.basic()</TT>, then the 
  property is a simple column of that type. </P>
  <LI>
  <P>For <TT class=literal>hibernate.type.Type</TT> custom types and <TT 
  class=literal>PersistentEnum</TT> a simple column is used as well. </P>
  <LI>
  <P>If the property type is an array, then a Hibernate array is used, and <TT 
  class=literal>MapGenerator</TT> attempts to reflect on the array element type. 
  </P>
  <LI>
  <P>If the property has type <TT class=literal>java.util.List</TT>, <TT 
  class=literal>java.util.Map</TT>, or <TT class=literal>java.util.Set</TT>, 
  then the corresponding Hibernate types are used, but <TT 
  class=literal>MapGenerator</TT> cannot further process the insides of these 
  types. </P>
  <LI>
  <P>If the property's type is any other class, <TT 
  class=literal>MapGenerator</TT> defers the decision on the database 
  representation until all classes have been processed. At this point, if the 
  class was discovered through the superclass search described above, then the 
  property is an <TT class=literal>many-to-one</TT> association. If the class 
  has any properties, then it is a <TT class=literal>component</TT>. Otherwise 
  it is serializable, or not persistable. </P></LI></OL></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=toolsetguide-s3-1></A>15.3.1.&nbsp;Running the 
tool</H3></DIV></DIV>
<DIV></DIV></DIV>
<P>The tool writes XML mappings to standard out and/or to a file. </P>
<P>When invoking the tool you must place your compiled classes on the classpath. 
</P>
<P><TT class=literal>java -cp </TT><SPAN 
class=emphasis><EM>hibernate_and_your_class_classpaths</EM></SPAN> <TT 
class=literal>net.sf.hibernate.tool.class2hbm.MapGenerator</TT> <SPAN 
class=emphasis><EM>options and classnames</EM></SPAN> </P>
<P>There are two modes of operation: command line or interactive. </P>
<P>The interactive mode is selected by providing the single command line 
argument <TT class=literal>--interact</TT>. This mode provides a prompt response 
console. Using it you can set the UID property name for each class using the <TT 
class=literal>uid=XXX</TT> command where <TT class=literal>XXX</TT> is the UID 
property name. Other command alternatives are simply a fully qualified class 
name, or the command done which emits the XML and terminates. </P>
<P>In command line mode the arguments are the options below interspersed with 
fully qualified class names of the classes to be processed. Most of the options 
are meant to be used multiple times; each use affects subsequently added 
classes. </P>
<DIV class=table><A name=d0e10033></A>
<P class=title><B>Table&nbsp;15.7.&nbsp;MapGenerator Command Line 
Options</B></P>
<TABLE summary="MapGenerator Command Line Options" border=1>
  <COLGROUP>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Option</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><TT class=literal>--quiet</TT></TD>
    <TD>don't output the O-R Mapping to stdout</TD></TR>
  <TR>
    <TD><TT class=literal>--setUID=uid</TT></TD>
    <TD>set the list of candidate UIDs to the singleton uid</TD></TR>
  <TR>
    <TD><TT class=literal>--addUID=uid</TT></TD>
    <TD>add uid to the front of the list of candidate UIDs</TD></TR>
  <TR>
    <TD><TT class=literal>--select=</TT><SPAN 
      class=emphasis><EM>mode</EM></SPAN></TD>
    <TD>mode use select mode <SPAN class=emphasis><EM>mode</EM></SPAN>(e.g., 
      <SPAN class=emphasis><EM>distinct</EM></SPAN> or <SPAN 
      class=emphasis><EM>all</EM></SPAN>) for subsequently added classes</TD></TR>
  <TR>
    <TD><TT class=literal>--depth=&lt;small-int&gt;</TT></TD>
    <TD>limit the depth of component data recursion for subsequently added 
      classes</TD></TR>
  <TR>
    <TD><TT class=literal>--output=my_mapping.xml</TT></TD>
    <TD>output the O-R Mapping to a file</TD></TR>
  <TR>
    <TD><SPAN class=emphasis><EM>full.class.Name</EM></SPAN></TD>
    <TD>add the class to the mapping</TD></TR>
  <TR>
    <TD><TT class=literal>--abstract=</TT><SPAN 
      class=emphasis><EM>full.class.Name</EM></SPAN></TD>
    <TD>see below</TD></TR></TBODY></TABLE></DIV>
<P>The abstract switch directs the map generator tool to ignore specific super 
classes so that classes with common inheritance are not mapped to one large 
table. For instance, consider these class hierarchies: </P>
<P><TT class=literal>Animal--&gt;Mammal--&gt;Human</TT> </P>
<P><TT class=literal>Animal--&gt;Mammal--&gt;Marsupial--&gt;Kangaroo</TT> </P>
<P>If the <TT class=literal>--abstract</TT>switch is <SPAN 
class=emphasis><EM>not</EM></SPAN> used, all classes will be mapped as 
subclasses of <TT class=literal>Animal</TT>, resulting in one large table 
containing all the properties of all the classes plus a discriminator column to 
indicate which subclass is actually stored. If <TT class=literal>Mammal</TT> is 
marked as <TT class=literal>abstract</TT>, <TT class=literal>Human</TT> and <TT 
class=literal>Marsupial</TT> will be mapped to separate <TT 
class=literal>&lt;class&gt;</TT> declarations and stored in separate tables. <TT 
class=literal>Kangaroo</TT> will still be a subclass of <TT 
class=literal>Marsupial</TT> unless <TT class=literal>Marsupial</TT> is also 
marked as <TT class=literal>abstract</TT>. </P></DIV></DIV></DIV>
<DIV class=chapter lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A name=example-parentchild></A>Chapter&nbsp;16.&nbsp;Example: 
Parent/Child</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>One of the very first things that new users try to do with Hibernate is to 
model a parent / child type relationship. There are two different approaches to 
this. For various reasons the most convenient approach, especially for new 
users, is to model both <TT class=literal>Parent</TT> and <TT 
class=literal>Child</TT> as entity classes with a <TT 
class=literal>&lt;one-to-many&gt;</TT> association from <TT 
class=literal>Parent</TT> to <TT class=literal>Child</TT>. (The alternative 
approach is to declare the <TT class=literal>Child</TT> as a <TT 
class=literal>&lt;composite-element&gt;</TT>.) Now, it turns out that default 
semantics of a one to many association (in Hibernate) are much less close to the 
usual semantics of a parent / child relationship than those of a composite 
element mapping. We will explain how to use a <SPAN 
class=emphasis><EM>bidirectional one to many association with 
cascades</EM></SPAN> to model a parent / child relationship efficiently and 
elegantly. It's not at all difficult! </P>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=example-parentchild-collections></A>16.1.&nbsp;A note about 
collections</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Hibernate collections are considered to be a logical part of their owning 
entity; never of the contained entities. This is a crucial distinction! It has 
the following consequences: </P>
<DIV class=itemizedlist>
<UL type=disc>
  <LI>
  <P>When we remove / add an object from / to a collection, the version number 
  of the collection owner is incremented. </P>
  <LI>
  <P>If an object that was removed from a collection is an instance of a value 
  type (eg, a composite element), that object will cease to be persistent and 
  its state will be completely removed from the database. Likewise, adding a 
  value type instance to the collection will cause its state to be immediately 
  persistent. </P>
  <LI>
  <P>On the other hand, if an entity is removed from a collection (a one-to-many 
  or many-to-many association), it will not be deleted, by default. This 
  behaviour is completely consistent - a change to the internal state of another 
  entity should not cause the associated entity to vanish! Likewise, adding an 
  entity to a collection does not cause that entity to become persistent, by 
  default. </P></LI></UL></DIV>
<P>Instead, the default behaviour is that adding an entity to a collection 
merely creates a link between the two entities, while removing it removes the 
link. This is very appropriate for all sorts of cases. Where it is not 
appropriate at all is the case of a parent / child relationship, where the life 
of the child is bound to the lifecycle of the parent. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=example-parentchild-bidir></A>16.2.&nbsp;Bidirectional 
one-to-many</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Suppose we start with a simple <TT class=literal>&lt;one-to-many&gt;</TT> 
association from <TT class=literal>Parent</TT> to <TT class=literal>Child</TT>. 
</P><PRE class=programlisting>&lt;set name="children"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</PRE>
<P>If we were to execute the following code </P><PRE class=programlisting>Parent p = .....;
Child c = new Child();
p.getChildren().add(c);
session.save(c);
session.flush();</PRE>
<P>Hibernate would issue two SQL statements: </P>
<DIV class=itemizedlist>
<UL type=disc>
  <LI>
  <P>an <TT class=literal>INSERT</TT> to create the record for <TT 
  class=literal>c</TT></P>
  <LI>
  <P>an <TT class=literal>UPDATE</TT> to create the link from <TT 
  class=literal>p</TT> to <TT class=literal>c</TT> </P></LI></UL></DIV>
<P>This is not only inefficient, but also violates any <TT class=literal>NOT 
NULL</TT> constraint on the <TT class=literal>parent_id</TT> column. </P>
<P>The underlying cause is that the link (the foreign key <TT 
class=literal>parent_id</TT>) from <TT class=literal>p</TT> to <TT 
class=literal>c</TT> is not considered part of the state of the <TT 
class=literal>Child</TT> object and is therefore not created in the <TT 
class=literal>INSERT</TT>. So the solution is to make the link part of the <TT 
class=literal>Child</TT> mapping. </P><PRE class=programlisting>&lt;many-to-one name="parent" column="parent_id" not-null="true"/&gt;</PRE>
<P>(We also need to add the <TT class=literal>parent</TT> property to the <TT 
class=literal>Child</TT> class.) </P>
<P>Now that the <TT class=literal>Child</TT> entity is managing the state of the 
link, we tell the collection not to update the link. We use the <TT 
class=literal>inverse</TT> attribute. </P><PRE class=programlisting>&lt;set name="children" inverse="true"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</PRE>
<P>The following code would be used to add a new <TT class=literal>Child</TT> 
</P><PRE class=programlisting>Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
c.setParent(p);
p.getChildren().add(c);
session.save(c);
session.flush();</PRE>
<P>And now, only one SQL <TT class=literal>INSERT</TT> would be issued! </P>
<P>To tighten things up a bit, we could create an <TT 
class=literal>addChild()</TT> method of <TT class=literal>Parent</TT>. </P><PRE class=programlisting>public void addChild(Child c) {
    c.setParent(this);
    children.add(c);
}</PRE>
<P>Now, the code to add a <TT class=literal>Child</TT> looks like </P><PRE class=programlisting>Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
p.addChild(c);
session.save(c);
session.flush();</PRE></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=example-parentchild-cascades></A>16.3.&nbsp;Cascading 
lifecycle</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>The explicit call to <TT class=literal>save()</TT> is still annoying. We will 
address this by using cascades. </P><PRE class=programlisting>&lt;set name="children" inverse="true" cascade="all"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</PRE>
<P>This simplifies the code above to </P><PRE class=programlisting>Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
p.addChild(c);
session.flush();</PRE>
<P>Similarly, we don't need to iterate over the children when saving or deleting 
a <TT class=literal>Parent</TT>. The following removes <TT class=literal>p</TT> 
and all its children from the database. </P><PRE class=programlisting>Parent p = (Parent) session.load(Parent.class, pid);
session.delete(p);
session.flush();</PRE>
<P>However, this code </P><PRE class=programlisting>Parent p = (Parent) session.load(Parent.class, pid);
Child c = (Child) p.getChildren().iterator().next();
p.getChildren().remove(c);
c.setParent(null);
session.flush();</PRE>
<P>will not remove <TT class=literal>c</TT> from the database; it will ony 
remove the link to <TT class=literal>p</TT> (and cause a <TT class=literal>NOT 
NULL</TT> constraint violation, in this case). You need to explicitly <TT 
class=literal>delete()</TT> the <TT class=literal>Child</TT>. </P><PRE class=programlisting>Parent p = (Parent) session.load(Parent.class, pid);
Child c = (Child) p.getChildren().iterator().next();
p.getChildren().remove(c);
session.delete(c);
session.flush();</PRE>
<P>Now, in our case, a <TT class=literal>Child</TT> can't really exist without 
its parent. So if we remove a <TT class=literal>Child</TT> from the collection, 
we really do want it to be deleted. For this, we must use <TT 
class=literal>cascade="all-delete-orphan"</TT>. </P><PRE class=programlisting>&lt;set name="children" inverse="true" cascade="all-delete-orphan"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</PRE>
<P>Note: even though the collection mapping specifies <TT 
class=literal>inverse="true"</TT>, cascades are still processed by iterating the 
collection elements. So if you require that an object be saved, deleted or 
updated by cascade, you must add it to the collection. It is not enough to 
simply call <TT class=literal>setParent()</TT>. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=example-parentchild-update></A>16.4.&nbsp;Using cascading <TT 
class=literal>update()</TT></H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Suppose we loaded up a <TT class=literal>Parent</TT> in one <TT 
class=literal>Session</TT>, made some changes in a UI action and wish to persist 
these changes in a new Session (by calling <TT class=literal>update()</TT>). The 
<TT class=literal>Parent</TT> will contain a collection of childen and, since 
cascading update is enabled, Hibernate needs to know which children are newly 
instantiated and which represent existing rows in the database. Lets assume that 
both <TT class=literal>Parent</TT> and <TT class=literal>Child</TT> have 
(synthetic) identifier properties of type <TT class=literal>java.lang.Long</TT>. 
Hibernate will use the identifier property value to determine which of the 
children are new. (You may also use the version or timestamp property, see <A 
title="9.4.2.&nbsp;Updating detached objects" 
href="http://www.hibernate.org/hib_docs/reference/en/html_single/#manipulatingdata-updating-detached">Section&nbsp;9.4.2, 
“Updating detached objects”</A>.) </P>
<P>The <TT class=literal>unsaved-value</TT> attribute is used to specify the 
identifier value of a newly instantiated instance. <TT 
class=literal>unsaved-value</TT> defaults to "null", which is perfect for a <TT 
class=literal>Long</TT> identifier type. If we would have used a primitive 
identitifier property, we would need to specify </P><PRE class=programlisting>&lt;id name="id" type="long" unsaved-value="0"&gt;</PRE>
<P>for the <TT class=literal>Child</TT> mapping. (There is also an <TT 
class=literal>unsaved-value</TT> attribute for version and timestamp property 
mappings.) </P>
<P>The following code will update <TT class=literal>parent</TT> and <TT 
class=literal>child</TT> and insert <TT class=literal>newChild</TT>. </P><PRE class=programlisting>//parent and child were both loaded in a previous session
parent.addChild(child);
Child newChild = new Child();
parent.addChild(newChild);
session.update(parent);
session.flush();</PRE>
<P>Well, thats all very well for the case of a generated identifier, but what 
about assigned identifiers and composite identifiers? This is more difficult, 
since <TT class=literal>unsaved-value</TT> can't distinguish between a newly 
instantiated object (with an identifier assigned by the user) and an object 
loaded in a previous session. In these cases, you will probably need to give 
Hibernate a hint; either </P>
<DIV class=itemizedlist>
<UL type=disc>
  <LI>
  <P>define <TT class=literal>unsaved-value="null"</TT> or <TT 
  class=literal>unsaved-value="negative"</TT> on a <TT 
  class=literal>&lt;version&gt;</TT> or <TT class=literal>&lt;timestamp&gt;</TT> 
  property mapping for the class. </P>
  <LI>
  <P>set <TT class=literal>unsaved-value="none"</TT> and explicitly <TT 
  class=literal>save()</TT> newly instantiated children before calling <TT 
  class=literal>update(parent)</TT> </P>
  <LI>
  <P>set <TT class=literal>unsaved-value="any"</TT> and explicitly <TT 
  class=literal>update()</TT> previously persistent children before calling <TT 
  class=literal>update(parent)</TT> </P></LI></UL></DIV>
<P><TT class=literal>none</TT> is the default <TT 
class=literal>unsaved-value</TT> for assigned and composite identifiers. </P>
<P>There is one further possibility. There is a new <TT 
class=literal>Interceptor</TT> method named <TT class=literal>isUnsaved()</TT> 
which lets the application implement its own strategy for distinguishing newly 
instantiated objects. For example, you could define a base class for your 
persistent classes. </P><PRE class=programlisting>public class Persistent {
    private boolean _saved = false;
    public void onSave() {
        _saved=true;
    }
    public void onLoad() {
        _saved=true;
    }
    ......
    public boolean isSaved() {
        return _saved;
    }
}</PRE>
<P>(The <TT class=literal>saved</TT> property is non-persistent.) Now implement 
<TT class=literal>isUnsaved()</TT>, along with <TT class=literal>onLoad()</TT> 
and <TT class=literal>onSave()</TT> as follows. </P><PRE class=programlisting>public Boolean isUnsaved(Object entity) {
    if (entity instanceof Persistent) {
        return new Boolean( !( (Persistent) entity ).isSaved() );
    }
    else {
        return null;
    }
}

public boolean onLoad(Object entity, 
    Serializable id,
    Object[] state,
    String[] propertyNames,
    Type[] types) {

    if (entity instanceof Persistent) ( (Persistent) entity ).onLoad();
    return false;
}

public boolean onSave(Object entity,
    Serializable id,
    Object[] state,
    String[] propertyNames,
    Type[] types) {
        
    if (entity instanceof Persistent) ( (Persistent) entity ).onSave();
    return false;
}</PRE></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=example-parentchild-conclusion></A>16.5.&nbsp;Conclusion</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>There is quite a bit to digest here and it might look confusing first time 
around. However, in practice, it all works out quite nicely. Most Hibernate 
applications use the parent / child pattern in many places. </P>
<P>We mentioned an alternative in the first paragraph. None of the above issues 
exist in the case of <TT class=literal>&lt;composite-element&gt;</TT> mappings, 
which have exactly the semantics of a parent / child relationship. 
Unfortunately, there are two big limitations to composite element classes: 
composite elements may not own collections, and they should not be the child of 
any entity other than the unique parent. (However, they <SPAN 
class=emphasis><EM>may</EM></SPAN> have a surrogate primary key, using an <TT 
class=literal>&lt;idbag&gt;</TT> mapping.) </P></DIV></DIV>
<DIV class=chapter lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A name=example-weblog></A>Chapter&nbsp;17.&nbsp;Example: Weblog 
Application</H2></DIV></DIV>
<DIV></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=example-weblog-classes></A>17.1.&nbsp;Persistent Classes</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>The persistent classes represent a weblog, and an item posted in a weblog. 
They are to be modelled as a standard parent/child relationship, but we will use 
an ordered bag, instead of a set. </P><PRE class=programlisting>package eg;

import java.util.List;

public class Blog {
    private Long _id;
    private String _name;
    private List _items;

    public Long getId() {
        return _id;
    }
    public List getItems() {
        return _items;
    }
    public String getName() {
        return _name;
    }
    public void setId(Long long1) {
        _id = long1;
    }
    public void setItems(List list) {
        _items = list;
    }
    public void setName(String string) {
        _name = string;
    }
}</PRE><PRE class=programlisting>package eg;

import java.text.DateFormat;
import java.util.Calendar;

public class BlogItem {
    private Long _id;
    private Calendar _datetime;
    private String _text;
    private String _title;
    private Blog _blog;

    public Blog getBlog() {
        return _blog;
    }
    public Calendar getDatetime() {
        return _datetime;
    }
    public Long getId() {
        return _id;
    }
    public String getText() {
        return _text;
    }
    public String getTitle() {
        return _title;
    }
    public void setBlog(Blog blog) {
        _blog = blog;
    }
    public void setDatetime(Calendar calendar) {
        _datetime = calendar;
    }
    public void setId(Long long1) {
        _id = long1;
    }
    public void setText(String string) {
        _text = string;
    }
    public void setTitle(String string) {
        _title = string;
    }
}</PRE></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=example-weblog-mappings></A>17.2.&nbsp;Hibernate Mappings</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>The XML mappings should now be quite straightforward. </P><PRE class=programlisting>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC 
        "-//Hibernate/Hibernate Mapping DTD 2.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

    &lt;class 
        name="Blog" 
        table="BLOGS" 
        lazy="true"&gt;
        
        &lt;id 
            name="id" 
            column="BLOG_ID"&gt;
            
            &lt;generator class="native"/&gt;
            
        &lt;/id&gt;
        
        &lt;property 
            name="name" 
            column="NAME" 
            not-null="true" 
            unique="true"/&gt;
            
        &lt;bag 
            name="items" 
            inverse="true" 
            lazy="true"
            order-by="DATE_TIME" 
            cascade="all"&gt;
            
            &lt;key column="BLOG_ID"/&gt;
            &lt;one-to-many class="BlogItem"/&gt;
            
        &lt;/bag&gt;
        
    &lt;/class&gt;
    
&lt;/hibernate-mapping&gt;</PRE><PRE class=programlisting>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC 
        "-//Hibernate/Hibernate Mapping DTD 2.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;
    
    &lt;class 
        name="BlogItem" 
        table="BLOG_ITEMS" 
        dynamic-update="true"&gt;
        
        &lt;id 
            name="id" 
            column="BLOG_ITEM_ID"&gt;
            
            &lt;generator class="native"/&gt;
            
        &lt;/id&gt;
        
        &lt;property 
            name="title" 
            column="TITLE" 
            not-null="true"/&gt;
            
        &lt;property 
            name="text" 
            column="TEXT" 
            not-null="true"/&gt;
            
        &lt;property 
            name="datetime" 
            column="DATE_TIME" 
            not-null="true"/&gt;
            
        &lt;many-to-one 
            name="blog" 
            column="BLOG_ID" 
            not-null="true"/&gt;
            
    &lt;/class&gt;
    
&lt;/hibernate-mapping&gt;</PRE></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=example-weblog-code></A>17.3.&nbsp;Hibernate Code</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>The following class demonstrates some of the kinds of things we can do with 
these classes, using Hibernate. </P><PRE class=programlisting>package eg;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Iterator;
import java.util.List;

import net.sf.hibernate.HibernateException;
import net.sf.hibernate.Query;
import net.sf.hibernate.Session;
import net.sf.hibernate.SessionFactory;
import net.sf.hibernate.Transaction;
import net.sf.hibernate.cfg.Configuration;
import net.sf.hibernate.tool.hbm2ddl.SchemaExport;

public class BlogMain {
    
    private SessionFactory _sessions;
    
    public void configure() throws HibernateException {
        _sessions = new Configuration()
            .addClass(Blog.class)
            .addClass(BlogItem.class)
            .buildSessionFactory();
    }
    
    public void exportTables() throws HibernateException {
        Configuration cfg = new Configuration()
            .addClass(Blog.class)
            .addClass(BlogItem.class);
        new SchemaExport(cfg).create(true, true);
    }
    
    public Blog createBlog(String name) throws HibernateException {
        
        Blog blog = new Blog();
        blog.setName(name);
        blog.setItems( new ArrayList() );
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.save(blog);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return blog;
    }
    
    public BlogItem createBlogItem(Blog blog, String title, String text)
                        throws HibernateException {
        
        BlogItem item = new BlogItem();
        item.setTitle(title);
        item.setText(text);
        item.setBlog(blog);
        item.setDatetime( Calendar.getInstance() );
        blog.getItems().add(item);
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.update(blog);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return item;
    }
    
    public BlogItem createBlogItem(Long blogid, String title, String text)
                        throws HibernateException {
        
        BlogItem item = new BlogItem();
        item.setTitle(title);
        item.setText(text);
        item.setDatetime( Calendar.getInstance() );
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            Blog blog = (Blog) session.load(Blog.class, blogid);
            item.setBlog(blog);
            blog.getItems().add(item);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return item;
    }
    
    public void updateBlogItem(BlogItem item, String text)
                    throws HibernateException {
        
        item.setText(text);
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.update(item);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
    }
    
    public void updateBlogItem(Long itemid, String text)
                    throws HibernateException {
    
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            BlogItem item = (BlogItem) session.load(BlogItem.class, itemid);
            item.setText(text);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
    }
    
    public List listAllBlogNamesAndItemCounts(int max)
                    throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        List result = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "select blog.id, blog.name, count(blogItem) " +
                "from Blog as blog " +
                "left outer join blog.items as blogItem " +
                "group by blog.name, blog.id " +
                "order by max(blogItem.datetime)"
            );
            q.setMaxResults(max);
            result = q.list();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return result;
    }
    
    public Blog getBlogAndAllItems(Long blogid)
                    throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        Blog blog = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "from Blog as blog " +
                "left outer join fetch blog.items " +
                "where blog.id = :blogid"
            );
            q.setParameter("blogid", blogid);
            blog  = (Blog) q.list().get(0);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return blog;
    }
    
    public List listBlogsAndRecentItems() throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        List result = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "from Blog as blog " +
                "inner join blog.items as blogItem " +
                "where blogItem.datetime &gt; :minDate"
            );

            Calendar cal = Calendar.getInstance();
            cal.roll(Calendar.MONTH, false);
            q.setCalendar("minDate", cal);
            
            result = q.list();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return result;
    }
}</PRE></DIV></DIV>
<DIV class=chapter lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A name=example-mappings></A>Chapter&nbsp;18.&nbsp;Example: 
Various Mappings</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>This chapters shows off some more complex association mappings. </P>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=example-mappings-emp></A>18.1.&nbsp;Employer/Employee</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>The following model of the relationship between <TT 
class=literal>Employer</TT> and <TT class=literal>Employee</TT> uses an actual 
entity class (<TT class=literal>Employment</TT>) to represent the association. 
This is done because there might be more than one period of employment for the 
same two parties. Components are used to model monetory values and employee 
names. </P>
<DIV class=mediaobject align=center><IMG 
src="Hibernate_files/EmployerEmployee.gif" align=middle></DIV>
<P>Heres a possible mapping document: </P><PRE class=programlisting>&lt;hibernate-mapping&gt;
        
    &lt;class name="Employer" table="employers"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employer_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

    &lt;class name="Employment" table="employment_periods"&gt;

        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employment_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="startDate" column="start_date"/&gt;
        &lt;property name="endDate" column="end_date"/&gt;

        &lt;component name="hourlyRate" class="MonetoryAmount"&gt;
            &lt;property name="amount"&gt;
                &lt;column name="hourly_rate" sql-type="NUMERIC(12, 2)"/&gt;
            &lt;/property&gt;
            &lt;property name="currency" length="12"/&gt;
        &lt;/component&gt;

        &lt;many-to-one name="employer" column="employer_id" not-null="true"/&gt;
        &lt;many-to-one name="employee" column="employee_id" not-null="true"/&gt;

    &lt;/class&gt;

    &lt;class name="Employee" table="employees"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employee_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="taxfileNumber"/&gt;
        &lt;component name="name" class="Name"&gt;
            &lt;property name="firstName"/&gt;
            &lt;property name="initial"/&gt;
            &lt;property name="lastName"/&gt;
        &lt;/component&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</PRE>
<P>And heres the table schema generated by <TT class=literal>SchemaExport</TT>. 
</P><PRE class=programlisting>create table employers (
    id BIGINT not null, 
    name VARCHAR(255), 
    primary key (id)
)

create table employment_periods (
    id BIGINT not null,
    hourly_rate NUMERIC(12, 2),
    currency VARCHAR(12), 
    employee_id BIGINT not null, 
    employer_id BIGINT not null, 
    end_date TIMESTAMP, 
    start_date TIMESTAMP, 
    primary key (id)
)

create table employees (
    id BIGINT not null, 
    firstName VARCHAR(255), 
    initial CHAR(1), 
    lastName VARCHAR(255), 
    taxfileNumber VARCHAR(255), 
    primary key (id)
)

alter table employment_periods 
    add constraint employment_periodsFK0 foreign key (employer_id) references employers
alter table employment_periods 
    add constraint employment_periodsFK1 foreign key (employee_id) references employees
create sequence employee_id_seq
create sequence employment_id_seq
create sequence employer_id_seq</PRE></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=example-mappings-authorwork></A>18.2.&nbsp;Author/Work</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Consider the following model of the relationships between <TT 
class=literal>Work</TT>, <TT class=literal>Author</TT> and <TT 
class=literal>Person</TT>. We represent the relationship between <TT 
class=literal>Work</TT> and <TT class=literal>Author</TT> as a many-to-many 
association. We choose to represent the relationship between <TT 
class=literal>Author</TT> and <TT class=literal>Person</TT> as one-to-one 
association. Another possibility would be to have <TT class=literal>Author</TT> 
extend <TT class=literal>Person</TT>. </P>
<DIV class=mediaobject align=center><IMG src="Hibernate_files/AuthorWork.gif" 
align=middle></DIV>
<P>The following mapping document correctly represents these relationships: </P><PRE class=programlisting>&lt;hibernate-mapping&gt;

    &lt;class name="Work" table="works" discriminator-value="W"&gt;

        &lt;id name="id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;discriminator column="type" type="character"/&gt;

        &lt;property name="title"/&gt;
        &lt;set name="authors" table="author_work" lazy="true"&gt;
            &lt;key&gt;
                &lt;column name="work_id" not-null="true"/&gt;
            &lt;/key&gt;
            &lt;many-to-many class="Author"&gt;
                &lt;column name="author_id" not-null="true"/&gt;
            &lt;/many-to-many&gt;
        &lt;/set&gt;

        &lt;subclass name="Book" discriminator-value="B"&gt;
            &lt;property name="text"/&gt;
        &lt;/subclass&gt;

        &lt;subclass name="Song" discriminator-value="S"&gt;
            &lt;property name="tempo"/&gt;
            &lt;property name="genre"/&gt;
        &lt;/subclass&gt;

    &lt;/class&gt;

    &lt;class name="Author" table="authors"&gt;

        &lt;id name="id" column="id"&gt;
            &lt;!-- The Author must have the same identifier as the Person --&gt;
            &lt;generator class="assigned"/&gt; 
        &lt;/id&gt;

        &lt;property name="alias"/&gt;
        &lt;one-to-one name="person" constrained="true"/&gt;

        &lt;set name="works" table="author_work" inverse="true" lazy="true"&gt;
            &lt;key column="author_id"/&gt;
            &lt;many-to-many class="Work" column="work_id"/&gt;
        &lt;/set&gt;

    &lt;/class&gt;

    &lt;class name="Person" table="persons"&gt;
        &lt;id name="id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</PRE>
<P>There are four tables in this mapping. <TT class=literal>works</TT>, <TT 
class=literal>authors</TT> and <TT class=literal>persons</TT> hold work, author 
and person data respectively. <TT class=literal>author_work</TT> is an 
association table linking authors to works. Heres the table schema, as generated 
by <TT class=literal>SchemaExport</TT>. </P><PRE class=programlisting>create table works (
    id BIGINT not null generated by default as identity, 
    tempo FLOAT, 
    genre VARCHAR(255), 
    text INTEGER, 
    title VARCHAR(255), 
    type CHAR(1) not null, 
    primary key (id)
)

create table author_work (
    author_id BIGINT not null, 
    work_id BIGINT not null, 
    primary key (work_id, author_id)
)

create table authors (
    id BIGINT not null generated by default as identity, 
    alias VARCHAR(255), 
    primary key (id)
)

create table persons (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

alter table authors 
    add constraint authorsFK0 foreign key (id) references persons
alter table author_work 
    add constraint author_workFK0 foreign key (author_id) references authors
alter table author_work
    add constraint author_workFK1 foreign key (work_id) references works</PRE></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=example-mappings-customerorderproduct></A>18.3.&nbsp;Customer/Order/Product</H2></DIV></DIV>
<DIV></DIV></DIV>
<P>Now consider a model of the relationships between <TT 
class=literal>Customer</TT>, <TT class=literal>Order</TT> and <TT 
class=literal>LineItem</TT> and <TT class=literal>Product</TT>. There is a 
one-to-many association between <TT class=literal>Customer</TT> and <TT 
class=literal>Order</TT>, but how should we represent <TT 
class=literal>Order</TT> / <TT class=literal>LineItem</TT> / <TT 
class=literal>Product</TT>? I've chosen to map <TT class=literal>LineItem</TT> 
as an association class representing the many-to-many association between <TT 
class=literal>Order</TT> and <TT class=literal>Product</TT>. In Hibernate, this 
is called a composite element. </P>
<DIV class=mediaobject align=center><IMG 
src="Hibernate_files/CustomerOrderProduct.gif" align=middle></DIV>
<P>The mapping document: </P><PRE class=programlisting>&lt;hibernate-mapping&gt;

    &lt;class name="Customer" table="customers"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
        &lt;set name="orders" inverse="true" lazy="true"&gt;
            &lt;key column="customer_id"/&gt;
            &lt;one-to-many class="Order"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Order" table="orders"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="date"/&gt;
        &lt;many-to-one name="customer" column="customer_id"/&gt;
        &lt;list name="lineItems" table="line_items" lazy="true"&gt;
            &lt;key column="order_id"/&gt;
            &lt;index column="line_number"/&gt;
            &lt;composite-element class="LineItem"&gt;
                &lt;property name="quantity"/&gt;
                &lt;many-to-one name="product" column="product_id"/&gt;
            &lt;/composite-element&gt;
        &lt;/list&gt;
    &lt;/class&gt;

    &lt;class name="Product" table="products"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="serialNumber"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</PRE>
<P><TT class=literal>customers</TT>, <TT class=literal>orders</TT>, <TT 
class=literal>line_items</TT> and <TT class=literal>products</TT> hold customer, 
order, order line item and product data respectively. <TT 
class=literal>line_items</TT> also acts as an association table linking orders 
with products. </P><PRE class=programlisting>create table customers (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

create table orders (
    id BIGINT not null generated by default as identity, 
    customer_id BIGINT, 
    date TIMESTAMP, 
    primary key (id)
)

create table line_items (
    line_number INTEGER not null, 
    order_id BIGINT not null, 
    product_id BIGINT, 
    quantity INTEGER, 
    primary key (order_id, line_number)
)

create table products (
    id BIGINT not null generated by default as identity, 
    serialNumber VARCHAR(255), 
    primary key (id)
)

alter table orders 
    add constraint ordersFK0 foreign key (customer_id) references customers
alter table line_items
    add constraint line_itemsFK0 foreign key (product_id) references products
alter table line_items
    add constraint line_itemsFK1 foreign key (order_id) references orders</PRE></DIV></DIV>
<DIV class=chapter lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A name=best-practices></A>Chapter&nbsp;19.&nbsp;Best 
Practices</H2></DIV></DIV>
<DIV></DIV></DIV>
<DIV class=variablelist>
<DL>
  <DT><SPAN class=term>Write fine-grained classes and map them using <TT 
  class=literal>&lt;component&gt;</TT>.</SPAN>
  <DD>
  <P>Use an <TT class=literal>Address</TT> class to encapsulate <TT 
  class=literal>street</TT>, <TT class=literal>suburb</TT>, <TT 
  class=literal>state</TT>, <TT class=literal>postcode</TT>. This encourages 
  code reuse and simplifies refactoring. </P>
  <DT><SPAN class=term>Declare identifier properties on persistent 
  classes.</SPAN>
  <DD>
  <P>Hibernate makes identifier properties optional. There are all sorts of 
  reasons why you should use them. We recommend that identifiers be 'synthetic' 
  (generated, with no business meaning) and of a non-primitive type. For maximum 
  flexibility, use <TT class=literal>java.lang.Long</TT> or <TT 
  class=literal>java.lang.String</TT>. </P>
  <DT><SPAN class=term>Place each class mapping in its own file.</SPAN>
  <DD>
  <P>Don't use a single monolithic mapping document. Map <TT 
  class=literal>com.eg.Foo</TT> in the file <TT 
  class=literal>com/eg/Foo.hbm.xml</TT>. This makes particularly good sense in a 
  team environment. </P>
  <DT><SPAN class=term>Load mappings as resources.</SPAN>
  <DD>
  <P>Deploy the mappings along with the classes they map. </P>
  <DT><SPAN class=term>Consider externalising query strings.</SPAN>
  <DD>
  <P>This is a good practice if your queries call non-ANSI-standard SQL 
  functions. Externalising the query strings to mapping files will make the 
  application more portable. </P>
  <DT><SPAN class=term>Use bind variables.</SPAN>
  <DD>
  <P>As in JDBC, always replace non-constant values by "?". Never use string 
  manipulation to bind a non-constant value in a query! Even better, consider 
  using named parameters in queries. </P>
  <DT><SPAN class=term>Don't manage your own JDBC connections.</SPAN>
  <DD>
  <P>Hibernate lets the application manage JDBC connections. This approach 
  should be considered a last-resort. If you can't use the built-in connections 
  providers, consider providing your own implementation of <TT 
  class=literal>net.sf.hibernate.connection.ConnectionProvider</TT>. </P>
  <DT><SPAN class=term>Consider using a custom type.</SPAN>
  <DD>
  <P>Suppose you have a Java type, say from some library, that needs to be 
  persisted but doesn't provide the accessors needed to map it as a component. 
  You should consider implementing <TT 
  class=literal>net.sf.hibernate.UserType</TT>. This approach frees the 
  application code from implementing transformations to / from a Hibernate type. 
  </P>
  <DT><SPAN class=term>Use hand-coded JDBC in bottlenecks.</SPAN>
  <DD>
  <P>In performance-critical areas of the system, some kinds of operations (eg. 
  mass update / delete) might benefit from direct JDBC. But please, wait until 
  you <SPAN class=emphasis><EM>know</EM></SPAN> something is a bottleneck. And 
  don't assume that direct JDBC is necessarily faster. If need to use direct 
  JDBC, it might be worth opening a Hibernate <TT class=literal>Session</TT> and 
  using that SQL connection. That way you can still use the same transaction 
  strategy and underlying connection provider. </P>
  <DT><SPAN class=term>Understand <TT class=literal>Session</TT> 
flushing.</SPAN>
  <DD>
  <P>From time to time the Session synchronizes its persistent state with the 
  database. Performance will be affected if this process occurs too often. You 
  may sometimes minimize unnecessary flushing by disabling automatic flushing or 
  even by changing the order of queries and other operations within a particular 
  transaction. </P>
  <DT><SPAN class=term>In a three tiered architecture, consider using <TT 
  class=literal>saveOrUpdate()</TT>.</SPAN>
  <DD>
  <P>When using a servlet / session bean architecture, you could pass persistent 
  objects loaded in the session bean to and from the servlet / JSP layer. Use a 
  new session to service each request. Use <TT 
  class=literal>Session.update()</TT> or <TT 
  class=literal>Session.saveOrUpdate()</TT> to update the persistent state of an 
  object. </P>
  <DT><SPAN class=term>In a two tiered architecture, consider using session 
  disconnection.</SPAN>
  <DD>
  <P>When using a servlet only, you may reuse the same session for multiple 
  client requests. Just remember to disconnect the session before returning 
  control to the client. </P>
  <DT><SPAN class=term>Don't treat exceptions as recoverable.</SPAN>
  <DD>
  <P>This is more of a necessary practice than a "best" practice. When an 
  exception occurs, roll back the <TT class=literal>Transaction</TT> and close 
  the <TT class=literal>Session</TT>. If you don't, Hibernate can't guarantee 
  that in-memory state accurately represents persistent state. As a special case 
  of this, do not use <TT class=literal>Session.load()</TT> to determine if an 
  instance with the given identifier exists on the database; use <TT 
  class=literal>find()</TT> instead. </P>
  <DT><SPAN class=term>Prefer lazy fetching for associations.</SPAN>
  <DD>
  <P>Use eager (outer-join) fetching sparingly. Use proxies and/or lazy 
  collections for most associations to classes that are not cached at the 
  JVM-level. For associations to cached classes, where there is a high 
  probability of a cache hit, explicitly disable eager fetching using <TT 
  class=literal>outer-join="false"</TT>. When an outer-join fetch is appropriate 
  to a particular use case, use a query with a <TT class=literal>left join</TT>. 
  </P>
  <DT><SPAN class=term>Consider abstracting your business logic from 
  Hibernate.</SPAN>
  <DD>
  <P>Hide (Hibernate) data-access code behind an interface. Combine the <SPAN 
  class=emphasis><EM>DAO</EM></SPAN> and <SPAN class=emphasis><EM>Thread Local 
  Session</EM></SPAN> patterns. You can even have some classes persisted by 
  handcoded JDBC, associated to Hibernate via a <TT class=literal>UserType</TT>. 
  (This advice is intended for "sufficiently large" applications; it is not 
  appropriate for an application with five tables!) 
</P></DD></DL></DIV></DIV></DIV></BODY></HTML>
